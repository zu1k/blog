---
title: Taint-Style Vulnerablities
date: 2020-10-20T13:40:04+08:00
draft: true
---

如果程序没有对用户的输入进行检查，经过精心构造的输入在传播到安全敏感的位置就有可能产生溢出、泄露等安全问题

来看一个真实世界的例子，在2014年的时候广为使用的OpenSSL爆出了心脏出血漏洞（CVE-2014-0160, Heartbleed)

该漏洞的产生原因非常简单，没有对用户传过来的长度信息进行检查，在后面进行 `memcpy` 的时候直接使用了用户输入的长度，用户通过输入一个较大的长度，来偷取服务器内存中的敏感信息

相关细节和代码见：

- [CVE-2014-0160](https://git.openssl.org/gitweb/?p=openssl.git&a=search&h=refs%2Fheads%2FOpenSSL_1_0_1-stable&st=commit&s=cve-2014-0160)
- [补丁：Add heartbeat extension bounds check](https://git.openssl.org/gitweb/?p=openssl.git;a=blobdiff;f=ssl/d1_both.c;h=2e8cf681ed0976e2b16460170fda27c77cfec6cc;hp=7a5596a6b373aeabbd6d8d674f0e20b1618c5012;hb=96db9023b881d7cd9f379b0c154650d6c108e9a3;hpb=0d7717fc9c83dafab8153cbd5e2180e6e04cc802)

## 污染型漏洞

OpenSSL的心脏出血漏洞便是典型的污染型漏洞

污染型漏洞有三个关键点：

- Source
- Sanitizers
- Sinks

Source是污染源，是用户可以控制的输入，不受信任的数据和参数从这里引入程序中

Sanitizers是杀毒处理，是一些约束和检查，防止有害信息继续传播，很明显污染性漏洞并没有进行杀毒

Sinks是一些安全敏感的函数，比如memcpy、strcpy、sprintf等

这三部分组成了三元组

## 污点分析

针对上面说的用户输入恶意数据，在程序的某个安全敏感位置造成安全隐患，最原始的避免办法就是人工审计代码，追踪用户输入可以到达的任何位置，判断在到达Sink前有没有进行Sanitizer处理

人工的方法费时费力，所以便需要利用程序自动追踪数据的传播路径，这便是污点(传播)分析技术

通过对要分析的数据（一般是用户输入）打上污点标记，通过追踪污点数据在程序中的流向，可以得到数据能够影响的程序操作，通过判断受影响的操作有无安全风险、数据是否被Sink使用，来挖掘污染型漏洞

污点分析技术按照分析**对象**和分析**方法**主要分为两种：**静态污点分析**、**动态污点分析**

### 静态污点分析

静态污点分析不需要执行目标程序，分析对象主要是程序的源代码、中间代码、调用树、依赖树、抽象语法树

### 动态污点分析

